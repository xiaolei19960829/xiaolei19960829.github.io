<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【JUC并发编程】：（2）锁理解、集合类的并发使用、JUC三个辅助类、读写锁、阻塞队列</title>
    <url>/2020/03/01/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E9%94%81%E7%90%86%E8%A7%A3%E3%80%81%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8%E3%80%81JUC%E4%B8%89%E4%B8%AA%E8%BE%85%E5%8A%A9%E7%B1%BB%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="1、锁理解"><a href="#1、锁理解" class="headerlink" title="1、锁理解"></a>1、锁理解</h3><ul>
<li><p>问题：如何判断锁的是谁？永远的知道什么锁，锁到底锁的是谁！</p>
</li>
<li><p>深刻理解我们的锁</p>
</li>
<li><p>synchronized:锁的对象是方法的调用者，同个对象适用同一把锁会陷入等待</p>
</li>
<li><p>static修饰后，锁的是class类，而不是原来的方法锁了。</p>
</li>
</ul>
<h3 id="2、集合类不安全"><a href="#2、集合类不安全" class="headerlink" title="2、集合类不安全"></a>2、集合类不安全</h3><ul>
<li>2.1、List不安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//java.util.ConcurrentModificationException</span><br><span class="line">public class ListTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 并发下arrayList不安全的</span><br><span class="line">         * 解决方案：</span><br><span class="line">         * 1、arrayList-&gt;vector</span><br><span class="line">         * 2、借助工具类:</span><br><span class="line">         * List list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">         * 3、juc包下： List list = new CopyOnWriteArrayList() ;</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //CopyOnWrite:写入时复制 COW 计算机程序设计领域的一种优化策略</span><br><span class="line">        //多个程序调用的时候，List ，读取的时候，固定的写入（覆盖）</span><br><span class="line">        //在写入的时候避免覆盖，造成数据问题</span><br><span class="line">        //CopyOnWriteArrayList比vector好在哪？答：只要有Synchronized效率低</span><br><span class="line">        List list = new CopyOnWriteArrayList() ;</span><br><span class="line">        for (int i = 1; i &lt;=20; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">                &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.2、set不安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//java.util.ConcurrentModificationException</span><br><span class="line">    //解决方法1：Set set= Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">    //解决方法2：写入时复制，CopyOnWriteArraySet</span><br><span class="line">public class SetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //HashSet set = new HashSet();</span><br><span class="line">        //Set set= Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">        CopyOnWriteArraySet set = new CopyOnWriteArraySet();</span><br><span class="line">        for (int i = 1; i &lt; 50; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">                &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>hashset的底层：hashmap</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">     map = new HashMap&lt;&gt;();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       return map.put(e, PRESENT)==null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.3、map不安全<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//并发解决：</span><br><span class="line">// 1.ConcurrentHashMap,</span><br><span class="line">// 2、 HashMap mao = Collections.synchronizedMap()</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt;= 30; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,4));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3、Callable（简单）"><a href="#3、Callable（简单）" class="headerlink" title="3、Callable（简单）"></a>3、Callable（简单）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泛型的参数等于方法的返回值</li>
</ul>
<p>例子：<br>问：怎么起的callable 答：callable本身不与thread直接联系，但是可以借助runable中的一个实现类，可以完成联系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CallableTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    //问：怎么起的callable 答：callable本身不与thread直接联系，</span><br><span class="line">     // 但是可以借助runable中的一个实现类，可以完成联系</span><br><span class="line">    //new Thread(new FutureTask&lt;V&gt;(Callable)).start();</span><br><span class="line">        new Thread().start();</span><br><span class="line"></span><br><span class="line">        MyThread thread=new MyThread();</span><br><span class="line">        //适配类,本质就是一个runable</span><br><span class="line">        FutureTask futureTask = new FutureTask(thread);</span><br><span class="line">        new Thread(futureTask,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        String o = (String) futureTask.get();//获取callable的返回结果</span><br><span class="line">        //get方法可能产生阻塞，方法里面可能会有耗时的操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;12&quot;);</span><br><span class="line">        return &quot;13&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、JUC常用的辅助类"><a href="#4、JUC常用的辅助类" class="headerlink" title="4、JUC常用的辅助类"></a>4、JUC常用的辅助类</h3><h5 id="4-1-CountDownLatch：减法计数器"><a href="#4-1-CountDownLatch：减法计数器" class="headerlink" title="4.1 CountDownLatch：减法计数器"></a>4.1 CountDownLatch：减法计数器</h5><ul>
<li>public class CountDownLatch<br>extends Object</li>
<li>一种同步帮助，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。 </li>
<li>一个CountDownLatch与给定数初始化。的await方法块直到当前计数达到零的countDown()方法调用，之后，所有等待的线程，释放任何后续的调用await立即返回。这是一一个镜头的现象-计数不能被重置。如果你需要一个版本，重置计数，考虑使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: XiaoLei</span><br><span class="line"> * @Date Created in 20:39 2020/3/1</span><br><span class="line"> * 案例说明：6个线程，等他们都输出go out 之后，才能输出close door</span><br><span class="line"> */</span><br><span class="line">//计数器</span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //总数是6，倒计时完毕会进行一个操作</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(6);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;go out&quot;);</span><br><span class="line">                countDownLatch.countDown();//计数器-1</span><br><span class="line">                &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(); //等到计数器归零，然后再向下执行</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;close door&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：<ul>
<li>countDownLatch.countDown();//计数器-1</li>
<li>countDownLatch.await(); //等到计数器归零，然后再向下执行</li>
<li>每次有线程调用countDown（）数量-1，假设计数器变为0，countDownLatch.await（）就会被唤醒，继续执行</li>
</ul>
</li>
</ul>
<h5 id="4-2-CycliBarrier：加法计数器"><a href="#4-2-CycliBarrier：加法计数器" class="headerlink" title="4.2 CycliBarrier：加法计数器"></a>4.2 CycliBarrier：加法计数器</h5><ul>
<li><p>一个同步帮助，允许一组线程相互等待，以达到一个共同的障碍点。cyclicbarriers涉及一个固定大小的线程必须党偶尔互相等待程序是有用的。该障碍被称为循环，因为它可以在等待线程被释放后重新使用。 </p>
</li>
<li><p>一个CyclicBarrier支持一个可选的Runnable命令，每个障碍点一次，在聚会的最后一个线程到达后，但在任何线程释放。这种障碍作用是有用的更新共享状态之前，任何一方继续。</p>
</li>
<li><p>案例：集齐七颗龙珠召唤神龙</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;召唤成功！&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;=7; i++) &#123;</span><br><span class="line">            final int temp=i;//lambda不能操作到i</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;收集了&quot;+temp+&quot;个龙珠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();//等待</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：await等待它计数，如果达到这个数字，就会开启另一条线程去执行</li>
</ul>
<h5 id="4-3-Semaphore"><a href="#4-3-Semaphore" class="headerlink" title="4.3 Semaphore"></a>4.3 Semaphore</h5><ul>
<li><p>一个计数信号量，在概念上，信号量维持一组许可证，如果有必要，每个acquire（）都会阻塞，知道许可证可用，然后才能使用它。</p>
</li>
<li><p>案例：抢车位 6车抢三个车位置</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //线程数量：抽象为停车位! 限流的时候</span><br><span class="line">        Semaphore semaphore = new Semaphore(3);</span><br><span class="line">        for (int i = 1; i &lt;=6; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                //acquire()得到</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;得到了该车位&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;离开车位&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    //release()释放</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理：</p>
<ul>
<li>acquire（）获得，假设如果已经满了，等待，等待被释放位置</li>
<li>release：释放，会将当前的信号释放+1，然后唤醒等待的线程。</li>
<li>作用：多个共享资源互斥的使用！并发限流</li>
</ul>
<h3 id="5、读写锁"><a href="#5、读写锁" class="headerlink" title="5、读写锁"></a>5、读写锁</h3><p><img src="D5C880CD63A749F6A222EC1929971746" alt="image"></p>
<ul>
<li>ReadWriteLock<ul>
<li>独占锁(写锁)：一次只能被一个线程占有</li>
<li>共享锁（读锁）：多个线程可以同时占有。</li>
</ul>
</li>
<li>读与读：可以共存</li>
<li>读与写：不能共存</li>
<li>写与写：不能共存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        MyCache myCache = new MyCache();</span><br><span class="line">        MyCatchLock myCache = new MyCatchLock();</span><br><span class="line"></span><br><span class="line">        //写入</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int temp=i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(temp+&quot;&quot;,temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //读取</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int temp=i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyCatchLock&#123;</span><br><span class="line">    private volatile Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">    //加了个读写锁，更加细粒度的控制</span><br><span class="line">    private ReadWriteLock lock=new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    //存，写，写入的时候，只希望同时只有一个线程写</span><br><span class="line">    public void put(String key,Object value)&#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;写入ok&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //取，读</span><br><span class="line">    public void get(String key)&#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key);</span><br><span class="line">            Object o=map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;读取ok&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义缓存</span><br><span class="line"> */</span><br><span class="line">class MyCache&#123;</span><br><span class="line">    private volatile Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //存，写</span><br><span class="line">    public void put(String key,Object value)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key);</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;写入ok&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //取，读</span><br><span class="line">    public void get(String key)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key);</span><br><span class="line">        Object o=map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、阻塞队列"><a href="#6、阻塞队列" class="headerlink" title="6、阻塞队列"></a>6、阻塞队列</h3><ul>
<li><p>写入：如果队列满了，就必须阻塞等待</p>
</li>
<li><p>读取：如果队列是空的，必须阻塞等待生产<br><img src="3931D64693864EDA8EFF1CBE16F89BA9" alt="image"></p>
</li>
<li><p>BlockingQueue 不是新东西，和set ，list平级都属于Collection类下的接口<br><img src="C2BCAF017A0A42D1AFB3721AF355F800" alt="image"></p>
</li>
<li><p>学会使用队列：添加、移除</p>
</li>
<li><p>四组API</p>
<ul>
<li>1、抛出异常</li>
<li>2、不会抛出异常</li>
<li>3、阻塞，等待</li>
<li>4、超时等待</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>不会抛出异常，有返回值</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer()</td>
<td>put()</td>
<td>offer(,,)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>poll()</td>
<td>take()</td>
<td>poll(,,)</td>
</tr>
<tr>
<td>检查队首元素</td>
<td>element</td>
<td>peek</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>第一种：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 抛出异常</span><br><span class="line">     */</span><br><span class="line">    public static void test1()&#123;</span><br><span class="line">        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">        System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">        System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line">//        System.out.println(blockingQueue.add(&quot;d&quot;));</span><br><span class="line">//        java.lang.IllegalStateException</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===========&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">//        java.util.NoSuchElementException</span><br><span class="line">//        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二种</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void test2()&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">        System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">        System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">        System.out.println(blockingQueue.offer(&quot;d&quot;));//返回false，没有异常</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;==========&quot;);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());//null 没有异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三种方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void test3() throws InterruptedException &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">        blockingQueue.put(&quot;a&quot;);</span><br><span class="line">        blockingQueue.put(&quot;b&quot;);</span><br><span class="line">        blockingQueue.put(&quot;c&quot;);</span><br><span class="line">//        blockingQueue.put(&quot;d&quot;);//找到没有位置了，一直等待</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">//        System.out.println(blockingQueue.take());//没有这个位置，一直等待</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第四种：超时等待<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test4() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3);</span><br><span class="line"></span><br><span class="line">    blockingQueue.offer(&quot;a&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;b&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;c&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;d&quot;, 2,TimeUnit.SECONDS);//等待两秒没位置退出</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;========&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="同步队列：SynchronousQueue"><a href="#同步队列：SynchronousQueue" class="headerlink" title="同步队列：SynchronousQueue"></a>同步队列：SynchronousQueue</h5></li>
<li>没有容量，进去一个元素，必须等待取出来之后，才能再往里面放入元素</li>
<li>SynchronousQueue，只存储一个元素</li>
<li>put存，take取</li>
</ul>]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【JUC并发编程】：（1）JUC入门</title>
    <url>/2020/02/29/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89JUC%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h3><ul>
<li>java.util.concurrent ：工具包、分类</li>
<li>业务：普通的线程代码：Thread<ul>
<li>Runnable:没有返回值，效率相比Callable相对较低</li>
</ul>
</li>
</ul>
<h3 id="2、线程和进程"><a href="#2、线程和进程" class="headerlink" title="2、线程和进程"></a>2、线程和进程</h3><ul>
<li>进程：一个程序，程序的集合<ul>
<li>一个进程可以包含多个线程，至少包含一个</li>
<li>java默认有几个线程？2个main和GC</li>
</ul>
</li>
<li>线程：开了一个进程<ul>
<li>java真的可以开启线程吗？开不了，因为java是运行在虚拟机上的，开启的是本地方法。</li>
</ul>
</li>
<li>并发：多线程同时操作同一个资源</li>
<li>并行：多个人一起行走，多个线程可以同时执行；线程池</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取cpu的核数</span><br><span class="line">        //cpu 密集型，IO密集型</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发编程的本质：<strong>充分利用cpu的资源</strong></p>
<ul>
<li>线程有几个状态？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEW,//新生</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">RUNNABLE,//运行</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">BLOCKED,//阻塞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WAITING,//等待，死死等待</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">TIMED_WAITING,//超时等待</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TERMINATED;//终止</span><br></pre></td></tr></table></figure>
<ul>
<li>wait和sleep的区别？<ul>
<li>1、来自不同的类<ul>
<li>wait=》object</li>
<li>sleep=》Thread</li>
</ul>
</li>
<li>2、关于锁的释放<ul>
<li>wait会释放锁</li>
<li>sleep不会释放</li>
</ul>
</li>
<li>3、使用范围是不同的<ul>
<li>wait：必须在同步代码块中</li>
<li>sleep可以在任何地方睡</li>
</ul>
</li>
<li>4、是否需要捕获异常<ul>
<li>wait不需要捕获异常</li>
<li>sleep必须要捕获异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、lock锁"><a href="#3、lock锁" class="headerlink" title="3、lock锁"></a>3、lock锁</h3><h5 id="3-1-传统的Synchronized："><a href="#3-1-传统的Synchronized：" class="headerlink" title="3.1 传统的Synchronized："></a>3.1 传统的Synchronized：</h5><ul>
<li>卖票案例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SaleTicketDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //并发：多个线程操作同个资源，把资源类丢入线程</span><br><span class="line">       Ticket ticket = new Ticket();</span><br><span class="line">       //@FunctionalInterface 函数式接口，jdk8，lambda表达式（参数）-&gt;&#123; 代码&#125;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程一&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程二&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程三&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//资源类 oop:属性+方法</span><br><span class="line">class Ticket&#123;</span><br><span class="line">    private int number=50;</span><br><span class="line"></span><br><span class="line">    public void sale()&#123;</span><br><span class="line">        if(number&gt;0)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+number--+&quot;票，还剩：&quot;+number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/code/juc/juc1.png" alt="image"></p>
<ul>
<li>可以看到不加锁是由问题的，我们可以加上锁，并发就是多个线程操作同个资源。</li>
</ul>
<h5 id="3-2-Lock锁"><a href="#3-2-Lock锁" class="headerlink" title="3.2 Lock锁"></a>3.2 Lock锁</h5><ul>
<li><p>思路：加锁，finally-&gt;解锁</p>
</li>
<li><p>lock锁的三个实现类：<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/code/juc/juc2.png" alt="image"></p>
</li>
<li><p>ReentrantLock的底层<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/code/juc/juc3.png" alt="image"></p>
</li>
<li><p>公平锁：十分公平：可以先来后到。</p>
</li>
<li><p><strong>非公平锁：十分不公平，可以插队（默认）。</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SaleTicketDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //并发：多个线程操作同个资源，把资源类丢入线程</span><br><span class="line">        Ticket2 ticket = new Ticket2();</span><br><span class="line">        //@FunctionalInterface 函数式接口，jdk8，lambda表达式（参数）-&gt;&#123; 代码&#125;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程一&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程二&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程三&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Lock</span><br><span class="line">class Ticket2&#123;</span><br><span class="line">    private int number=50;</span><br><span class="line">    Lock lock =new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public  void sale()&#123;</span><br><span class="line">        lock.lock();//加锁</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //业务代码</span><br><span class="line">            if(number&gt;0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+number--+&quot;票，还剩：&quot;+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();//解锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-Synchronized和Lock的区别"><a href="#3-3-Synchronized和Lock的区别" class="headerlink" title="3.3 Synchronized和Lock的区别"></a>3.3 Synchronized和Lock的区别</h5><ol>
<li>Synchronized内置的java关键字，Lock是一个java类</li>
<li>Synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁</li>
<li>Synchronized会自动释放锁，Lock必须要手动释放锁，如果不释放锁，死锁。</li>
<li>Synchronized 线程1（获得锁，阻塞）、线程2（死死的等）；Lock锁就不一定会等待下去</li>
<li>Synchronized 可重入锁，不可以中断，非公平；Lock，可重入锁，可以判断锁，非公平（可以自己设置）</li>
<li>Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码。</li>
</ol>
<h5 id="3-4思考：-锁是什么？如何判断锁的是谁？"><a href="#3-4思考：-锁是什么？如何判断锁的是谁？" class="headerlink" title="3.4思考： 锁是什么？如何判断锁的是谁？"></a>3.4思考： 锁是什么？如何判断锁的是谁？</h5><h3 id="4、生产者和消费者问题"><a href="#4、生产者和消费者问题" class="headerlink" title="4、生产者和消费者问题"></a>4、生产者和消费者问题</h3><h5 id="4-1-传统版"><a href="#4-1-传统版" class="headerlink" title="4.1 传统版"></a>4.1 传统版</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程之间的通信问题：生产者和消费者问题! 等待唤醒和通知唤醒</span><br><span class="line"> * 线程交替执行   A B操作同一个变量  num=0</span><br><span class="line"> * A    num+1</span><br><span class="line"> * B    num-1</span><br><span class="line"> */</span><br><span class="line">public class A &#123; //线程类，操作资源类</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data = new Data();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程A&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//等待，业务，通知</span><br><span class="line">class  Data&#123;//数字，资源类</span><br><span class="line">    private int number=0;</span><br><span class="line"></span><br><span class="line">    //+1</span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        if(number!=0)&#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+number);</span><br><span class="line">        //通知其他线程+1完了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    //-1</span><br><span class="line">    public  synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        if(number==0)&#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+number);</span><br><span class="line">        //通知线程，我-1完成了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题存在，要是有abcd 四个线程安全吗？存在<strong>虚假唤醒</strong>问题！！</p>
</li>
<li><p>虚假唤醒：线程可以唤醒，而不会被通知，中断或超时。等待应该出现在循环中</p>
</li>
<li><p>解决：把if判断改成while判断</p>
</li>
</ul>
<h5 id="4-2-JUC版"><a href="#4-2-JUC版" class="headerlink" title="4.2 JUC版"></a>4.2 JUC版</h5><p><img src="6792926C3386459EBB0C7B03CCDAFA91" alt="image"><br>condition.awati();//等待<br>conditon.signalAll();//唤醒全部</p>
<ul>
<li>代码实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程之间的通信问题：生产者和消费者问题! 等待唤醒和通知唤醒</span><br><span class="line"> * 线程交替执行   A B操作同一个变量  num=0</span><br><span class="line"> * A    num+1</span><br><span class="line"> * B    num-1</span><br><span class="line"> */</span><br><span class="line">public class B &#123; //线程类，操作资源类</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data2 data = new Data2();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程A&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//等待，业务，通知</span><br><span class="line">class  Data2&#123;//数字，资源类</span><br><span class="line">    private int number=0;</span><br><span class="line"></span><br><span class="line">    Lock lock=new ReentrantLock();</span><br><span class="line">    Condition condition=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    //+1</span><br><span class="line">    public  void increment() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            while (number!=0)&#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+number);</span><br><span class="line">            //通知其他线程+1完了</span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //-1</span><br><span class="line">    public   void decrement() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number==0)&#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+number);</span><br><span class="line">            //通知线程，我-1完成了</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，优势和补充。</li>
<li>Condition的优势？：可以精准的通知和唤醒</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class C &#123; //线程类，操作资源类</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data3 data = new Data3();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125; &#125;,&quot;A&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            data.printB();</span><br><span class="line">        &#125; &#125;,&quot;B&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;  for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            data.printC();</span><br><span class="line">        &#125;&#125;,&quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//等待，业务，通知</span><br><span class="line">class  Data3&#123;//数字，资源类</span><br><span class="line">    private int number=1;</span><br><span class="line"></span><br><span class="line">    Lock lock=new ReentrantLock();</span><br><span class="line">    Condition condition1=lock.newCondition();</span><br><span class="line">    Condition condition2=lock.newCondition();</span><br><span class="line">    Condition condition3=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void printA()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number!=1)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+&quot;AA&quot;);</span><br><span class="line">            number=2;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printB()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number!=2)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+&quot;BBB&quot;);</span><br><span class="line">            number=3;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printC()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number!=3)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+&quot;CC&quot;);</span><br><span class="line">            number=1;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【mybaits】：(3) 动态sql</title>
    <url>/2020/02/28/%E3%80%90Mybatis%E3%80%91%EF%BC%9A%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81sql/</url>
    <content><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>传统的使用JDBC的方法，相信大家在组合复杂的的SQL语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误。Mybatis的动态SQL功能正是为了解决这种问题， 其通过 if, choose, when, otherwise, trim, where, set, foreach标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率。</p>
<h3 id="2、动态标签"><a href="#2、动态标签" class="headerlink" title="2、动态标签"></a>2、动态标签</h3><h5 id="2-1-if"><a href="#2-1-if" class="headerlink" title="2.1 if"></a>2.1 if</h5><pre><code>- 例如，根据username和sex来查询数据。如果username为空，那么将只根据sex来查询；反之只根据username来查询。
- 首先不使用动态sql来书写</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot;</span><br><span class="line">        resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    &lt;!-- 这里和普通的sql 查询语句差不多，对于只有一个参数，后面的 #&#123;id&#125;表示占位符，里面不一定要写id,</span><br><span class="line">            写啥都可以，但是不要空着，如果有多个参数则必须写pojo类里面的属性 --&gt;</span><br><span class="line">    select * from user where username=#&#123;username&#125; and sex=#&#123;sex&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的查询语句，我们可以发现，如果#{username}为空，那么查询结构也是空，如何解决这个问题呢？使用if来判断</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    select * from user where</span><br><span class="line">        &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">           username=#&#123;username&#125;</span><br><span class="line">        &lt;/if&gt;      </span><br><span class="line">        &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">           and sex=#&#123;sex&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样写我们可以看到，如果 sex 等于 null，那么查询语句为 select * from user where username=#{username},但是如果usename 为空呢？那么查询语句为 select * from user where and sex=#{sex}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句。</li>
</ul>
<h5 id="2-2-where"><a href="#2-2-where" class="headerlink" title="2.2 where"></a>2.2 where</h5><ul>
<li><p>这个where标签会知道如果他包含的标签中有返回值的话，它就插入一个where。此外，如果标签返回的内容是and或or开头的，则它会剔除掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">           username=#&#123;username&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">         </span><br><span class="line">        &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">           and sex=#&#123;sex&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-if-set"><a href="#2-3-if-set" class="headerlink" title="2.3 if+set"></a>2.3 if+set</h5></li>
<li><p>同理，上面的对于查询SQL语句包含where关键字，如果在进行更新操作的时候，含有set关键字，我们怎么处理呢？</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span><br><span class="line">&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    update user u</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;</span><br><span class="line">                u.username = #&#123;username&#125;,</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;</span><br><span class="line">                u.sex = #&#123;sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">     </span><br><span class="line">     where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<p>这样写，</p>
<ul>
<li>如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex=? where id=?</li>
<li>如果第一个条件不为空，那么 sql 语句为：update user u set u.username = ? ,u.sex = ? where id=?</li>
</ul>
<h5 id="2-4-choose（when，otherwise）语句"><a href="#2-4-choose（when，otherwise）语句" class="headerlink" title="2.4 choose（when，otherwise）语句"></a>2.4 choose（when，otherwise）语句</h5><ul>
<li>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用choose标签可以解决此类问题，类似Java的switch语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByChoose&quot; resultType=&quot;com.ys.po.User&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">      select * from user</span><br><span class="line">      &lt;where&gt;</span><br><span class="line">          &lt;choose&gt;</span><br><span class="line">              &lt;when test=&quot;id !=&apos;&apos; and id != null&quot;&gt;</span><br><span class="line">                  id=#&#123;id&#125;</span><br><span class="line">              &lt;/when&gt;</span><br><span class="line">              &lt;when test=&quot;username !=&apos;&apos; and username != null&quot;&gt;</span><br><span class="line">                  and username=#&#123;username&#125;</span><br><span class="line">              &lt;/when&gt;</span><br><span class="line">              &lt;otherwise&gt;</span><br><span class="line">                  and sex=#&#123;sex&#125;</span><br><span class="line">              &lt;/otherwise&gt;</span><br><span class="line">          &lt;/choose&gt;</span><br><span class="line">      &lt;/where&gt;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>也就是说，这里我们有三个条件，id，username，sex，只能选择一个作为查询条件</li>
<li>如果id不为空，那么查询语句为：select * from user where  id=?</li>
<li>如果 id 为空，那么看username 是否为空，如果不为空，那么语句为 select * from user where  username=?;</li>
<li>如果 username 为空，那么查询语句为 select * from user where sex=?</li>
</ul>
<h5 id="2-5trim语句"><a href="#2-5trim语句" class="headerlink" title="2.5trim语句"></a>2.5trim语句</h5><ul>
<li>trim标记是一个格式化的标记，可以完成set或者是where标记的功能。</li>
<li>1、用trim改写上面第二点的if+where语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">        select * from user</span><br><span class="line">        &lt;!-- &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">               username=#&#123;username&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">             </span><br><span class="line">            &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">               and sex=#&#123;sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;  --&gt;</span><br><span class="line">        &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&gt;</span><br><span class="line">            &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">               and username=#&#123;username&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">               and sex=#&#123;sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/trim&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>prefix：前缀<br>prefixOverride：去掉第一个and或者是or</p>
<ul>
<li>2、用trim改写上面第三点的if+set语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span><br><span class="line">    &lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">        update user u</span><br><span class="line">            &lt;!-- &lt;set&gt;</span><br><span class="line">                &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;</span><br><span class="line">                    u.username = #&#123;username&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;</span><br><span class="line">                    u.sex = #&#123;sex&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/set&gt; --&gt;</span><br><span class="line">            &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">                &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;</span><br><span class="line">                    u.username = #&#123;username&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;</span><br><span class="line">                    u.sex = #&#123;sex&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/trim&gt;</span><br><span class="line">         </span><br><span class="line">         where id=#&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>suffix：后缀　　</li>
<li>suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样）</li>
</ul>
<h5 id="2-6-sql片段"><a href="#2-6-sql片段" class="headerlink" title="2.6 sql片段"></a>2.6 sql片段</h5><ul>
<li>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</li>
<li>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义 sql 片段 --&gt;</span><br><span class="line">&lt;sql id=&quot;selectUserByUserNameAndSexSQL&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;</span><br><span class="line">        AND username = #&#123;username&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;</span><br><span class="line">        AND sex = #&#123;sex&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用sql片段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&gt;</span><br><span class="line">        &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;</span><br><span class="line">        &lt;include refid=&quot;selectUserByUserNameAndSexSQL&quot;&gt;&lt;/include&gt;</span><br><span class="line">        &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>【注意】：最好基于单表定义sql片段，提高片段的可重用性；在sql片段中最好不要包括where</li>
</ul>
<h5 id="2-7foreach语句"><a href="#2-7foreach语句" class="headerlink" title="2.7foreach语句"></a>2.7foreach语句</h5><ul>
<li>需求：我们需要查询user表id分为1,2,3的用户</li>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where id=1 or id=2 or id=3</span><br><span class="line">　　　　　　 select * from user where id in (1,2,3)</span><br></pre></td></tr></table></figure>
<ol>
<li>建立一个UserVo类，里面封装一个List<integer>ids的属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ys.vo;</span><br><span class="line"> </span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class UserVo &#123;</span><br><span class="line">    //封装多个用户的id</span><br><span class="line">    private List&lt;Integer&gt; ids;</span><br><span class="line"> </span><br><span class="line">    public List&lt;Integer&gt; getIds() &#123;</span><br><span class="line">        return ids;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setIds(List&lt;Integer&gt; ids) &#123;</span><br><span class="line">        this.ids = ids;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>我们用 foreach 来改写 select * from user where id=1 or id=2 or id=3</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id=&quot;selectUserByListId&quot; parameterType=&quot;com.ys.vo.UserVo&quot; resultType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            collection:指定输入对象中的集合属性</span><br><span class="line">            item:每次遍历生成的对象</span><br><span class="line">            open:开始遍历时的拼接字符串</span><br><span class="line">            close:结束时拼接的字符串</span><br><span class="line">            separator:遍历对象之间需要拼接的字符串</span><br><span class="line">            select * from user where 1=1 and (id=1 or id=2 or id=3)</span><br><span class="line">          --&gt;</span><br><span class="line">        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            id=#&#123;id&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>==【注意】：在mapper文件中写sql语句时，遇到特殊字符时，如：&lt; 等，建议使用<![CDATA[ sql 语句 ]]>标记，将sql语句包裹住，不被解析器解析==</p>
<h3 id="3、项目sql实例"><a href="#3、项目sql实例" class="headerlink" title="3、项目sql实例"></a>3、项目sql实例</h3><ul>
<li>统计个数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;countSkillInfoTYB&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">    select count(tb.id)</span><br><span class="line">    from ss_user_skill_info_tyb tb</span><br><span class="line">    &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND|OR &quot;&gt;</span><br><span class="line">        &lt;if test=&quot;state !=null&quot;&gt;</span><br><span class="line">            and tb.state=#&#123;state&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into ss_skill_tag</span><br><span class="line">&lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;tagName != null&quot; &gt;</span><br><span class="line">        tag_name,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;url != null&quot; &gt;</span><br><span class="line">        url,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;sortNum != null&quot; &gt;</span><br><span class="line">        sort_num,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;status != null&quot; &gt;</span><br><span class="line">        status,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    add_date</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;content != null&quot; &gt;</span><br><span class="line">        #&#123;content&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;url != null&quot; &gt;</span><br><span class="line">        #&#123;url&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;sortNum != null&quot; &gt;</span><br><span class="line">        #&#123;sortNum&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;status != null&quot; &gt;</span><br><span class="line">        #&#123;status&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    now()</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>【mybaits】：(2) 配置解析</title>
    <url>/2020/02/28/%E3%80%90Mybatis%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="1、核心配置文件"><a href="#1、核心配置文件" class="headerlink" title="1、核心配置文件"></a>1、核心配置文件</h3><ul>
<li>能配置的内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">    properties（属性）</span><br><span class="line">    settings（设置）</span><br><span class="line">    typeAliases（类型别名）</span><br><span class="line">    typeHandlers（类型处理器）</span><br><span class="line">    objectFactory（对象工厂）</span><br><span class="line">    plugins（插件）</span><br><span class="line">    environments（环境配置）</span><br><span class="line">        environment（环境变量）</span><br><span class="line">            transactionManager（事务管理器）</span><br><span class="line">            dataSource（数据源）</span><br><span class="line">    databaseIdProvider（数据库厂商标识）</span><br><span class="line">    mappers（映射器）</span><br><span class="line">&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2、environments元素"><a href="#2、environments元素" class="headerlink" title="2、environments元素"></a>2、environments元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">  &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">    &lt;transactionManager type=&quot;JDBC&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;</span><br><span class="line">    &lt;/transactionManager&gt;</span><br><span class="line">    &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">    &lt;/dataSource&gt;</span><br><span class="line">  &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置MyBatis的多套运行环境，将Sql映射到多个不同的数据库上，必须指定其中一个位默认运行环境（通过default指定）</li>
<li>子元素节点：environment<ul>
<li>具体的一套环境，通过设置id进行区别，id保证唯一。</li>
</ul>
</li>
<li>子元素节点：transactionManager【事务管理器】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 语法 --&gt;</span><br><span class="line">&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>子元素节点：数据源（datasource）<ul>
<li>dataSource元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源。</li>
</ul>
</li>
</ul>
<h3 id="3、mapper元素"><a href="#3、mapper元素" class="headerlink" title="3、mapper元素"></a>3、mapper元素</h3><ul>
<li><p>映射器：定义映射SQL语句文件</p>
</li>
<li><p>告诉mybatis去哪找这些语句,该标签可以指定xxxMapper.xml的文件路径，也就是集中管理sql语句的文件。</p>
</li>
<li><p>引入资源方式：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">使用映射器接口实现类的完全限定类名</span><br><span class="line">需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">将包内的映射器接口实现全部注册为映射器</span><br><span class="line">但是需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>namespace+id可以限定唯一的标签</li>
<li>namespace要写成映射包中对应接口的全类名。</li>
<li>id就是方法名，同一个映射文件中的id不能重复</li>
<li>resultType是返回值要封装的类型，javaBean和普通类型都可以选择写全类名、或者简写。</li>
<li>接口中的方法名要和我们的namespace下的id对应起来。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--namespace要写成接口的全类名--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;cskaoyan.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;queryUserByName&quot; resultType=&quot;cskaoyan.User&quot;&gt;</span><br><span class="line">        select id,username,password,age,email from user where username = #&#123;as&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>



<h3 id="4、Properties（属性配置项）优化"><a href="#4、Properties（属性配置项）优化" class="headerlink" title="4、Properties（属性配置项）优化"></a>4、Properties（属性配置项）优化</h3><ul>
<li>在外面单独通过<properties>为数据源配置信息，可以降低datasource的配置项的耦合度，方便修改。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=123456</span><br><span class="line">url=jdbc:mysql://localhost:3306/mybatis</span><br><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">=================================================================</span><br><span class="line">&lt;properties resource=&quot;db.properties&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;jdbcurl&quot; value=&quot;jdbc:mysql://localhost:3306/mydb2?serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">================================================================</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">        &lt;!--这里暂时指定通过JDBC实现事务，这就需要我们手动提交、关闭 --&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5、typeAliases优化"><a href="#5、typeAliases优化" class="headerlink" title="5、typeAliases优化"></a>5、typeAliases优化</h3><ul>
<li>类型别名是为Java类型设置一个短的名字，不太好用。</li>
<li>方法一：直接指定全类名的别名。type写javabean的全类名；alias写别名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;typeAlias type=&quot;cskaoyan.User&quot; alias=&quot;xl&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br><span class="line">=====================================================================</span><br><span class="line">具体使用</span><br><span class="line">&lt;select id=&quot;queryUserById&quot; resultType=&quot;xl&quot;&gt;</span><br><span class="line">  select id,username,password,age,email from user where id = #&#123;abc&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：指定某个包，这个包内的全类名，默认简写就是类名的首字母小写【批量配置别名】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;package name=&quot;cskaoyan&quot;&gt;&lt;/package&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br><span class="line">====================================================================================</span><br><span class="line">具体使用</span><br><span class="line">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">  select id,username,password,age,email from user where id = #&#123;abc&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法三：基本类型的默认别名</p>
<ul>
<li>八大基本类型在类型前加上下划线_</li>
<li>包装基本类型就是首字母小写</li>
</ul>
</li>
<li><p>方法四：注解的方式设置类简称：@Alias</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Alias(&quot;xl&quot;)</span><br><span class="line">public class people&#123;</span><br><span class="line">    String id;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectPeople&quot; resultType=&quot;xl&quot;&gt;</span><br><span class="line">    select * from ddd;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6、setting设置"><a href="#6、setting设置" class="headerlink" title="6、setting设置"></a>6、setting设置</h3><ul>
<li>重点：<ul>
<li>懒加载</li>
<li>日志实现</li>
<li>缓存开启关闭</li>
</ul>
</li>
<li>完整的settings元素的实例如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7、生命周期和作用域"><a href="#7、生命周期和作用域" class="headerlink" title="7、生命周期和作用域"></a>7、生命周期和作用域</h3><ul>
<li><p>生命周期、作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
</li>
<li><p>SqlSessionFactoryBuilder：</p>
<ul>
<li>一旦创建了sqlSessionFactory，就不再需要它了</li>
<li>局部变量</li>
</ul>
</li>
<li><p>SqlSessionFactory：</p>
<ul>
<li>说白了就是可以想象为：数据库连接池。</li>
<li>一旦创建就应该在应用的运行期间一直存在，没有任何理由对其它或重新创建另一个实例。</li>
<li>因此sqlSessionFactory的最佳作用域是应用作用域，程序开始就开始，程序结束就结束。</li>
<li>最简单的就是使用单例模式或者静态单例模式</li>
</ul>
</li>
<li><p>sqlsession：</p>
<ul>
<li>sqlsession的实例不是线程安全的，因此不能被共享，所以它的最佳作用域是请求或方法作用域。</li>
<li></li>
</ul>
</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2347803678.png" alt="image"></p>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>【mybaits】：(1) Mybatis简介</title>
    <url>/2020/02/28/%E3%80%90Mybatis%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89Mybatis%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="1、Mybatis介绍"><a href="#1、Mybatis介绍" class="headerlink" title="1、Mybatis介绍"></a>1、Mybatis介绍</h3><ul>
<li><p>Object relationship mapping 对象关系映射</p>
</li>
<li><p>映射关系：将数据中和java对象联系起来。</p>
</li>
<li><p>对比jdbc：</p>
<ul>
<li>定制化sql：更能适应业务复杂度（灵活的修改sql）</li>
<li>进行动态sql ：（sql语句的部分可以根据不同的条件出现）</li>
<li>分离sql集中管理：可以把SQL语句放在配置文件中，进行集中管理。这个配置文件叫做Mapping映射文件，多个映射文件分别管理不同的模块</li>
<li>mybatis对参数和结果的封装处理更完善，使用更方便 直接封装成对应的类型</li>
<li>输出映射：把数据库查询出来的数据记录，封装成结果集：可以是基本类型、数组、集合或JavaBean······</li>
<li>输入映射：把参数的值交给SQL语句，去数据库中查询对应的记录。</li>
</ul>
</li>
<li><p>实际上就是把：sql语句暴露给开发者，自己去写，其他的封装起来。去修改非常方便（增删改查都是我们自己来写）</p>
</li>
<li><p>Mybatis是一款持久层框架，它支持定制化sql（灵活的修改）、存储过程（函数）、以及高级映射（javabean和数据库对象的映射–&gt;输入映射和输出映射）。Mybatis避免了几乎所有的jdbc代码和手动设置参数以及获取结果集。</p>
</li>
<li><p>Mybatis可以使用简单的XML或注解来配置和映射原生信息。</p>
</li>
<li><p>将接口和java的POJOs映射成数据库中的记录</p>
</li>
</ul>
<h3 id="2、第一个程序"><a href="#2、第一个程序" class="headerlink" title="2、第一个程序"></a>2、第一个程序</h3><ul>
<li>1、搭建数据库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE `mybatis`;</span><br><span class="line"></span><br><span class="line">USE `mybatis`;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(20) NOT NULL,</span><br><span class="line">  `name` varchar(30) DEFAULT NULL,</span><br><span class="line">  `pwd` varchar(30) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert  into `user`(`id`,`name`,`pwd`) values (1,&apos;狂神&apos;,&apos;123456&apos;),(2,&apos;张三&apos;,&apos;abcdef&apos;),(3,&apos;李四&apos;,&apos;987654&apos;);</span><br></pre></td></tr></table></figure>
<ul>
<li>2、导入Mybatis相关的jar包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、编写mybatis核心配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、编写mybatis工具类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class MybatisUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取SqlSession连接</span><br><span class="line">    public static SqlSession getSession()&#123;</span><br><span class="line">        return sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这是一个建造者的生产模式：</p>
<ul>
<li>1、首先通过Resource.getResourceAsStream（）获取输入流，参数为mybatis配置文件</li>
<li>2、然后new一个SqlSessionFactoryBuilder，创建一个 工厂的建造者</li>
<li>3、工厂建造者对象调用build（）方法获取一个Sqlsession工厂对象，参数是之前得到的输入流</li>
<li>4、工厂对象调用openSession()方法，获取一个sqlSesson对象。</li>
<li>5、sqlSesson对象可以调用各种sql语句，其中本例中查询一个记录就是selectOne（）</li>
</ul>
</li>
</ul>
<ul>
<li>5、创建实体类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    </span><br><span class="line">    private int id;  //id</span><br><span class="line">    private String name;   //姓名</span><br><span class="line">    private String pwd;   //密码</span><br><span class="line">    </span><br><span class="line">    //构造,有参,无参</span><br><span class="line">    //set/get</span><br><span class="line">    //toString()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6、编写Mapper接口类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.kuang.pojo.User;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    List&lt;User&gt; selectUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>7、编写Mapper.xml配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt;</span><br><span class="line">  &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>8、编写测试类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void selectUser() &#123;</span><br><span class="line">        SqlSession session = MybatisUtils.getSession();</span><br><span class="line">        //方法一:</span><br><span class="line">        //List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);</span><br><span class="line">        //方法二:</span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; users = mapper.selectUser();</span><br><span class="line"></span><br><span class="line">        for (User user: users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h3><ul>
<li><p>namespace：名称为对应Mapper接口或者Dao接口的完整包名。</p>
</li>
<li><p>select：</p>
<ul>
<li>接口中的方法名与映射文件中的sql语句id一一对应</li>
<li>parameterType：传入SQL语句的参数类型。【万能的Map，参数多的时候多使用】</li>
<li>resultType：Sql语句返回值类型【完整的类名】</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>insert：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">     insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>update：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">    update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>delete：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">    delete from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>所有的增删改操作都需要提交事务</li>
<li>接口的所有普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上</li>
<li>有时候根据业务的需求，可以考虑map传递参数</li>
<li>为了规范操作，在sql配置文件中，我们尽量将Parameter参数和resultType都写上</li>
</ol>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】：代理模式</title>
    <url>/2020/02/27/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul>
<li>为什么要学该模式？因为这就是SpringAop的底层</li>
<li>代理模式的分类：<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
</li>
</ul>
<h3 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h3><ul>
<li><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的对象</li>
<li>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
</li>
<li><p>静态代理的好处：</p>
<ul>
<li>可以使我们的真实角色更加纯粹，不再关注一些公众的事情</li>
<li>公共的业务由代理来完成，实现了业务的分工</li>
<li>公共业务发生扩展时会变得更加集中方便。</li>
</ul>
</li>
<li><p>静态代理的缺点：</p>
<ul>
<li>多了代理类，工作量变大。</li>
</ul>
</li>
</ul>
<h3 id="3、静态代理的例子理解"><a href="#3、静态代理的例子理解" class="headerlink" title="3、静态代理的例子理解"></a>3、静态代理的例子理解</h3><ol>
<li>创建一个抽象角色。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//抽象角色：增删改查业务</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void add();</span><br><span class="line">    void delete();</span><br><span class="line">    void update();</span><br><span class="line">    void query();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>真实对象完成这些操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//真实对象，完成增删改查操作的人</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;增加了一个用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        System.out.println(&quot;删除了一个用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;更新了一个用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void query() &#123;</span><br><span class="line">        System.out.println(&quot;查询了一个用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>增加一个日志功能</li>
<li>设置一个代理类来处理日志</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代理角色，在这里面增加日志的实现</span><br><span class="line">public class UserServiceProxy implements UserService &#123;</span><br><span class="line">    private UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    public void setUserService(UserServiceImpl userService) &#123;</span><br><span class="line">        this.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        log(&quot;add&quot;);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        log(&quot;delete&quot;);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        log(&quot;update&quot;);</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void query() &#123;</span><br><span class="line">        log(&quot;query&quot;);</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试访问类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //真实业务</span><br><span class="line">        UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">        //代理类</span><br><span class="line">        UserServiceProxy proxy = new UserServiceProxy();</span><br><span class="line">        //使用代理类实现日志功能！</span><br><span class="line">        proxy.setUserService(userService);</span><br><span class="line"></span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、动态代理"><a href="#4、动态代理" class="headerlink" title="4、动态代理"></a>4、动态代理</h3><ul>
<li><p>动态代理的角色和静态代理的一样</p>
</li>
<li><p>动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类：一类是基于接口动态代理，一类是基于类的动态代理</p>
<ul>
<li>基于接口:jdk动态代理</li>
<li>基于类：cglib</li>
</ul>
</li>
<li><p>jdk动态代理需要了解两个类：</p>
</li>
</ul>
<p>核心 : InvocationHandler 和 Proxy</p>
<h5 id="【InvocationHandler：调用处理程序】"><a href="#【InvocationHandler：调用处理程序】" class="headerlink" title="【InvocationHandler：调用处理程序】"></a>【InvocationHandler：调用处理程序】</h5><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1738839022.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object invoke(Object proxy, 方法 method, Object[] args)；</span><br><span class="line">//参数 </span><br><span class="line">//proxy - 调用该方法的代理实例 </span><br><span class="line">//method -所述方法对应于调用代理实例上的接口方法的实例。 方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 </span><br><span class="line">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。 原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span><br></pre></td></tr></table></figure>

<h5 id="【Proxy：代理】"><a href="#【Proxy：代理】" class="headerlink" title="【Proxy：代理】"></a>【Proxy：代理】</h5><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3889331720.png" alt="image"><br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2362460967.png" alt="image"><br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/269587194.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//生成代理类</span><br><span class="line">public Object getProxy()&#123;</span><br><span class="line">    return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">                                  rent.getClass().getInterfaces(),this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、动态代理代码实现"><a href="#5、动态代理代码实现" class="headerlink" title="5、动态代理代码实现"></a>5、动态代理代码实现</h3><ol>
<li>抽象角色（接口）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//抽象角色：租房</span><br><span class="line">public interface Rent &#123;</span><br><span class="line">    public void rent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>真实角色</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">房东，房东要出租房子</span><br><span class="line">public class Host implements Rent&#123;</span><br><span class="line">    public void rent() &#123;</span><br><span class="line">        System.out.println(&quot;房屋出租&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.ProxyInvocationHandler. java 即代理角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProxyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Rent rent;</span><br><span class="line"></span><br><span class="line">    public void setRent(Rent rent) &#123;</span><br><span class="line">        this.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span><br><span class="line">    public Object getProxy()&#123;</span><br><span class="line">        return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">                rent.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span><br><span class="line">    // 处理代理实例上的方法调用并返回结果</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        //核心：本质利用反射实现！</span><br><span class="line">        Object result = method.invoke(rent, args);</span><br><span class="line">        fare();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //看房</span><br><span class="line">    public void seeHouse()&#123;</span><br><span class="line">        System.out.println(&quot;带房客看房&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //收中介费</span><br><span class="line">    public void fare()&#123;</span><br><span class="line">        System.out.println(&quot;收中介费&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.客户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//租客</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //真实角色</span><br><span class="line">        Host host = new Host();</span><br><span class="line">        //代理实例的调用处理程序</span><br><span class="line">        ProxyInvocationHandler pih = new ProxyInvocationHandler();</span><br><span class="line">        pih.setRent(host); //将真实角色放置进去！</span><br><span class="line">        Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>核心：一个动态代理可以代理多个类，代理的是接口。</p>
</li>
<li><p>动态代理的好处：</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
</li>
</ul>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（6）AOP</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%886%EF%BC%89AOP/</url>
    <content><![CDATA[<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><ul>
<li>面向切面编程，是一种通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。是函数式编程的一种衍生范型，利用AOP可以对业务逻辑的各个部分进行隔离，实现各部分之间的解耦。<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1595583263.png" alt="image"></li>
</ul>
<h3 id="2、AOP在Spring中的作用"><a href="#2、AOP在Spring中的作用" class="headerlink" title="2、AOP在Spring中的作用"></a>2、AOP在Spring中的作用</h3><p><strong>==提供声明式事务：允许用户自定义切面==</strong></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。就是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…</li>
<li>切面（ASPECT）：横切关注点，被模块化的特殊对象，它是一个类</li>
<li>通知（Advice）：切面必须要完成的工作。它是类中的一个方法</li>
<li>目标（Target）：被通知对象</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象</li>
<li>切入点（PointCut）：切面通知 执行的地点的定义</li>
<li>连接点（jointPoint）：与切入点匹配的执行点</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/142667477.png" alt="image"></p>
<h3 id="3、使用Spring实现AOP"><a href="#3、使用Spring实现AOP" class="headerlink" title="3、使用Spring实现AOP"></a>3、使用Spring实现AOP</h3><h5 id="3-1-通过Spring-API实现"><a href="#3-1-通过Spring-API实现" class="headerlink" title="3.1 通过Spring API实现"></a>3.1 通过Spring API实现</h5><ul>
<li>首先编写我们的业务接口和实现类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add();</span><br><span class="line"></span><br><span class="line">    public void delete();</span><br><span class="line"></span><br><span class="line">    public void update();</span><br><span class="line"></span><br><span class="line">    public void search();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;增加用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        System.out.println(&quot;删除用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;更新用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void search() &#123;</span><br><span class="line">        System.out.println(&quot;查询用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后去写我们的增强类，一个前置增强，一个后置增强。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Log implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">    //method : 要执行的目标对象的方法</span><br><span class="line">    //objects : 被调用的方法的参数</span><br><span class="line">    //Object : 目标对象</span><br><span class="line">    @Override</span><br><span class="line">    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">        System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AfterLog implements AfterReturningAdvice &#123;</span><br><span class="line">    //returnValue 返回值</span><br><span class="line">    //method被调用的方法</span><br><span class="line">    //args 被调用的方法的对象的参数</span><br><span class="line">    //target 被调用的目标对象</span><br><span class="line">    @Override</span><br><span class="line">    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行了&quot; + target.getClass().getName()</span><br><span class="line">        +&quot;的&quot;+method.getName()+&quot;方法,&quot;</span><br><span class="line">        +&quot;返回值：&quot;+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后去spring的文件中注册，并实现aop切入实现，注意导入约束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册bean--&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--aop的配置--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--切入点  expression:表达式匹配要执行的方法--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">        &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.search();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</li>
</ul>
<h5 id="3-2-自定义类来实现AOP"><a href="#3-2-自定义类来实现AOP" class="headerlink" title="3.2 自定义类来实现AOP"></a>3.2 自定义类来实现AOP</h5><ul>
<li>第一步：写我们自己的一个切入类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DiyPointcut &#123;</span><br><span class="line"></span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>去spring配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="line">&lt;!--注册bean--&gt;</span><br><span class="line">&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--aop的配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;diy&quot;&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;</span><br><span class="line">        &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-使用注解实现"><a href="#3-3-使用注解实现" class="headerlink" title="3.3 使用注解实现"></a>3.3 使用注解实现</h5><ul>
<li>编写注解实现的增强类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class AnnotationPointcut &#123;</span><br><span class="line">    @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;环绕前&quot;);</span><br><span class="line">        System.out.println(&quot;签名:&quot;+jp.getSignature());</span><br><span class="line">        //执行目标方法proceed</span><br><span class="line">        Object proceed = jp.proceed();</span><br><span class="line">        System.out.println(&quot;环绕后&quot;);</span><br><span class="line">        System.out.println(proceed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：在spring配置文件中，注册bean，并增加支持注解的配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="line">&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>
<p>op:aspectj-autoproxy：说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 </span><br><span class="line"></span><br><span class="line">&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（5）Bean的自动装配</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%885%EF%BC%89Bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h3 id="1、Bean的自动装配"><a href="#1、Bean的自动装配" class="headerlink" title="1、Bean的自动装配"></a>1、Bean的自动装配</h3><ul>
<li>自动装配是Spring满足bean依赖的一种方式！</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在spring中有三种装配的方式：</p>
<ul>
<li>在xml中显示的配置</li>
<li>在java中显示配置</li>
<li>隐式的自动装配【重要】</li>
</ul>
<h3 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h3><p>环境搭建：一个人有两个宠物。</p>
<h3 id="3、自动装配"><a href="#3、自动装配" class="headerlink" title="3、自动装配"></a>3、自动装配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;cat&quot; class=&quot;xiaolei.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;xiaolei.pojo.Dog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">byname:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id,如果相同，则自动装配</span><br><span class="line">byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;people&quot; class=&quot;xiaolei.pojo.People&quot; autowire=&quot;byName&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>【小结】：</p>
<ul>
<li>byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致。</li>
<li>bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。</li>
</ul>
<h3 id="4、使用注解自动装配"><a href="#4、使用注解自动装配" class="headerlink" title="4、使用注解自动装配"></a>4、使用注解自动装配</h3><p>要使用注解须知：<br>1、导入约束：content约束<br>2、配置注解的支持：==<strong><a href="context:annotation-config" target="_blank" rel="noopener">context:annotation-config</a></strong>==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean definitions here --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.cskaoyan&quot;&gt;   &lt;/context:component-scan&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><ul>
<li>@Autowired 是按类型自动装配的，不支持id匹配。</li>
<li>需要导入Spring-aop的包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//如果允许对象为null，设置required = false,默认为true</span><br><span class="line">@Autowired(required = false)</span><br><span class="line">private Cat cat;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用</li>
</ul>
<p>测试：</p>
<ul>
<li>1.配置文件修改内容，保证类型存在对象，且名字不为类的默认名字！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.没有加Qualifier测试，直接报错。</li>
<li>3.在属性上添加Qualifier注解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;cat2&quot;)</span><br><span class="line">private Cat cat;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;dog2&quot;)</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、成功输出</li>
</ul>
<h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：(4)spring Bean的生命周期</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%884%EF%BC%89Spring%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<img width="769px" height="369px" src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/%E7%BE%8E%E5%9B%BE/1bffb1a3f9f12ff2a0b3a0c2f83d9eeb_5be671fc13d35.jpg"/>

<h3 id="1、Bean的完整生命周期"><a href="#1、Bean的完整生命周期" class="headerlink" title="1、Bean的完整生命周期"></a>1、Bean的完整生命周期</h3><ul>
<li>在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean 的实例化，然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。</li>
<li>相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强，下面展示了一个Bean的构造过程</li>
</ul>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java0-1558500658.jpg" alt="image"></p>
<p>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</p>
<p> 1、实例化一个Bean－－也就是我们常说的new；</p>
<p> 2、按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；</p>
<p> 3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值</p>
<p> 4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</p>
<p> 5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</p>
<p> 6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</p>
<p> 7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p>
<p> 8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；</p>
<p>  注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</p>
<p> 9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；</p>
<p> 10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p>
<h3 id="2、各种接口方法分类"><a href="#2、各种接口方法分类" class="headerlink" title="2、各种接口方法分类"></a>2、各种接口方法分类</h3><ul>
<li>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：<ul>
<li>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</li>
<li>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</li>
<li>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li>
<li>工厂后处理器接口方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（3）依赖注入</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%883%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<img width="769px" height="369px" src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/%E7%BE%8E%E5%9B%BE/1bffb1a3f9f12ff2a0b3a0c2f83d9eeb_5be671fc13d35.jpg"/>



<h3 id="1、依赖注入"><a href="#1、依赖注入" class="headerlink" title="1、依赖注入"></a>1、依赖注入</h3><ul>
<li>依赖：指Bean对象的创建依赖于容器，Bean对象的依赖资源。</li>
<li>注入：指Bean对象所依赖的资源，由容器来设置和装配。</li>
<li>依赖注入分为：构造器注入、setter注入（重点）、拓展注入实现。</li>
</ul>
<h3 id="2、构造器注入"><a href="#2、构造器注入" class="headerlink" title="2、构造器注入"></a>2、构造器注入</h3><ul>
<li>有参构造和无参构造。</li>
</ul>
<h3 id="3、setter注入"><a href="#3、setter注入" class="headerlink" title="3、setter注入"></a>3、setter注入</h3><p>【环境搭建】：</p>
<ul>
<li>两个pojo类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    //1、基本类型</span><br><span class="line">    private String name;</span><br><span class="line">    //2、引用类型</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] books;</span><br><span class="line">    private List&lt;String&gt; hobbies;</span><br><span class="line">    private Map&lt;String,String&gt; card;</span><br><span class="line">    private Set&lt;String&gt; games;</span><br><span class="line">    private String wife;</span><br><span class="line">    private Properties info;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(Address address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getBooks() &#123;</span><br><span class="line">        return books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBooks(String[] books) &#123;</span><br><span class="line">        this.books = books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getHobbies() &#123;</span><br><span class="line">        return hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHobbies(List&lt;String&gt; hobbies) &#123;</span><br><span class="line">        this.hobbies = hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, String&gt; getCard() &#123;</span><br><span class="line">        return card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCard(Map&lt;String, String&gt; card) &#123;</span><br><span class="line">        this.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; getGames() &#123;</span><br><span class="line">        return games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGames(Set&lt;String&gt; games) &#123;</span><br><span class="line">        this.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getWife() &#123;</span><br><span class="line">        return wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWife(String wife) &#123;</span><br><span class="line">        this.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Properties getInfo() &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInfo(Properties info) &#123;</span><br><span class="line">        this.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, address=&quot; + address.toString() +</span><br><span class="line">                &quot;, books=&quot; + Arrays.toString(books) +</span><br><span class="line">                &quot;, hobbies=&quot; + hobbies +</span><br><span class="line">                &quot;, card=&quot; + card +</span><br><span class="line">                &quot;, games=&quot; + games +</span><br><span class="line">                &quot;, wife=&apos;&quot; + wife + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, info=&quot; + info +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address&#123;&quot; +</span><br><span class="line">                &quot;address=&apos;&quot; + address + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beans.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;address&quot; class=&quot;xiaolei.pojo.Address&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;address&quot; value=&quot;上海&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;xiaolei.pojo.Student&quot;&gt;</span><br><span class="line">        &lt;!--第一种：普通值注入，value--&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">        &lt;!--第二种：Bean注入，ref注入--&gt;</span><br><span class="line">        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;</span><br><span class="line">        &lt;!--第三种：数组注入--&gt;</span><br><span class="line">        &lt;property name=&quot;books&quot;&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;《Java编程思想》&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;《Java多线程并发》&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;《深入学习Mysql》&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第四种：List集合数组--&gt;</span><br><span class="line">        &lt;property name=&quot;hobbies&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;喝奶茶&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;吃火锅&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;写代码&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第五种：Map集合--&gt;</span><br><span class="line">        &lt;property name=&quot;card&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;身份证&quot; value=&quot;121212&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;银行卡&quot; value=&quot;212121&quot;/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第六种：Set集合--&gt;</span><br><span class="line">        &lt;property name=&quot;games&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;LOL&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;CF&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;DNF&lt;/value&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--第七种：空值注入--&gt;</span><br><span class="line">        &lt;property name=&quot;wife&quot;&gt;</span><br><span class="line">            &lt;null/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第八种：properties--&gt;</span><br><span class="line">        &lt;property name=&quot;info&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;driver&quot;&gt;20192020&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;url&quot;&gt;男&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;username&quot;&gt;20192020&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        Student student = (Student) context.getBean(&quot;student&quot;);</span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&apos;潇雷&apos;, address=Address&#123;address=&apos;上海&apos;&#125;, books=[《Java编程思想》, 《Java多线程并发》, 《深入学习Mysql》], hobbies=[喝奶茶, 吃火锅, 写代码], card=&#123;身份证=121212, 银行卡=212121&#125;, games=[LOL, CF, DNF], wife=&apos;null&apos;, info=&#123;url=男, driver=20192020, username=20192020&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、拓展方式注入"><a href="#4、拓展方式注入" class="headerlink" title="4、拓展方式注入"></a>4、拓展方式注入</h3><ul>
<li>1、P命名空间注入：需要在头文件加入约束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; p:name=&quot;潇雷&quot; p:age=&quot;18&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>2、C命名空间注入：需要在头文件加入约束文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; c:name=&quot;潇雷&quot; p:age=&quot;18&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5、Bean的作用域"><a href="#5、Bean的作用域" class="headerlink" title="5、Bean的作用域"></a>5、Bean的作用域</h3><ul>
<li>在Spring中，那些组成应用程序的主体及由Spring ioc容器所管理的对象，被称为bean。简单的说，bean就是由ioc容器初始化、装配及管理的对象。</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/852070927.png" alt="image"></p>
<ul>
<li><p>几种作用域中，request，session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架）只能用在基于web的spring ApplicationContext环境。</p>
</li>
<li><p>1、单例模式（Spring默认机制）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; scope=&quot;singleton&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>2、原型模式：每次从容器中get的时候，都会产生一个新对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（2）第一个程序、ioc创建对象方式、spring配置</title>
    <url>/2020/02/25/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E3%80%81ioc%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F%E3%80%81spring%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1、第一个Spring程序"><a href="#1、第一个Spring程序" class="headerlink" title="1、第一个Spring程序"></a>1、第一个Spring程序</h2><ul>
<li>spring的xml配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>先写一个简单的pojo类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    private String str;</span><br><span class="line"></span><br><span class="line">    public String getStr() &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStr(String str) &#123;</span><br><span class="line">        this.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hello&#123;&quot; +</span><br><span class="line">                &quot;str=&apos;&quot; + str + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再在xml中配置bean：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--使用spring来创建对象，在spring这些都称为bean--&gt;</span><br><span class="line">&lt;bean id=&quot;hello&quot; class=&quot;xiaolei.pojo.Hello&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在测试类中，不需要创建Hello对象就获得：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取Spring的上下文对象！</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        //我们的对象现在都在spring中的管理了，我们要使用，直接去里面取出来就可以了</span><br><span class="line">        Hello hello = (Hello) context.getBean(&quot;hello&quot;);</span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong></p>
<ul>
<li>hello对象是谁创建的？答：hello对象是由spring创建的。</li>
<li>hello对象的属性是怎么设置的？答：hello对象的属性是由spring容器设置的。</li>
</ul>
<h2 id="2、ioc创建对象常见方式"><a href="#2、ioc创建对象常见方式" class="headerlink" title="2、ioc创建对象常见方式"></a>2、ioc创建对象常见方式</h2><h4 id="2-1-无参构造"><a href="#2-1-无参构造" class="headerlink" title="2.1 无参构造"></a>2.1 无参构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">    public User() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--注册无参构造--&gt;</span><br><span class="line">&lt;bean id=&quot;user2&quot; class=&quot;Bean.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;hahaha&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<property>标签给构造出来的无参对象赋值</li>
<li>这个便签内的name的值必须是类中存在的setter方法。</li>
<li>至于后面的ref，指向其他类型的bean，如果该bean已经被注册，则ref值指向该bean的id，如果该bean没有被注册，则写该bean的全类限定名。</li>
<li>当然，value也可以写在bean标签的外部，单独写一个标签。</li>
</ul>
<h4 id="2-2-有参构造"><a href="#2-2-有参构造" class="headerlink" title="2.2 有参构造"></a>2.2 有参构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public User(String username,String password)&#123;</span><br><span class="line">    this.password=password;</span><br><span class="line">    this.username=username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;bean.User&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;password&quot; value=&quot;123&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<constructor-arg>标签构造方法的参数</li>
<li>当是有参构造时，name的参数就是构造方法的形参名</li>
<li>如果这个参数变量是javabean，写ref</li>
<li>如果是基本类型，写value</li>
</ul>
<h2 id="3-spring配置"><a href="#3-spring配置" class="headerlink" title="3.spring配置"></a>3.spring配置</h2><h5 id="3-1-别名"><a href="#3-1-别名" class="headerlink" title="3.1 别名"></a>3.1 别名</h5><ul>
<li>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot;&gt;</span><br><span class="line">   &lt;constructor-arg name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;alias name=&quot;user&quot; alias=&quot;user2&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-Bean的配置"><a href="#3-2-Bean的配置" class="headerlink" title="3.2 Bean的配置"></a>3.2 Bean的配置</h5><ul>
<li>id:bean的唯一标识符，也就是java对象名。如果没有配置id，name就是默认标识符；如果配置了id，又配置了name，那么name是别名，name可以设置多个别名，可以用逗号，分号，空格隔开。</li>
<li>如果不配置id和name，可以根据applicationContext.getBean(.class)获取对象;</li>
<li>class:bean对象所对应的全限定名</li>
</ul>
<h5 id="3-3-import"><a href="#3-3-import" class="headerlink" title="3.3 import"></a>3.3 import</h5><ul>
<li>一般用于团队开发使用，它可以将多个配置文件，导入合并为一个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（1）概述、ioc理论</title>
    <url>/2020/02/25/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0%E3%80%81ioc%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><ul>
<li>Spring：春天-&gt;给软件行业带来了春天</li>
<li>2002年，首先推出Spring框架的雏形：interface21</li>
<li>2004年3月24号：在interface21框架上，发布了Spring框架的1.0版本</li>
<li>Rod Johnson：Spring Framework创始人,音乐学博士</li>
<li>Spring理念：本身就是大杂烩，整合现有的框架技术。</li>
</ul>
<p>官网：<a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">https://spring.io/projects/spring-framework</a></p>
<p>官方下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>Github：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></p>
<h2 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h2><ol>
<li>方便解耦，简化开发（高内聚，低耦合）</li>
<li>Spring是一个轻量级的、非侵入式的框架！非侵入式就是对原来的东西没有影响</li>
<li><strong>控制反转（ioc）、面向切面编程（AOP）</strong></li>
<li>支持事务的处理，对框架整合的支持</li>
</ol>
<p><strong>==总结一句话：Spring就是一个轻量级的控制反转（ioc）和面向切面编程的框架==</strong></p>
<h2 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h2><ul>
<li>spring框架是一个分层架构，由7个定义良好的模块组成，Spring模块构建在核心容器之上，核心容器定义了创建、配置和管理bean的方式。</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3294472123.png" alt="image"></p>
<ul>
<li>组成Sping框架的每个模块都可以单独存在，或者与其他一个或多个模块联合实现，每个模块的功能如下：<ul>
<li>核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
</li>
</ul>
<h2 id="1-4-ioc理论推导"><a href="#1-4-ioc理论推导" class="headerlink" title="1.4 ioc理论推导"></a>1.4 ioc理论推导</h2><h4 id="1-4-1-过去我们写代码："><a href="#1-4-1-过去我们写代码：" class="headerlink" title="1.4.1 过去我们写代码："></a>1.4.1 过去我们写代码：</h4><ul>
<li>1、先一个UserDao接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2、再去写Dao的实现类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;获取用户数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3、然后去写UserService的接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>4、最后写UserService的实现类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao = new UserDaoImpl();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、测试一下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    UserService service = new UserServiceImpl();</span><br><span class="line">    service.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这是我们原来的方式，如果在dao层在增加一个实现类，则需要更改service实现类的代码。如果大量增加实现类，大量更改service代码的话，这种方法也就不适用了。耦合性太高，牵一发而动全身！</p>
<h4 id="1-4-2-如何解决？"><a href="#1-4-2-如何解决？" class="headerlink" title="1.4.2 如何解决？"></a>1.4.2 如何解决？</h4><ul>
<li>我们可以在需要用到它的地方，不去实现它，而是留出一个接口，利用set，我们去代码里修改下。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    // 利用set实现</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改后，就不需要再动service里的代码，用户想调用什么就在外面直接调用。</p>
<ol>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用set注入后，程序不再具有主动性，而是变成可被动的接收到对象。</li>
</ol>
<ul>
<li>这种思想，从本质上解决了问题，外面程序员不再管理对象的创建，系统的耦合性大大降低，可以更加专注在业务的实现上，这就是ioc的原型。</li>
</ul>
<h2 id="1-5-ioc本质"><a href="#1-5-ioc本质" class="headerlink" title="1.5 ioc本质"></a>1.5 ioc本质</h2><ul>
<li>ioc：inverse of controller 控制反转，ioc是一种新的java编程模式。由Spring来负责控制对象的生命周期和对象间的关系，而不需要程序员来管理，Di是实现ioc的一种方法。</li>
<li>Spring容器在初始化时会读取配置文件，根据配置文件或元数据创建组织对象存入容器中，程序使用时从ioc容器中取出需要的对象</li>
</ul>
<p><strong>搞清楚几个问题：</strong></p>
<ul>
<li>谁依赖谁：应用程序依赖于ioc容器</li>
<li>为什么要依赖：应用程序需要ioc容器来提供对象需要的外部资源。</li>
<li>谁注入谁：IOC容器注入应用程序某个对象，应用程序依赖的对象。</li>
<li>注入了什么：注入了某个对象所需要的外部资源（包括对象、资源、常量数据）</li>
</ul>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【java基础】：反射机制</title>
    <url>/2020/02/18/%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="java基础之反射"><a href="#java基础之反射" class="headerlink" title="java基础之反射"></a>java基础之反射</h1><ul>
<li><strong>1、反射概述</strong></li>
<li><strong>2、获取class类型的对象</strong></li>
<li><strong>3、通过反射获取构造方法并使用</strong></li>
<li><strong>4、通过反射获取成员变量并使用</strong></li>
<li><strong>5、通过反射并获取成员方法并使用</strong></li>
</ul>
<h2 id="1、反射概述"><a href="#1、反射概述" class="headerlink" title="1、反射概述"></a>1、反射概述</h2><p>&emsp;&emsp;java不是动态 语言，但java可以被称为准动态语言，因为它的反射机制。而这个反射机制是java被视为动态语言的关键。反射机制允许程序在执行期间借助Reflection API取得任何类的内部消息，并能直接操作任意对象的内部属性及方法。加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称为：反射。</p>
<p><strong>优点</strong>：可以实现动态创建对象和编译，体现出很大的灵活性。</p>
<p><strong>缺点</strong>：对性能有影响，使用反射基本上是一种解析操作，我们可以告诉jvm，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p>
<h2 id="2、获取class类型对象"><a href="#2、获取class类型对象" class="headerlink" title="2、获取class类型对象"></a>2、获取class类型对象</h2><h3 id="2-1-java代码分析"><a href="#2-1-java代码分析" class="headerlink" title="2.1 java代码分析"></a>2.1 java代码分析</h3><p>java代码在计算机中经历有三个阶段。</p>
<p>第一阶段：源代码阶段。由程序员写的一个pojo类，假设为A，可以包含成员变量，构造方法，和成员方法。然后该类经过javac编译，生成了一个A.class的字节码文件。</p>
<p>第二阶段：class类对象阶段。这个阶段由类加载器ClassLoader加载得到一个class类的对象。该对象包含成员变量，构造方法以及成员方法。一个类只产生一个class对象。</p>
<p>第三阶段：运行时阶段。通过class类的这几个方法创建对象。反射的本质理解就是得到class对象后反向获取student对象的各种信息。</p>
<h2 id="2-2-如何得到class类对象"><a href="#2-2-如何得到class类对象" class="headerlink" title="2.2 如何得到class类对象"></a>2.2 如何得到class类对象</h2><p><strong>方式一：</strong> Object类的getClass（）方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">Class c = p.getClass();</span><br></pre></td></tr></table></figure>
<p><strong>方式二：</strong> 任何数据类型都有一个“静态”的class属性.</p>
<p>所有类型的class对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = Object.class;//对象</span><br><span class="line">        Class c2= Comparable.class;//接口</span><br><span class="line">        Class c3=String[].class;//数组</span><br><span class="line">        Class c4=int[][].class;//二维数组</span><br><span class="line">        Class c5=Override.class;//注解</span><br><span class="line">        Class c6=Integer.class;//基本数据类型</span><br><span class="line">        Class c7= ElementType.class;//枚举类型</span><br><span class="line">        Class c8=void.class;//空</span><br><span class="line">        Class c9=Class.class;//class</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.Object</span><br><span class="line">interface java.lang.Comparable</span><br><span class="line">class [Ljava.lang.String;</span><br><span class="line">class [[I</span><br><span class="line">interface java.lang.Override</span><br><span class="line">class java.lang.Integer</span><br><span class="line">class java.lang.annotation.ElementType</span><br><span class="line">void</span><br><span class="line">class java.lang.Class</span><br></pre></td></tr></table></figure>
<p><strong>方式三（常用）：</strong> 通过Class类的静态方法：forName（String  className）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c4 = Class.forName(&quot;com.xiaolei.Person&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="3、通过反射获取构造方法并使用"><a href="#3、通过反射获取构造方法并使用" class="headerlink" title="3、通过反射获取构造方法并使用"></a>3、通过反射获取构造方法并使用</h2><p>写个person类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    //定义三个成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    int age;</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Person(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age, String address) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个无参的方法</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;show!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带参的方法</span><br><span class="line">    public void method(String s) &#123;</span><br><span class="line">        System.out.println(&quot;method:&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带两个参数的方法</span><br><span class="line">    public String getString(String s,int i)&#123;</span><br><span class="line">        return s+&quot;---&quot;+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个私有的方法</span><br><span class="line">    private void function()&#123;</span><br><span class="line">        System.out.println(&quot;function !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写toStirng（）</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person[name=&quot;+name+&quot;,age=&quot;+age+&quot;,address=&quot;+address+&quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package fqy1;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1).批量的方法：</span><br><span class="line">   public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">   public Constructor[] getDeclaredConstructors()：</span><br><span class="line">   获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line"></span><br><span class="line">2).获取单个的方法，并调用：</span><br><span class="line">public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">获取指定单个的&quot;公有的&quot;构造方法：</span><br><span class="line">public Constructor getDeclaredConstructor(Class... parameterTypes):</span><br><span class="line">获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line">调用构造方法：</span><br><span class="line">      Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line">创建对象：</span><br><span class="line">      newInstance()</span><br><span class="line">      con.newInstance(“zhangsan&quot;, 20);</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //获取字节码文件对象</span><br><span class="line">        Class c1=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //第一：public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">        System.out.println(&quot;一、获取所有公有构造方法:&quot;);</span><br><span class="line">        Constructor[] cons = c1.getConstructors();</span><br><span class="line">        for(Constructor con:cons)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第二：public Constructor[] getDeclaredConstructors()：</span><br><span class="line">        //   获取所有的构造方法</span><br><span class="line">        System.out.println(&quot;二、获取所有的构造方法:&quot;);</span><br><span class="line">        Constructor[] cons2 =c1.getDeclaredConstructors();</span><br><span class="line">        for(Constructor con:cons2)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第三：public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">        //获取指定的单个“共有的”构造方法</span><br><span class="line">        //步骤：</span><br><span class="line">        //  A：首先创造字节码文件对象</span><br><span class="line">        //  B：通过字节码文件对象去创建构造器对象</span><br><span class="line">        //  C：通过构造器对象去创建一个实例对象</span><br><span class="line">        System.out.println(&quot;三、无参：获取指定的单个“共有的”构造方法:&quot;);</span><br><span class="line">        Constructor con3= c1.getConstructor(null);//返回的是构造方法对象</span><br><span class="line">        Object obj=con3.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        第四：需求：通过反射去获取该构造方法并使用</span><br><span class="line">        public person (String name,int age,String address)</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;四、通过反射去获取该构造方法并使用:&quot;);</span><br><span class="line">        Constructor con4=c1.getConstructor(String.class,int.class,String.class);</span><br><span class="line"></span><br><span class="line">        //通过带参构造方法对象创建对象</span><br><span class="line">        Object obj2=con4.newInstance(&quot;徐雷&quot;,18,&quot;武汉&quot;);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        需求：通过反射获取私有构造方法并使用</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;五、需求：通过反射获取私有构造方法并使用:&quot;);</span><br><span class="line">        Constructor con5=c1.getDeclaredConstructor(String.class);</span><br><span class="line">        //暴力访问</span><br><span class="line">        con5.setAccessible(true);</span><br><span class="line">         obj2=con5.newInstance(&quot;猫猫&quot;);//IllegalArgumentException:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、获取所有公有构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">二、获取所有的构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">fqy1.Person(java.lang.String,int)</span><br><span class="line">private fqy1.Person(java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">三、无参：获取指定的单个“共有的”构造方法:</span><br><span class="line">Person[name=null,age=0,address=null]</span><br><span class="line">四、通过反射去获取该构造方法并使用:</span><br><span class="line">Person[name=徐雷,age=18,address=武汉]</span><br><span class="line">五、需求：通过反射获取私有构造方法并使用:</span><br><span class="line">Person[name=猫猫,age=0,address=null]</span><br></pre></td></tr></table></figure>
<h2 id="4、通过反射获取成员变量并使用"><a href="#4、通过反射获取成员变量并使用" class="headerlink" title="4、通过反射获取成员变量并使用"></a>4、通过反射获取成员变量并使用</h2><p>1.获取所有成员：<br>     1).Field[] getFields():获取所有的”公有字段”<br>     2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</p>
<p>2.获取单个成员的：<br>     1).public Field getField(String fieldName):获取某个”公有的”字段；<br>     2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</p>
<p>3.修改成员的值：<br>         Field –&gt; public void set(Object obj,Object value):</p>
<p> 参数说明：<br>             1.obj:要设置的字段所在的对象；这个对象通过Constructor创建<br>             2.value:要为字段设置的值；</p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReflectDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c2=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //Field[] getFields():获取所有的&quot;公有字段&quot;</span><br><span class="line">        System.out.println(&quot;第一：获取所有公有成员变量：&quot;);</span><br><span class="line">        Field[] field=c2.getFields();</span><br><span class="line">        for(Field f:field)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有</span><br><span class="line">        System.out.println(&quot;第二：获取所有字段&quot;);</span><br><span class="line">        Field [] field2=c2.getDeclaredFields();</span><br><span class="line">        for(Field f:field2)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span><br><span class="line">        //Field --&gt; public void set(Object obj,Object value):</span><br><span class="line">        System.out.println(&quot;第三：获取某个公共字段并赋值：&quot;);</span><br><span class="line">        //通过无参构造方法创建对象</span><br><span class="line">        Constructor con =c2.getConstructor();</span><br><span class="line">        Object obj =con.newInstance();</span><br><span class="line">        Field field3=c2.getField(&quot;address&quot;);</span><br><span class="line">        field3.set(obj,&quot;武汉&quot;);//给object对象的f字段设置为”武汉“</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //获取name并对其赋值</span><br><span class="line">        System.out.println(&quot;第四：获取私有变量并赋值&quot;);</span><br><span class="line">        Field field4=c2.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        field4.setAccessible(true);</span><br><span class="line">        field4.set(obj,&quot;徐雷&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一：获取所有公有成员变量：</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第二：获取所有字段</span><br><span class="line">private java.lang.String fqy1.Person.name</span><br><span class="line">int fqy1.Person.age</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第三：获取某个公共字段并赋值：</span><br><span class="line">Person[name=null,age=0,address=武汉]</span><br><span class="line">第四：获取私有变量并赋值</span><br><span class="line">Person[name=徐雷,age=0,address=武汉]</span><br></pre></td></tr></table></figure>
<h2 id="5、通过反射获取成员方法并使用"><a href="#5、通过反射获取成员方法并使用" class="headerlink" title="5、通过反射获取成员方法并使用"></a>5、通过反射获取成员方法并使用</h2><h3 id="1-批量的："><a href="#1-批量的：" class="headerlink" title="1.批量的："></a>1.批量的：</h3><pre><code>public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）
public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</code></pre><h3 id="2-获取单个的："><a href="#2-获取单个的：" class="headerlink" title="2.获取单个的："></a>2.获取单个的：</h3><pre><code>public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):
            参数：
                 name : 方法名；
                Class ... : 形参的Class类型对象
public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code></pre><p> 【注】：第一个参数表示的是方法名，第二个参数表示的是方法的参数的class类型，这个方法返回值是Object接收，第一个参数表示对象是谁，第二参数表示调用该方法的实际参数。</p>
<h3 id="3-调用方法："><a href="#3-调用方法：" class="headerlink" title="3.调用方法："></a>3.调用方法：</h3><pre><code>Method --&gt; public Object invoke(Object obj,Object... args):
    参数说明：
    obj : 要调用方法的对象；
    args:调用方式时所传递的实参；</code></pre><p>测试成员方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">测试成员方法：</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //public Method[] getMethods():获取所有&quot;公有方法&quot;；</span><br><span class="line">        System.out.println(&quot;------第一：获取所有公有方法-------&quot;);</span><br><span class="line">        Method []m=c.getMethods();</span><br><span class="line">        for(Method method:m)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        //public Method[] getDeclaredMethods():</span><br><span class="line">        System.out.println(&quot;---------第二：获取所有方法--------&quot;);</span><br><span class="line">        Method[] m2=c.getDeclaredMethods();</span><br><span class="line">        for(Method method:m2)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor con=c.getConstructor();</span><br><span class="line">        Object obj=con.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------第三获取单个无参方法并使用----------&quot;);</span><br><span class="line">        //调用show方法</span><br><span class="line">        Method m1=c.getMethod(&quot;show&quot;);</span><br><span class="line">        //obj.m1();错误</span><br><span class="line">        //</span><br><span class="line">        m1.invoke(obj);//调用obj对象的m1方法</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第四，获取单个有参参数并使用-----------&quot;);</span><br><span class="line">        Method m3=c.getMethod(&quot;method&quot;, String.class);</span><br><span class="line">        m3.invoke(obj,&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第五，获取带多个参数的方法并使用-----&quot;);</span><br><span class="line">        Method m4=c.getMethod(&quot;getString&quot;, String.class, int.class);</span><br><span class="line">        Object objectString=m4.invoke(obj,&quot;徐雷&quot;,18);//返回object类型，记住！</span><br><span class="line">        System.out.println(objectString);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第六。获取私有的方法并使用----&quot;);</span><br><span class="line">        Method m5=c.getDeclaredMethod(&quot;function&quot;);</span><br><span class="line">        m5.setAccessible(true);</span><br><span class="line">        m5.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------第一：获取所有公有方法-------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">---------第二：获取所有方法--------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">private void fqy1.Person.function()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">--------第三获取单个无参方法并使用----------</span><br><span class="line">show!</span><br><span class="line">-----第四，获取单个有参参数并使用-----------</span><br><span class="line">method:hello</span><br><span class="line">-----第五，获取带多个参数的方法并使用-----</span><br><span class="line">徐雷---18</span><br><span class="line">-----第六。获取私</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作】：入职前的一些规划</title>
    <url>/2019/11/18/%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91%EF%BC%9A%E5%85%A5%E8%81%8C%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%92%E5%92%8C%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[##  一、前言

<p>&emsp;&emsp;未来不可知，上海的职业生涯将正式开始，花自缤纷花自谢，时间太紧了，拼不了爹的自己只能拼命去学习。万一实现了呢？ </p>
<h2 id="二、未来计划（2019-11-2021-9）"><a href="#二、未来计划（2019-11-2021-9）" class="headerlink" title="二、未来计划（2019.11-2021.9）"></a>二、未来计划（2019.11-2021.9）</h2><p>&emsp;&emsp;我希望在这近两年的时间内，竭尽全力的提升自己，努力往（三初一高）的方向发展：    </p>
<ul>
<li><strong>高级的Java开发</strong>；</li>
<li><strong>初级的大数据学习者</strong>；</li>
<li><strong>初级的人工智能学习者</strong>；</li>
<li><strong>初级的vr学习者</strong>；</li>
</ul>
<h2 id="三、着手当下"><a href="#三、着手当下" class="headerlink" title="三、着手当下"></a>三、着手当下</h2><ol>
<li>融入公司，跟上工作节奏。</li>
<li>学习不再片面，有条理的规划出一块内容深入学习</li>
<li>每周抽出20个小时的时间学习新知识。</li>
<li>不打游戏。</li>
<li>开始阅读书籍，书单已经选好。</li>
<li>开始慢慢的理财，关注房价和理财的事儿。</li>
<li>待更。。。</li>
</ol>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【潇雷】：风雨求职路</title>
    <url>/2019/11/14/%E3%80%90%E6%B1%82%E8%81%8C%E3%80%91%E9%82%A3%E4%BA%9B%E5%BF%83%E9%85%B8%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>一转眼，来上海就两个半月了，由夏至秋，天气转凉。  如今找工作的事情终于尘埃入定。  应届生社招时的碰壁让我深受打击，不仅投过实习的岗位，也频频报低价格卑微地换取一份糊口的工作，最后，还是没有放弃，总有适合你的工作在等待你。熬一熬，就过去了。</p>
<h1 id="2-求职"><a href="#2-求职" class="headerlink" title="2.求职"></a>2.求职</h1><h2 id="2-1-简历"><a href="#2-1-简历" class="headerlink" title="2.1 简历"></a>2.1 简历</h2><p>面了一个月，boss沟通八百多家，拉钩5年以下全投过，换来的是寥寥无几的面试机会，从刚开始投简历到找到工作的前两天还改些简历中的小毛病，慢慢的，我发现越到后面，我这简历竟然也能入的了一些大中厂的眼，虽然写的一年工作经验，虽然念的是普通二本非科班，这些特征在浩浩荡荡的简历海洋中本就该沉入海底的，我回头想想，除了那些项目，专业技能外，还有两点：第一是我把本科的CPA专业排名第二写上去了，还有一些奖学金，数学竞赛奖，这些起码能说明我在大学还是学了点东西的。第二是我添加了自己的个人博客和微信公众号，虽然不知道他们会不会看，虽然csdn很low，文章也不多，但是看着还是很努力的。所以个人博客的重要性在面试的时候还是挺加分的。因此，在往后的学习工作中，我将以博客的形式来记录自己的学习和生活。</p>
<h2 id="2-2-面试"><a href="#2-2-面试" class="headerlink" title="2.2 面试"></a>2.2 面试</h2><p><strong>第一家:</strong> 去了个培训机构，叫一堆的人去面试，做了几道nc逻辑题，结果全给做错了，连培训机构都不想要我，hhhh，服了，现在培训机构也挑人了吗？<br><strong>第二家:</strong> 是一个医疗相关的，面试很紧张，终于来了次正经的技术面，下面是面试题  </p>
<p><strong>1.两个linux之间相互传文件怎么做？</strong><br>答：可以使用SCP命令。  </p>
<p><strong>2.mysql查询前十条数据怎么做？</strong><br>select * from emp LIMIT 0,10  </p>
<p><strong>3.js怎么定义数组？</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种  </span><br><span class="line">            var arr = new Array();  </span><br><span class="line">            arr[0] = 123  </span><br><span class="line">            arr[1] = &quot;abc&quot;;  </span><br><span class="line">            arr[5] = false;  </span><br><span class="line">            alert(arr[3]);//undefined  </span><br><span class="line">            alert(arr);//123,abc,,,,false  </span><br><span class="line">            alert(arr[10]);//undefined，不会出现越界异常  </span><br><span class="line">            </span><br><span class="line">            //for in 遍历，未定义的不遍历</span><br><span class="line">            for(var i in arr)&#123;</span><br><span class="line">                alert(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">            //第二种  </span><br><span class="line">            var arr2 = new Array(2);//规定了数组的长度为2  </span><br><span class="line">            arr2[0] = &quot;ddd&quot;;  </span><br><span class="line">            arr2[1] = &quot;www&quot;;  </span><br><span class="line">            alert(arr2);//ddd,www  </span><br><span class="line">            arr2[2] = &quot;fff&quot;;//可以再次添加元素，定义的数组大小对此没有影响  </span><br><span class="line">            alert(arr2);//ddd,www,fff  </span><br><span class="line">                 </span><br><span class="line">            //第三种  </span><br><span class="line">            var arr3 = new Array(true,123,false);  </span><br><span class="line">            alert(arr3);//true,123,false  </span><br><span class="line">              </span><br><span class="line">            //第四种,推荐使用  </span><br><span class="line">            var arr4 = [false,&quot;aaa&quot;,123];  </span><br><span class="line">            alert(arr4);//false,aaa,123</span><br></pre></td></tr></table></figure>
<p><strong>4.vue的条件判断的指令？</strong><br> v-if指令。  </p>
<p><strong>5.git是干嘛的？（版本控制系统）</strong>  </p>
<p><strong>6.java的空指针怎么发生的？口述两行代码，一定会发生空指针？</strong><br>当一个对象不存在时，又调用它的话就会产生空指针异常。<br>object o=null；<br>o.tostring();</p>
<p><strong>7.java的数组越界是怎样的？像ArrayList这种自动增长的，它有没有可能发生越界？为什么？</strong><br>因为arrayList是线程不安全的类，当出现多个线程同时添加元素的时候，此时arrayList就会可能会出现数组越界的问题。  </p>
<p><strong>8.java的自定义注解是怎么解析的？（反射，加载成.class字节码文件）</strong>  </p>
<p><strong>9.定义一个简单的java类，这个类要使它能够表达简单的树形结构，那么这个类的关键特征是什么？</strong><br>就是有两个成员变量，类型是自己，分别指向左子树和右子树（以二叉树为例）。  </p>
<p>中间还问了点单词数学，应该是比较缺人，然后虽然我面试的很差，很多答不上来，但是过了几天还是给我发offer，只不过面试的时候就说就面试来看，我只值6k，我也同意它的说法，但是还是想多面几家试试，就拒绝了，没想到后面才正式开始了苦逼之路。</p>
<p><strong>第三家:</strong> 是一个50人左右的公司，做笔试题的时候，发现难度简直升级，结果笔试题都写不下去，就灰溜溜的回去了，下面是部分笔试题：<br>1.1万个人抢100个红包，如何保证2个人不能抢到同一个红包？<br>2.Git如何放弃工作区的更改？<br>3.写一个方法，处理接收POST类型的JSON参数的请求（参数为name，age）<br>4.POST请求是否可以是url？a=b&amp;c=d的形式请求？如何不可以请说出理由<br>5.设计一个对外服务的接口实现类，在1，2，3这三台主机上（有不同的IP地址）实现负载均衡和顺序轮询机制<br>6.@Scheduled是否为多线程执行，如果是请说明理由，否则请给出解决方案；<br>7.通过Nginx实现：访问<a href="http://test.ab.com，代理请求到http://101.101.1.1.9/" target="_blank" rel="noopener">http://test.ab.com，代理请求到http://101.101.1.1.9/</a><br>8.以JAR包的方式部署temp.jar，请写出部署命令，以及查看Java进程，结束进程</p>
<p><strong>第四家：</strong> 自第三家受打击之后就停下来复习了一周，当时也感觉面试好多，才没投几家就去面试了，所以当时想不把一些机会白白浪费掉，尽管如此，现在想来这种做法特别不好，不能停这么久，而且自己学真的学不到那么多，还是少约点面试，保持两天内一个面试放慢节奏还是比较好的。这家面了一个实习，在上海的团队就他一个人，想想就优点怕，它也看出来我心里的担心，最后可能倒在了沟通问题，以及非全日制，和技术回答的比较死板，考虑问题没有挖很深，很多都是直接从面经上看来，比如hashtable为什么不能为null？  </p>
<p><strong>第五家:</strong> 这次去的是一个岗位上技能啥都不要求的公司，会c，python，java就可以，我以为可能又是骗子公司，没想到公司也没想象中那么小，然后填完信息领到面试官那里，让我上机，实现一个在一个64*64的棋盘上，找出他给的100个点里的最短路径，然后让我开始写，我慢慢的脑子陷入了，感觉到现在都没理解好提议，它给的100个点如何输入到电脑里，一个二维数组，怎么接收这些点，然后算法用迪杰斯特拉算法怎么实现？虽然考研的时候做过这种算法找最短路径的点，但是要真让我实现，还真狠有难度，最后不来了之，自此又陷入自闭。 </p>
<p><strong>第六家，第七家：</strong>  上海无果，开始换城市，突发的选了嘉兴，去嘉兴，嘉善分别面了两家，第一家，做金融还要出差，感觉也不是想招人的意思，随便问的一些aop，springboot热部署等问题，最后我还是因为技术没过关被刷了，然后赶去嘉善面试，这个初创公司感觉面试官的他的三年经验很有水分，随便聊聊项目就过了，基础也没问，后面给我开了8k，最后犹豫再三还是拒了，初创公司不敢去，更别提没个大牛的初创公司。  </p>
<p><strong>第八家：</strong>  开始转战上海，一个金融相关的，我面试的感觉还不错，也感觉有希望进，但是最后不知道什么原因被刷了，这家我还是挺想去的。至少工作还是挺成熟的。 </p>
<p><strong>第九家：</strong> 做智能健身相关的，面试官技术很强，阿里出来的年轻小伙，但是给我的感觉是有点轻蔑，可能这就是牛人吧，最后我都报到6k了，但是我感觉那岗位学的东西也不多，不是纯java开发的。</p>
<p><strong>第十家：</strong> 转眼又过了一周，这家去了轻轻家教，面的问题很灵活，数据结构的知识我真的忘了很多，但是面试官人很好，跟我聊了挺久的。不过自己还是太菜了，我只想说面试还是很看重运气和那岗位的缺人程度的，最后惨败吧。 </p>
<p><strong>第十一家：</strong> 又跑了很远的地方去面试，一个挂羊头卖狗头的，应该是猎头公司，收集了很多面试人的信息资料，随便聊聊就不面了。也没抱希望。  </p>
<p><strong>第十二家：</strong> 这家是挺正规的，离我住处最近的一家了，走路十分钟就到了，面试之前看到这家岗位已经关闭了，面试官是一个很年轻的，这种年轻没多少面试经验的面试官会故意问的比较深，来展示他的能力，根本不从实际情况来面，我就一年的实习经验，把我当几年的面，还问我有没有带过人？也问了一些假大空的问题，消息堆积，重复消费，服务挂了怎么看等等，然后一个小时的面试，直接说，今天的面试到此结束。我就灰溜溜的回去了，不想要我干嘛浪费两个人的时间。</p>
<p><strong>第十三家：</strong> 这次是最后一次面试了，公司环境不错，成立八年的互联网公司，也有自己的产品，面积也很大，然后经过两轮的技术面试和一轮的hr小姐姐沟通后，终于以自己的实力和运气终于拿到了offer，这虽然不是最好的公司，但是这是现阶段最适合我的公司，面试总结的问题就是提升自己的沟通能力，很多东西，你得学会用自己的话来很精准的描述它，这种能力也是需要锻炼出来的，我在回复它邮件的时候，写了未来我们一起加油。  </p>
<h2 id="3感慨"><a href="#3感慨" class="headerlink" title="3感慨"></a>3感慨</h2><p>这一个多月我经历了什么？我得到了什么？<br>我的生活才刚刚开始，未来可期。<br>记两首诗：</p>
<p><strong>《夜》</strong><br>晚风拂我意，<br>荧屏对相思。<br>奔波十里外，<br>另觅橄榄枝。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/850b262531a3b749e927b27f1b28805.jpg" alt="image"></p>
<p><strong>《光》</strong><br>九月憧憬，新奇欲试笔与刀。<br>十月无闻，无花树下羞与闹。<br>十一过半，滩里霓虹光与照。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/f8e7a632c8e60cd0d9deb53f2ffd247.jpg" alt="image"></p>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>潇雷哥哥的第一篇博客</title>
    <url>/2019/11/11/%E6%BD%87%E9%9B%B7%E5%93%A5%E5%93%A5%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[# 潇雷

<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul>
<li>列表1</li>
<li>列表2<br>  a 字列表<br>  b 字列表<br>top: 100 数值越大越靠前<br><a href="https://lixiaoyu.cc/" target="_blank" rel="noopener">啸宇的博客</a><br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/00c1963b1cff4855bf4b72a84f2e0249" alt="我的头像"><br><em>字体是倾斜的</em><br>#字体也能加粗#</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is a block</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
