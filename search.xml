<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【JUC并发编程】：（1）JUC入门</title>
    <url>/2020/02/29/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89JUC%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h3><ul>
<li>java.util.concurrent ：工具包、分类</li>
<li>业务：普通的线程代码：Thread<ul>
<li>Runnable:没有返回值，效率相比Callable相对较低</li>
</ul>
</li>
</ul>
<h3 id="2、线程和进程"><a href="#2、线程和进程" class="headerlink" title="2、线程和进程"></a>2、线程和进程</h3><ul>
<li>进程：一个程序，程序的集合<ul>
<li>一个进程可以包含多个线程，至少包含一个</li>
<li>java默认有几个线程？2个main和GC</li>
</ul>
</li>
<li>线程：开了一个进程<ul>
<li>java真的可以开启线程吗？开不了，因为java是运行在虚拟机上的，开启的是本地方法。</li>
</ul>
</li>
<li>并发：多线程同时操作同一个资源</li>
<li>并行：多个人一起行走，多个线程可以同时执行；线程池</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取cpu的核数</span><br><span class="line">        //cpu 密集型，IO密集型</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发编程的本质：<strong>充分利用cpu的资源</strong></p>
<ul>
<li>线程有几个状态？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEW,//新生</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">RUNNABLE,//运行</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">BLOCKED,//阻塞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WAITING,//等待，死死等待</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">TIMED_WAITING,//超时等待</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TERMINATED;//终止</span><br></pre></td></tr></table></figure>
<ul>
<li>wait和sleep的区别？<ul>
<li>1、来自不同的类<ul>
<li>wait=》object</li>
<li>sleep=》Thread</li>
</ul>
</li>
<li>2、关于锁的释放<ul>
<li>wait会释放锁</li>
<li>sleep不会释放</li>
</ul>
</li>
<li>3、使用范围是不同的<ul>
<li>wait：必须在同步代码块中</li>
<li>sleep可以在任何地方睡</li>
</ul>
</li>
<li>4、是否需要捕获异常<ul>
<li>wait不需要捕获异常</li>
<li>sleep必须要捕获异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、lock锁"><a href="#3、lock锁" class="headerlink" title="3、lock锁"></a>3、lock锁</h3><h5 id="3-1-传统的Synchronized："><a href="#3-1-传统的Synchronized：" class="headerlink" title="3.1 传统的Synchronized："></a>3.1 传统的Synchronized：</h5><ul>
<li>卖票案例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SaleTicketDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //并发：多个线程操作同个资源，把资源类丢入线程</span><br><span class="line">       Ticket ticket = new Ticket();</span><br><span class="line">       //@FunctionalInterface 函数式接口，jdk8，lambda表达式（参数）-&gt;&#123; 代码&#125;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程一&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程二&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程三&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//资源类 oop:属性+方法</span><br><span class="line">class Ticket&#123;</span><br><span class="line">    private int number=50;</span><br><span class="line"></span><br><span class="line">    public void sale()&#123;</span><br><span class="line">        if(number&gt;0)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+number--+&quot;票，还剩：&quot;+number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/code/juc/juc1.png" alt="image"></p>
<ul>
<li>可以看到不加锁是由问题的，我们可以加上锁，并发就是多个线程操作同个资源。</li>
</ul>
<h5 id="3-2-Lock锁"><a href="#3-2-Lock锁" class="headerlink" title="3.2 Lock锁"></a>3.2 Lock锁</h5><ul>
<li><p>思路：加锁，finally-&gt;解锁</p>
</li>
<li><p>lock锁的三个实现类：<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/code/juc/juc2.png" alt="image"></p>
</li>
<li><p>ReentrantLock的底层<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/code/juc/juc3.png" alt="image"></p>
</li>
<li><p>公平锁：十分公平：可以先来后到。</p>
</li>
<li><p><strong>非公平锁：十分不公平，可以插队（默认）。</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SaleTicketDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //并发：多个线程操作同个资源，把资源类丢入线程</span><br><span class="line">        Ticket2 ticket = new Ticket2();</span><br><span class="line">        //@FunctionalInterface 函数式接口，jdk8，lambda表达式（参数）-&gt;&#123; 代码&#125;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程一&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程二&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程三&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Lock</span><br><span class="line">class Ticket2&#123;</span><br><span class="line">    private int number=50;</span><br><span class="line">    Lock lock =new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public  void sale()&#123;</span><br><span class="line">        lock.lock();//加锁</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //业务代码</span><br><span class="line">            if(number&gt;0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+number--+&quot;票，还剩：&quot;+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();//解锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-Synchronized和Lock的区别"><a href="#3-3-Synchronized和Lock的区别" class="headerlink" title="3.3 Synchronized和Lock的区别"></a>3.3 Synchronized和Lock的区别</h5><ol>
<li>Synchronized内置的java关键字，Lock是一个java类</li>
<li>Synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁</li>
<li>Synchronized会自动释放锁，Lock必须要手动释放锁，如果不释放锁，死锁。</li>
<li>Synchronized 线程1（获得锁，阻塞）、线程2（死死的等）；Lock锁就不一定会等待下去</li>
<li>Synchronized 可重入锁，不可以中断，非公平；Lock，可重入锁，可以判断锁，非公平（可以自己设置）</li>
<li>Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码。</li>
</ol>
<h5 id="3-4思考：-锁是什么？如何判断锁的是谁？"><a href="#3-4思考：-锁是什么？如何判断锁的是谁？" class="headerlink" title="3.4思考： 锁是什么？如何判断锁的是谁？"></a>3.4思考： 锁是什么？如何判断锁的是谁？</h5><h3 id="4、生产者和消费者问题"><a href="#4、生产者和消费者问题" class="headerlink" title="4、生产者和消费者问题"></a>4、生产者和消费者问题</h3><h5 id="4-1-传统版"><a href="#4-1-传统版" class="headerlink" title="4.1 传统版"></a>4.1 传统版</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程之间的通信问题：生产者和消费者问题! 等待唤醒和通知唤醒</span><br><span class="line"> * 线程交替执行   A B操作同一个变量  num=0</span><br><span class="line"> * A    num+1</span><br><span class="line"> * B    num-1</span><br><span class="line"> */</span><br><span class="line">public class A &#123; //线程类，操作资源类</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data = new Data();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程A&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//等待，业务，通知</span><br><span class="line">class  Data&#123;//数字，资源类</span><br><span class="line">    private int number=0;</span><br><span class="line"></span><br><span class="line">    //+1</span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        if(number!=0)&#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+number);</span><br><span class="line">        //通知其他线程+1完了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    //-1</span><br><span class="line">    public  synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        if(number==0)&#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+number);</span><br><span class="line">        //通知线程，我-1完成了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题存在，要是有abcd 四个线程安全吗？存在<strong>虚假唤醒</strong>问题！！</p>
</li>
<li><p>虚假唤醒：线程可以唤醒，而不会被通知，中断或超时。等待应该出现在循环中</p>
</li>
<li><p>解决：把if判断改成while判断</p>
</li>
</ul>
<h5 id="4-2-JUC版"><a href="#4-2-JUC版" class="headerlink" title="4.2 JUC版"></a>4.2 JUC版</h5><p><img src="6792926C3386459EBB0C7B03CCDAFA91" alt="image"><br>condition.awati();//等待<br>conditon.signalAll();//唤醒全部</p>
<ul>
<li>代码实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程之间的通信问题：生产者和消费者问题! 等待唤醒和通知唤醒</span><br><span class="line"> * 线程交替执行   A B操作同一个变量  num=0</span><br><span class="line"> * A    num+1</span><br><span class="line"> * B    num-1</span><br><span class="line"> */</span><br><span class="line">public class B &#123; //线程类，操作资源类</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data2 data = new Data2();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程A&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;线程B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//等待，业务，通知</span><br><span class="line">class  Data2&#123;//数字，资源类</span><br><span class="line">    private int number=0;</span><br><span class="line"></span><br><span class="line">    Lock lock=new ReentrantLock();</span><br><span class="line">    Condition condition=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    //+1</span><br><span class="line">    public  void increment() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            while (number!=0)&#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+number);</span><br><span class="line">            //通知其他线程+1完了</span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //-1</span><br><span class="line">    public   void decrement() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number==0)&#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+number);</span><br><span class="line">            //通知线程，我-1完成了</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，优势和补充。</li>
<li>Condition的优势？：可以精准的通知和唤醒</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class C &#123; //线程类，操作资源类</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data3 data = new Data3();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125; &#125;,&quot;A&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123; for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            data.printB();</span><br><span class="line">        &#125; &#125;,&quot;B&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;  for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            data.printC();</span><br><span class="line">        &#125;&#125;,&quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//等待，业务，通知</span><br><span class="line">class  Data3&#123;//数字，资源类</span><br><span class="line">    private int number=1;</span><br><span class="line"></span><br><span class="line">    Lock lock=new ReentrantLock();</span><br><span class="line">    Condition condition1=lock.newCondition();</span><br><span class="line">    Condition condition2=lock.newCondition();</span><br><span class="line">    Condition condition3=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void printA()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number!=1)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+&quot;AA&quot;);</span><br><span class="line">            number=2;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printB()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number!=2)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+&quot;BBB&quot;);</span><br><span class="line">            number=3;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printC()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (number!=3)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;=&gt;&quot;+&quot;CC&quot;);</span><br><span class="line">            number=1;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【JUC并发编程】：（2）锁理解、集合类的并发使用、JUC三个辅助类、读写锁、阻塞队列</title>
    <url>/2020/03/01/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E9%94%81%E7%90%86%E8%A7%A3%E3%80%81%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8%E3%80%81JUC%E4%B8%89%E4%B8%AA%E8%BE%85%E5%8A%A9%E7%B1%BB%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="1、锁理解"><a href="#1、锁理解" class="headerlink" title="1、锁理解"></a>1、锁理解</h3><ul>
<li><p>问题：如何判断锁的是谁？永远的知道什么锁，锁到底锁的是谁！</p>
</li>
<li><p>深刻理解我们的锁</p>
</li>
<li><p>synchronized:锁的对象是方法的调用者，同个对象适用同一把锁会陷入等待</p>
</li>
<li><p>static修饰后，锁的是class类，而不是原来的方法锁了。</p>
</li>
</ul>
<h3 id="2、集合类不安全"><a href="#2、集合类不安全" class="headerlink" title="2、集合类不安全"></a>2、集合类不安全</h3><ul>
<li>2.1、List不安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//java.util.ConcurrentModificationException</span><br><span class="line">public class ListTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 并发下arrayList不安全的</span><br><span class="line">         * 解决方案：</span><br><span class="line">         * 1、arrayList-&gt;vector</span><br><span class="line">         * 2、借助工具类:</span><br><span class="line">         * List list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">         * 3、juc包下： List list = new CopyOnWriteArrayList() ;</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //CopyOnWrite:写入时复制 COW 计算机程序设计领域的一种优化策略</span><br><span class="line">        //多个程序调用的时候，List ，读取的时候，固定的写入（覆盖）</span><br><span class="line">        //在写入的时候避免覆盖，造成数据问题</span><br><span class="line">        //CopyOnWriteArrayList比vector好在哪？答：只要有Synchronized效率低</span><br><span class="line">        List list = new CopyOnWriteArrayList() ;</span><br><span class="line">        for (int i = 1; i &lt;=20; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">                &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.2、set不安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//java.util.ConcurrentModificationException</span><br><span class="line">    //解决方法1：Set set= Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">    //解决方法2：写入时复制，CopyOnWriteArraySet</span><br><span class="line">public class SetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //HashSet set = new HashSet();</span><br><span class="line">        //Set set= Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">        CopyOnWriteArraySet set = new CopyOnWriteArraySet();</span><br><span class="line">        for (int i = 1; i &lt; 50; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">                &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>hashset的底层：hashmap</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">     map = new HashMap&lt;&gt;();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       return map.put(e, PRESENT)==null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.3、map不安全<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//并发解决：</span><br><span class="line">// 1.ConcurrentHashMap,</span><br><span class="line">// 2、 HashMap mao = Collections.synchronizedMap()</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt;= 30; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,4));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3、Callable（简单）"><a href="#3、Callable（简单）" class="headerlink" title="3、Callable（简单）"></a>3、Callable（简单）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泛型的参数等于方法的返回值</li>
</ul>
<p>例子：<br>问：怎么起的callable 答：callable本身不与thread直接联系，但是可以借助runable中的一个实现类，可以完成联系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CallableTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    //问：怎么起的callable 答：callable本身不与thread直接联系，</span><br><span class="line">     // 但是可以借助runable中的一个实现类，可以完成联系</span><br><span class="line">    //new Thread(new FutureTask&lt;V&gt;(Callable)).start();</span><br><span class="line">        new Thread().start();</span><br><span class="line"></span><br><span class="line">        MyThread thread=new MyThread();</span><br><span class="line">        //适配类,本质就是一个runable</span><br><span class="line">        FutureTask futureTask = new FutureTask(thread);</span><br><span class="line">        new Thread(futureTask,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        String o = (String) futureTask.get();//获取callable的返回结果</span><br><span class="line">        //get方法可能产生阻塞，方法里面可能会有耗时的操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;12&quot;);</span><br><span class="line">        return &quot;13&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、JUC常用的辅助类"><a href="#4、JUC常用的辅助类" class="headerlink" title="4、JUC常用的辅助类"></a>4、JUC常用的辅助类</h3><h5 id="4-1-CountDownLatch：减法计数器"><a href="#4-1-CountDownLatch：减法计数器" class="headerlink" title="4.1 CountDownLatch：减法计数器"></a>4.1 CountDownLatch：减法计数器</h5><ul>
<li>public class CountDownLatch<br>extends Object</li>
<li>一种同步帮助，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。 </li>
<li>一个CountDownLatch与给定数初始化。的await方法块直到当前计数达到零的countDown()方法调用，之后，所有等待的线程，释放任何后续的调用await立即返回。这是一一个镜头的现象-计数不能被重置。如果你需要一个版本，重置计数，考虑使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: XiaoLei</span><br><span class="line"> * @Date Created in 20:39 2020/3/1</span><br><span class="line"> * 案例说明：6个线程，等他们都输出go out 之后，才能输出close door</span><br><span class="line"> */</span><br><span class="line">//计数器</span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //总数是6，倒计时完毕会进行一个操作</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(6);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;go out&quot;);</span><br><span class="line">                countDownLatch.countDown();//计数器-1</span><br><span class="line">                &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(); //等到计数器归零，然后再向下执行</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;close door&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：<ul>
<li>countDownLatch.countDown();//计数器-1</li>
<li>countDownLatch.await(); //等到计数器归零，然后再向下执行</li>
<li>每次有线程调用countDown（）数量-1，假设计数器变为0，countDownLatch.await（）就会被唤醒，继续执行</li>
</ul>
</li>
</ul>
<h5 id="4-2-CycliBarrier：加法计数器"><a href="#4-2-CycliBarrier：加法计数器" class="headerlink" title="4.2 CycliBarrier：加法计数器"></a>4.2 CycliBarrier：加法计数器</h5><ul>
<li><p>一个同步帮助，允许一组线程相互等待，以达到一个共同的障碍点。cyclicbarriers涉及一个固定大小的线程必须党偶尔互相等待程序是有用的。该障碍被称为循环，因为它可以在等待线程被释放后重新使用。 </p>
</li>
<li><p>一个CyclicBarrier支持一个可选的Runnable命令，每个障碍点一次，在聚会的最后一个线程到达后，但在任何线程释放。这种障碍作用是有用的更新共享状态之前，任何一方继续。</p>
</li>
<li><p>案例：集齐七颗龙珠召唤神龙</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;召唤成功！&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;=7; i++) &#123;</span><br><span class="line">            final int temp=i;//lambda不能操作到i</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;收集了&quot;+temp+&quot;个龙珠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();//等待</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：await等待它计数，如果达到这个数字，就会开启另一条线程去执行</li>
</ul>
<h5 id="4-3-Semaphore"><a href="#4-3-Semaphore" class="headerlink" title="4.3 Semaphore"></a>4.3 Semaphore</h5><ul>
<li><p>一个计数信号量，在概念上，信号量维持一组许可证，如果有必要，每个acquire（）都会阻塞，知道许可证可用，然后才能使用它。</p>
</li>
<li><p>案例：抢车位 6车抢三个车位置</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //线程数量：抽象为停车位! 限流的时候</span><br><span class="line">        Semaphore semaphore = new Semaphore(3);</span><br><span class="line">        for (int i = 1; i &lt;=6; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                //acquire()得到</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;得到了该车位&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;离开车位&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    //release()释放</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理：</p>
<ul>
<li>acquire（）获得，假设如果已经满了，等待，等待被释放位置</li>
<li>release：释放，会将当前的信号释放+1，然后唤醒等待的线程。</li>
<li>作用：多个共享资源互斥的使用！并发限流</li>
</ul>
<h3 id="5、读写锁"><a href="#5、读写锁" class="headerlink" title="5、读写锁"></a>5、读写锁</h3><p><img src="D5C880CD63A749F6A222EC1929971746" alt="image"></p>
<ul>
<li>ReadWriteLock<ul>
<li>独占锁(写锁)：一次只能被一个线程占有</li>
<li>共享锁（读锁）：多个线程可以同时占有。</li>
</ul>
</li>
<li>读与读：可以共存</li>
<li>读与写：不能共存</li>
<li>写与写：不能共存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        MyCache myCache = new MyCache();</span><br><span class="line">        MyCatchLock myCache = new MyCatchLock();</span><br><span class="line"></span><br><span class="line">        //写入</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int temp=i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(temp+&quot;&quot;,temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //读取</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int temp=i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyCatchLock&#123;</span><br><span class="line">    private volatile Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">    //加了个读写锁，更加细粒度的控制</span><br><span class="line">    private ReadWriteLock lock=new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    //存，写，写入的时候，只希望同时只有一个线程写</span><br><span class="line">    public void put(String key,Object value)&#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;写入ok&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //取，读</span><br><span class="line">    public void get(String key)&#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key);</span><br><span class="line">            Object o=map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;读取ok&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义缓存</span><br><span class="line"> */</span><br><span class="line">class MyCache&#123;</span><br><span class="line">    private volatile Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //存，写</span><br><span class="line">    public void put(String key,Object value)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key);</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;写入ok&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //取，读</span><br><span class="line">    public void get(String key)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key);</span><br><span class="line">        Object o=map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、阻塞队列"><a href="#6、阻塞队列" class="headerlink" title="6、阻塞队列"></a>6、阻塞队列</h3><ul>
<li><p>写入：如果队列满了，就必须阻塞等待</p>
</li>
<li><p>读取：如果队列是空的，必须阻塞等待生产<br><img src="3931D64693864EDA8EFF1CBE16F89BA9" alt="image"></p>
</li>
<li><p>BlockingQueue 不是新东西，和set ，list平级都属于Collection类下的接口<br><img src="C2BCAF017A0A42D1AFB3721AF355F800" alt="image"></p>
</li>
<li><p>学会使用队列：添加、移除</p>
</li>
<li><p>四组API</p>
<ul>
<li>1、抛出异常</li>
<li>2、不会抛出异常</li>
<li>3、阻塞，等待</li>
<li>4、超时等待</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>不会抛出异常，有返回值</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer()</td>
<td>put()</td>
<td>offer(,,)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>poll()</td>
<td>take()</td>
<td>poll(,,)</td>
</tr>
<tr>
<td>检查队首元素</td>
<td>element</td>
<td>peek</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>第一种：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 抛出异常</span><br><span class="line">     */</span><br><span class="line">    public static void test1()&#123;</span><br><span class="line">        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">        System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">        System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line">//        System.out.println(blockingQueue.add(&quot;d&quot;));</span><br><span class="line">//        java.lang.IllegalStateException</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===========&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">//        java.util.NoSuchElementException</span><br><span class="line">//        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二种</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void test2()&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">        System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">        System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">        System.out.println(blockingQueue.offer(&quot;d&quot;));//返回false，没有异常</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;==========&quot;);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());//null 没有异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三种方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static void test3() throws InterruptedException &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">        blockingQueue.put(&quot;a&quot;);</span><br><span class="line">        blockingQueue.put(&quot;b&quot;);</span><br><span class="line">        blockingQueue.put(&quot;c&quot;);</span><br><span class="line">//        blockingQueue.put(&quot;d&quot;);//找到没有位置了，一直等待</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">//        System.out.println(blockingQueue.take());//没有这个位置，一直等待</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第四种：超时等待<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test4() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3);</span><br><span class="line"></span><br><span class="line">    blockingQueue.offer(&quot;a&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;b&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;c&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;d&quot;, 2,TimeUnit.SECONDS);//等待两秒没位置退出</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;========&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="同步队列：SynchronousQueue"><a href="#同步队列：SynchronousQueue" class="headerlink" title="同步队列：SynchronousQueue"></a>同步队列：SynchronousQueue</h5></li>
<li>没有容量，进去一个元素，必须等待取出来之后，才能再往里面放入元素</li>
<li>SynchronousQueue，只存储一个元素</li>
<li>put存，take取</li>
</ul>]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【mybaits】：(1) Mybatis简介</title>
    <url>/2020/02/28/%E3%80%90Mybatis%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89Mybatis%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="1、Mybatis介绍"><a href="#1、Mybatis介绍" class="headerlink" title="1、Mybatis介绍"></a>1、Mybatis介绍</h3><ul>
<li><p>Object relationship mapping 对象关系映射</p>
</li>
<li><p>映射关系：将数据中和java对象联系起来。</p>
</li>
<li><p>对比jdbc：</p>
<ul>
<li>定制化sql：更能适应业务复杂度（灵活的修改sql）</li>
<li>进行动态sql ：（sql语句的部分可以根据不同的条件出现）</li>
<li>分离sql集中管理：可以把SQL语句放在配置文件中，进行集中管理。这个配置文件叫做Mapping映射文件，多个映射文件分别管理不同的模块</li>
<li>mybatis对参数和结果的封装处理更完善，使用更方便 直接封装成对应的类型</li>
<li>输出映射：把数据库查询出来的数据记录，封装成结果集：可以是基本类型、数组、集合或JavaBean······</li>
<li>输入映射：把参数的值交给SQL语句，去数据库中查询对应的记录。</li>
</ul>
</li>
<li><p>实际上就是把：sql语句暴露给开发者，自己去写，其他的封装起来。去修改非常方便（增删改查都是我们自己来写）</p>
</li>
<li><p>Mybatis是一款持久层框架，它支持定制化sql（灵活的修改）、存储过程（函数）、以及高级映射（javabean和数据库对象的映射–&gt;输入映射和输出映射）。Mybatis避免了几乎所有的jdbc代码和手动设置参数以及获取结果集。</p>
</li>
<li><p>Mybatis可以使用简单的XML或注解来配置和映射原生信息。</p>
</li>
<li><p>将接口和java的POJOs映射成数据库中的记录</p>
</li>
</ul>
<h3 id="2、第一个程序"><a href="#2、第一个程序" class="headerlink" title="2、第一个程序"></a>2、第一个程序</h3><ul>
<li>1、搭建数据库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE `mybatis`;</span><br><span class="line"></span><br><span class="line">USE `mybatis`;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(20) NOT NULL,</span><br><span class="line">  `name` varchar(30) DEFAULT NULL,</span><br><span class="line">  `pwd` varchar(30) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert  into `user`(`id`,`name`,`pwd`) values (1,&apos;狂神&apos;,&apos;123456&apos;),(2,&apos;张三&apos;,&apos;abcdef&apos;),(3,&apos;李四&apos;,&apos;987654&apos;);</span><br></pre></td></tr></table></figure>
<ul>
<li>2、导入Mybatis相关的jar包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、编写mybatis核心配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、编写mybatis工具类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class MybatisUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取SqlSession连接</span><br><span class="line">    public static SqlSession getSession()&#123;</span><br><span class="line">        return sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这是一个建造者的生产模式：</p>
<ul>
<li>1、首先通过Resource.getResourceAsStream（）获取输入流，参数为mybatis配置文件</li>
<li>2、然后new一个SqlSessionFactoryBuilder，创建一个 工厂的建造者</li>
<li>3、工厂建造者对象调用build（）方法获取一个Sqlsession工厂对象，参数是之前得到的输入流</li>
<li>4、工厂对象调用openSession()方法，获取一个sqlSesson对象。</li>
<li>5、sqlSesson对象可以调用各种sql语句，其中本例中查询一个记录就是selectOne（）</li>
</ul>
</li>
</ul>
<ul>
<li>5、创建实体类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    </span><br><span class="line">    private int id;  //id</span><br><span class="line">    private String name;   //姓名</span><br><span class="line">    private String pwd;   //密码</span><br><span class="line">    </span><br><span class="line">    //构造,有参,无参</span><br><span class="line">    //set/get</span><br><span class="line">    //toString()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6、编写Mapper接口类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.kuang.pojo.User;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    List&lt;User&gt; selectUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>7、编写Mapper.xml配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt;</span><br><span class="line">  &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>8、编写测试类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void selectUser() &#123;</span><br><span class="line">        SqlSession session = MybatisUtils.getSession();</span><br><span class="line">        //方法一:</span><br><span class="line">        //List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);</span><br><span class="line">        //方法二:</span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; users = mapper.selectUser();</span><br><span class="line"></span><br><span class="line">        for (User user: users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h3><ul>
<li><p>namespace：名称为对应Mapper接口或者Dao接口的完整包名。</p>
</li>
<li><p>select：</p>
<ul>
<li>接口中的方法名与映射文件中的sql语句id一一对应</li>
<li>parameterType：传入SQL语句的参数类型。【万能的Map，参数多的时候多使用】</li>
<li>resultType：Sql语句返回值类型【完整的类名】</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>insert：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">     insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>update：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">    update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>delete：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">    delete from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>所有的增删改操作都需要提交事务</li>
<li>接口的所有普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上</li>
<li>有时候根据业务的需求，可以考虑map传递参数</li>
<li>为了规范操作，在sql配置文件中，我们尽量将Parameter参数和resultType都写上</li>
</ol>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>【mybaits】：(2) 配置解析</title>
    <url>/2020/02/28/%E3%80%90Mybatis%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="1、核心配置文件"><a href="#1、核心配置文件" class="headerlink" title="1、核心配置文件"></a>1、核心配置文件</h3><ul>
<li>能配置的内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">    properties（属性）</span><br><span class="line">    settings（设置）</span><br><span class="line">    typeAliases（类型别名）</span><br><span class="line">    typeHandlers（类型处理器）</span><br><span class="line">    objectFactory（对象工厂）</span><br><span class="line">    plugins（插件）</span><br><span class="line">    environments（环境配置）</span><br><span class="line">        environment（环境变量）</span><br><span class="line">            transactionManager（事务管理器）</span><br><span class="line">            dataSource（数据源）</span><br><span class="line">    databaseIdProvider（数据库厂商标识）</span><br><span class="line">    mappers（映射器）</span><br><span class="line">&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2、environments元素"><a href="#2、environments元素" class="headerlink" title="2、environments元素"></a>2、environments元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">  &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">    &lt;transactionManager type=&quot;JDBC&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;</span><br><span class="line">    &lt;/transactionManager&gt;</span><br><span class="line">    &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">    &lt;/dataSource&gt;</span><br><span class="line">  &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置MyBatis的多套运行环境，将Sql映射到多个不同的数据库上，必须指定其中一个位默认运行环境（通过default指定）</li>
<li>子元素节点：environment<ul>
<li>具体的一套环境，通过设置id进行区别，id保证唯一。</li>
</ul>
</li>
<li>子元素节点：transactionManager【事务管理器】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 语法 --&gt;</span><br><span class="line">&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>子元素节点：数据源（datasource）<ul>
<li>dataSource元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源。</li>
</ul>
</li>
</ul>
<h3 id="3、mapper元素"><a href="#3、mapper元素" class="headerlink" title="3、mapper元素"></a>3、mapper元素</h3><ul>
<li><p>映射器：定义映射SQL语句文件</p>
</li>
<li><p>告诉mybatis去哪找这些语句,该标签可以指定xxxMapper.xml的文件路径，也就是集中管理sql语句的文件。</p>
</li>
<li><p>引入资源方式：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">使用映射器接口实现类的完全限定类名</span><br><span class="line">需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">将包内的映射器接口实现全部注册为映射器</span><br><span class="line">但是需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>namespace+id可以限定唯一的标签</li>
<li>namespace要写成映射包中对应接口的全类名。</li>
<li>id就是方法名，同一个映射文件中的id不能重复</li>
<li>resultType是返回值要封装的类型，javaBean和普通类型都可以选择写全类名、或者简写。</li>
<li>接口中的方法名要和我们的namespace下的id对应起来。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--namespace要写成接口的全类名--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;cskaoyan.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;queryUserByName&quot; resultType=&quot;cskaoyan.User&quot;&gt;</span><br><span class="line">        select id,username,password,age,email from user where username = #&#123;as&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>



<h3 id="4、Properties（属性配置项）优化"><a href="#4、Properties（属性配置项）优化" class="headerlink" title="4、Properties（属性配置项）优化"></a>4、Properties（属性配置项）优化</h3><ul>
<li>在外面单独通过<properties>为数据源配置信息，可以降低datasource的配置项的耦合度，方便修改。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=123456</span><br><span class="line">url=jdbc:mysql://localhost:3306/mybatis</span><br><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">=================================================================</span><br><span class="line">&lt;properties resource=&quot;db.properties&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;jdbcurl&quot; value=&quot;jdbc:mysql://localhost:3306/mydb2?serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">================================================================</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">        &lt;!--这里暂时指定通过JDBC实现事务，这就需要我们手动提交、关闭 --&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5、typeAliases优化"><a href="#5、typeAliases优化" class="headerlink" title="5、typeAliases优化"></a>5、typeAliases优化</h3><ul>
<li>类型别名是为Java类型设置一个短的名字，不太好用。</li>
<li>方法一：直接指定全类名的别名。type写javabean的全类名；alias写别名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;typeAlias type=&quot;cskaoyan.User&quot; alias=&quot;xl&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br><span class="line">=====================================================================</span><br><span class="line">具体使用</span><br><span class="line">&lt;select id=&quot;queryUserById&quot; resultType=&quot;xl&quot;&gt;</span><br><span class="line">  select id,username,password,age,email from user where id = #&#123;abc&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：指定某个包，这个包内的全类名，默认简写就是类名的首字母小写【批量配置别名】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;package name=&quot;cskaoyan&quot;&gt;&lt;/package&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br><span class="line">====================================================================================</span><br><span class="line">具体使用</span><br><span class="line">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">  select id,username,password,age,email from user where id = #&#123;abc&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法三：基本类型的默认别名</p>
<ul>
<li>八大基本类型在类型前加上下划线_</li>
<li>包装基本类型就是首字母小写</li>
</ul>
</li>
<li><p>方法四：注解的方式设置类简称：@Alias</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Alias(&quot;xl&quot;)</span><br><span class="line">public class people&#123;</span><br><span class="line">    String id;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectPeople&quot; resultType=&quot;xl&quot;&gt;</span><br><span class="line">    select * from ddd;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6、setting设置"><a href="#6、setting设置" class="headerlink" title="6、setting设置"></a>6、setting设置</h3><ul>
<li>重点：<ul>
<li>懒加载</li>
<li>日志实现</li>
<li>缓存开启关闭</li>
</ul>
</li>
<li>完整的settings元素的实例如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;</span><br><span class="line">  &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7、生命周期和作用域"><a href="#7、生命周期和作用域" class="headerlink" title="7、生命周期和作用域"></a>7、生命周期和作用域</h3><ul>
<li><p>生命周期、作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
</li>
<li><p>SqlSessionFactoryBuilder：</p>
<ul>
<li>一旦创建了sqlSessionFactory，就不再需要它了</li>
<li>局部变量</li>
</ul>
</li>
<li><p>SqlSessionFactory：</p>
<ul>
<li>说白了就是可以想象为：数据库连接池。</li>
<li>一旦创建就应该在应用的运行期间一直存在，没有任何理由对其它或重新创建另一个实例。</li>
<li>因此sqlSessionFactory的最佳作用域是应用作用域，程序开始就开始，程序结束就结束。</li>
<li>最简单的就是使用单例模式或者静态单例模式</li>
</ul>
</li>
<li><p>sqlsession：</p>
<ul>
<li>sqlsession的实例不是线程安全的，因此不能被共享，所以它的最佳作用域是请求或方法作用域。</li>
<li></li>
</ul>
</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2347803678.png" alt="image"></p>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（1）概述、ioc理论</title>
    <url>/2020/02/25/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0%E3%80%81ioc%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><ul>
<li>Spring：春天-&gt;给软件行业带来了春天</li>
<li>2002年，首先推出Spring框架的雏形：interface21</li>
<li>2004年3月24号：在interface21框架上，发布了Spring框架的1.0版本</li>
<li>Rod Johnson：Spring Framework创始人,音乐学博士</li>
<li>Spring理念：本身就是大杂烩，整合现有的框架技术。</li>
</ul>
<p>官网：<a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">https://spring.io/projects/spring-framework</a></p>
<p>官方下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>Github：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></p>
<h2 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h2><ol>
<li>方便解耦，简化开发（高内聚，低耦合）</li>
<li>Spring是一个轻量级的、非侵入式的框架！非侵入式就是对原来的东西没有影响</li>
<li><strong>控制反转（ioc）、面向切面编程（AOP）</strong></li>
<li>支持事务的处理，对框架整合的支持</li>
</ol>
<p><strong>==总结一句话：Spring就是一个轻量级的控制反转（ioc）和面向切面编程的框架==</strong></p>
<h2 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h2><ul>
<li>spring框架是一个分层架构，由7个定义良好的模块组成，Spring模块构建在核心容器之上，核心容器定义了创建、配置和管理bean的方式。</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3294472123.png" alt="image"></p>
<ul>
<li>组成Sping框架的每个模块都可以单独存在，或者与其他一个或多个模块联合实现，每个模块的功能如下：<ul>
<li>核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
</li>
</ul>
<h2 id="1-4-ioc理论推导"><a href="#1-4-ioc理论推导" class="headerlink" title="1.4 ioc理论推导"></a>1.4 ioc理论推导</h2><h4 id="1-4-1-过去我们写代码："><a href="#1-4-1-过去我们写代码：" class="headerlink" title="1.4.1 过去我们写代码："></a>1.4.1 过去我们写代码：</h4><ul>
<li>1、先一个UserDao接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2、再去写Dao的实现类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;获取用户数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3、然后去写UserService的接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>4、最后写UserService的实现类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao = new UserDaoImpl();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、测试一下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    UserService service = new UserServiceImpl();</span><br><span class="line">    service.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这是我们原来的方式，如果在dao层在增加一个实现类，则需要更改service实现类的代码。如果大量增加实现类，大量更改service代码的话，这种方法也就不适用了。耦合性太高，牵一发而动全身！</p>
<h4 id="1-4-2-如何解决？"><a href="#1-4-2-如何解决？" class="headerlink" title="1.4.2 如何解决？"></a>1.4.2 如何解决？</h4><ul>
<li>我们可以在需要用到它的地方，不去实现它，而是留出一个接口，利用set，我们去代码里修改下。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    // 利用set实现</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改后，就不需要再动service里的代码，用户想调用什么就在外面直接调用。</p>
<ol>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用set注入后，程序不再具有主动性，而是变成可被动的接收到对象。</li>
</ol>
<ul>
<li>这种思想，从本质上解决了问题，外面程序员不再管理对象的创建，系统的耦合性大大降低，可以更加专注在业务的实现上，这就是ioc的原型。</li>
</ul>
<h2 id="1-5-ioc本质"><a href="#1-5-ioc本质" class="headerlink" title="1.5 ioc本质"></a>1.5 ioc本质</h2><ul>
<li>ioc：inverse of controller 控制反转，ioc是一种新的java编程模式。由Spring来负责控制对象的生命周期和对象间的关系，而不需要程序员来管理，Di是实现ioc的一种方法。</li>
<li>Spring容器在初始化时会读取配置文件，根据配置文件或元数据创建组织对象存入容器中，程序使用时从ioc容器中取出需要的对象</li>
</ul>
<p><strong>搞清楚几个问题：</strong></p>
<ul>
<li>谁依赖谁：应用程序依赖于ioc容器</li>
<li>为什么要依赖：应用程序需要ioc容器来提供对象需要的外部资源。</li>
<li>谁注入谁：IOC容器注入应用程序某个对象，应用程序依赖的对象。</li>
<li>注入了什么：注入了某个对象所需要的外部资源（包括对象、资源、常量数据）</li>
</ul>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（2）第一个程序、ioc创建对象方式、spring配置</title>
    <url>/2020/02/25/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E3%80%81ioc%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F%E3%80%81spring%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1、第一个Spring程序"><a href="#1、第一个Spring程序" class="headerlink" title="1、第一个Spring程序"></a>1、第一个Spring程序</h2><ul>
<li>spring的xml配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>先写一个简单的pojo类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    private String str;</span><br><span class="line"></span><br><span class="line">    public String getStr() &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStr(String str) &#123;</span><br><span class="line">        this.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hello&#123;&quot; +</span><br><span class="line">                &quot;str=&apos;&quot; + str + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再在xml中配置bean：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--使用spring来创建对象，在spring这些都称为bean--&gt;</span><br><span class="line">&lt;bean id=&quot;hello&quot; class=&quot;xiaolei.pojo.Hello&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在测试类中，不需要创建Hello对象就获得：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取Spring的上下文对象！</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        //我们的对象现在都在spring中的管理了，我们要使用，直接去里面取出来就可以了</span><br><span class="line">        Hello hello = (Hello) context.getBean(&quot;hello&quot;);</span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong></p>
<ul>
<li>hello对象是谁创建的？答：hello对象是由spring创建的。</li>
<li>hello对象的属性是怎么设置的？答：hello对象的属性是由spring容器设置的。</li>
</ul>
<h2 id="2、ioc创建对象常见方式"><a href="#2、ioc创建对象常见方式" class="headerlink" title="2、ioc创建对象常见方式"></a>2、ioc创建对象常见方式</h2><h4 id="2-1-无参构造"><a href="#2-1-无参构造" class="headerlink" title="2.1 无参构造"></a>2.1 无参构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">    public User() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--注册无参构造--&gt;</span><br><span class="line">&lt;bean id=&quot;user2&quot; class=&quot;Bean.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;hahaha&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<property>标签给构造出来的无参对象赋值</li>
<li>这个便签内的name的值必须是类中存在的setter方法。</li>
<li>至于后面的ref，指向其他类型的bean，如果该bean已经被注册，则ref值指向该bean的id，如果该bean没有被注册，则写该bean的全类限定名。</li>
<li>当然，value也可以写在bean标签的外部，单独写一个标签。</li>
</ul>
<h4 id="2-2-有参构造"><a href="#2-2-有参构造" class="headerlink" title="2.2 有参构造"></a>2.2 有参构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public User(String username,String password)&#123;</span><br><span class="line">    this.password=password;</span><br><span class="line">    this.username=username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;bean.User&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;password&quot; value=&quot;123&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<constructor-arg>标签构造方法的参数</li>
<li>当是有参构造时，name的参数就是构造方法的形参名</li>
<li>如果这个参数变量是javabean，写ref</li>
<li>如果是基本类型，写value</li>
</ul>
<h2 id="3-spring配置"><a href="#3-spring配置" class="headerlink" title="3.spring配置"></a>3.spring配置</h2><h5 id="3-1-别名"><a href="#3-1-别名" class="headerlink" title="3.1 别名"></a>3.1 别名</h5><ul>
<li>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot;&gt;</span><br><span class="line">   &lt;constructor-arg name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;alias name=&quot;user&quot; alias=&quot;user2&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-Bean的配置"><a href="#3-2-Bean的配置" class="headerlink" title="3.2 Bean的配置"></a>3.2 Bean的配置</h5><ul>
<li>id:bean的唯一标识符，也就是java对象名。如果没有配置id，name就是默认标识符；如果配置了id，又配置了name，那么name是别名，name可以设置多个别名，可以用逗号，分号，空格隔开。</li>
<li>如果不配置id和name，可以根据applicationContext.getBean(.class)获取对象;</li>
<li>class:bean对象所对应的全限定名</li>
</ul>
<h5 id="3-3-import"><a href="#3-3-import" class="headerlink" title="3.3 import"></a>3.3 import</h5><ul>
<li>一般用于团队开发使用，它可以将多个配置文件，导入合并为一个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（3）依赖注入</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%883%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="1、依赖注入"><a href="#1、依赖注入" class="headerlink" title="1、依赖注入"></a>1、依赖注入</h3><ul>
<li>依赖：指Bean对象的创建依赖于容器，Bean对象的依赖资源。</li>
<li>注入：指Bean对象所依赖的资源，由容器来设置和装配。</li>
<li>依赖注入分为：构造器注入、setter注入（重点）、拓展注入实现。</li>
</ul>
<h3 id="2、构造器注入"><a href="#2、构造器注入" class="headerlink" title="2、构造器注入"></a>2、构造器注入</h3><ul>
<li>有参构造和无参构造。</li>
</ul>
<h3 id="3、setter注入"><a href="#3、setter注入" class="headerlink" title="3、setter注入"></a>3、setter注入</h3><p>【环境搭建】：</p>
<ul>
<li>两个pojo类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    //1、基本类型</span><br><span class="line">    private String name;</span><br><span class="line">    //2、引用类型</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] books;</span><br><span class="line">    private List&lt;String&gt; hobbies;</span><br><span class="line">    private Map&lt;String,String&gt; card;</span><br><span class="line">    private Set&lt;String&gt; games;</span><br><span class="line">    private String wife;</span><br><span class="line">    private Properties info;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(Address address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getBooks() &#123;</span><br><span class="line">        return books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBooks(String[] books) &#123;</span><br><span class="line">        this.books = books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getHobbies() &#123;</span><br><span class="line">        return hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHobbies(List&lt;String&gt; hobbies) &#123;</span><br><span class="line">        this.hobbies = hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, String&gt; getCard() &#123;</span><br><span class="line">        return card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCard(Map&lt;String, String&gt; card) &#123;</span><br><span class="line">        this.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; getGames() &#123;</span><br><span class="line">        return games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGames(Set&lt;String&gt; games) &#123;</span><br><span class="line">        this.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getWife() &#123;</span><br><span class="line">        return wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWife(String wife) &#123;</span><br><span class="line">        this.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Properties getInfo() &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInfo(Properties info) &#123;</span><br><span class="line">        this.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, address=&quot; + address.toString() +</span><br><span class="line">                &quot;, books=&quot; + Arrays.toString(books) +</span><br><span class="line">                &quot;, hobbies=&quot; + hobbies +</span><br><span class="line">                &quot;, card=&quot; + card +</span><br><span class="line">                &quot;, games=&quot; + games +</span><br><span class="line">                &quot;, wife=&apos;&quot; + wife + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, info=&quot; + info +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address&#123;&quot; +</span><br><span class="line">                &quot;address=&apos;&quot; + address + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beans.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;address&quot; class=&quot;xiaolei.pojo.Address&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;address&quot; value=&quot;上海&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;xiaolei.pojo.Student&quot;&gt;</span><br><span class="line">        &lt;!--第一种：普通值注入，value--&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">        &lt;!--第二种：Bean注入，ref注入--&gt;</span><br><span class="line">        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;</span><br><span class="line">        &lt;!--第三种：数组注入--&gt;</span><br><span class="line">        &lt;property name=&quot;books&quot;&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;《Java编程思想》&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;《Java多线程并发》&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;《深入学习Mysql》&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第四种：List集合数组--&gt;</span><br><span class="line">        &lt;property name=&quot;hobbies&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;喝奶茶&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;吃火锅&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;写代码&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第五种：Map集合--&gt;</span><br><span class="line">        &lt;property name=&quot;card&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;身份证&quot; value=&quot;121212&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;银行卡&quot; value=&quot;212121&quot;/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第六种：Set集合--&gt;</span><br><span class="line">        &lt;property name=&quot;games&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;LOL&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;CF&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;DNF&lt;/value&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--第七种：空值注入--&gt;</span><br><span class="line">        &lt;property name=&quot;wife&quot;&gt;</span><br><span class="line">            &lt;null/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第八种：properties--&gt;</span><br><span class="line">        &lt;property name=&quot;info&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;driver&quot;&gt;20192020&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;url&quot;&gt;男&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;username&quot;&gt;20192020&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        Student student = (Student) context.getBean(&quot;student&quot;);</span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&apos;潇雷&apos;, address=Address&#123;address=&apos;上海&apos;&#125;, books=[《Java编程思想》, 《Java多线程并发》, 《深入学习Mysql》], hobbies=[喝奶茶, 吃火锅, 写代码], card=&#123;身份证=121212, 银行卡=212121&#125;, games=[LOL, CF, DNF], wife=&apos;null&apos;, info=&#123;url=男, driver=20192020, username=20192020&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、拓展方式注入"><a href="#4、拓展方式注入" class="headerlink" title="4、拓展方式注入"></a>4、拓展方式注入</h3><ul>
<li>1、P命名空间注入：需要在头文件加入约束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; p:name=&quot;潇雷&quot; p:age=&quot;18&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>2、C命名空间注入：需要在头文件加入约束文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; c:name=&quot;潇雷&quot; p:age=&quot;18&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5、Bean的作用域"><a href="#5、Bean的作用域" class="headerlink" title="5、Bean的作用域"></a>5、Bean的作用域</h3><ul>
<li>在Spring中，那些组成应用程序的主体及由Spring ioc容器所管理的对象，被称为bean。简单的说，bean就是由ioc容器初始化、装配及管理的对象。</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/852070927.png" alt="image"></p>
<ul>
<li><p>几种作用域中，request，session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架）只能用在基于web的spring ApplicationContext环境。</p>
</li>
<li><p>1、单例模式（Spring默认机制）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; scope=&quot;singleton&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>2、原型模式：每次从容器中get的时候，都会产生一个新对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：(4)spring Bean的生命周期</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%884%EF%BC%89Spring%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="1、Bean的完整生命周期"><a href="#1、Bean的完整生命周期" class="headerlink" title="1、Bean的完整生命周期"></a>1、Bean的完整生命周期</h3><ul>
<li>在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean 的实例化，然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。</li>
<li>相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强，下面展示了一个Bean的构造过程</li>
</ul>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java0-1558500658.jpg" alt="image"></p>
<p>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</p>
<p> 1、实例化一个Bean－－也就是我们常说的new；</p>
<p> 2、按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；</p>
<p> 3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值</p>
<p> 4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</p>
<p> 5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</p>
<p> 6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</p>
<p> 7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p>
<p> 8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；</p>
<p>  注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</p>
<p> 9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；</p>
<p> 10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p>
<h3 id="2、各种接口方法分类"><a href="#2、各种接口方法分类" class="headerlink" title="2、各种接口方法分类"></a>2、各种接口方法分类</h3><ul>
<li>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：<ul>
<li>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</li>
<li>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</li>
<li>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li>
<li>工厂后处理器接口方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li>
</ul>
</li>
</ul>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（5）Bean的自动装配</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%885%EF%BC%89Bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h3 id="1、Bean的自动装配"><a href="#1、Bean的自动装配" class="headerlink" title="1、Bean的自动装配"></a>1、Bean的自动装配</h3><ul>
<li>自动装配是Spring满足bean依赖的一种方式！</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在spring中有三种装配的方式：</p>
<ul>
<li>在xml中显示的配置</li>
<li>在java中显示配置</li>
<li>隐式的自动装配【重要】</li>
</ul>
<h3 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h3><p>环境搭建：一个人有两个宠物。</p>
<h3 id="3、自动装配"><a href="#3、自动装配" class="headerlink" title="3、自动装配"></a>3、自动装配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;cat&quot; class=&quot;xiaolei.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;xiaolei.pojo.Dog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">byname:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id,如果相同，则自动装配</span><br><span class="line">byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;people&quot; class=&quot;xiaolei.pojo.People&quot; autowire=&quot;byName&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>【小结】：</p>
<ul>
<li>byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致。</li>
<li>bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。</li>
</ul>
<h3 id="4、使用注解自动装配"><a href="#4、使用注解自动装配" class="headerlink" title="4、使用注解自动装配"></a>4、使用注解自动装配</h3><p>要使用注解须知：<br>1、导入约束：content约束<br>2、配置注解的支持：==<strong><a href="context:annotation-config" target="_blank" rel="noopener">context:annotation-config</a></strong>==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean definitions here --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.cskaoyan&quot;&gt;   &lt;/context:component-scan&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><ul>
<li>@Autowired 是按类型自动装配的，不支持id匹配。</li>
<li>需要导入Spring-aop的包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//如果允许对象为null，设置required = false,默认为true</span><br><span class="line">@Autowired(required = false)</span><br><span class="line">private Cat cat;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用</li>
</ul>
<p>测试：</p>
<ul>
<li>1.配置文件修改内容，保证类型存在对象，且名字不为类的默认名字！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.没有加Qualifier测试，直接报错。</li>
<li>3.在属性上添加Qualifier注解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;cat2&quot;)</span><br><span class="line">private Cat cat;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;dog2&quot;)</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、成功输出</li>
</ul>
<h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（6）AOP</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%886%EF%BC%89AOP/</url>
    <content><![CDATA[<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><ul>
<li>面向切面编程，是一种通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。是函数式编程的一种衍生范型，利用AOP可以对业务逻辑的各个部分进行隔离，实现各部分之间的解耦。<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1595583263.png" alt="image"></li>
</ul>
<h3 id="2、AOP在Spring中的作用"><a href="#2、AOP在Spring中的作用" class="headerlink" title="2、AOP在Spring中的作用"></a>2、AOP在Spring中的作用</h3><p><strong>==提供声明式事务：允许用户自定义切面==</strong></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。就是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…</li>
<li>切面（ASPECT）：横切关注点，被模块化的特殊对象，它是一个类</li>
<li>通知（Advice）：切面必须要完成的工作。它是类中的一个方法</li>
<li>目标（Target）：被通知对象</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象</li>
<li>切入点（PointCut）：切面通知 执行的地点的定义</li>
<li>连接点（jointPoint）：与切入点匹配的执行点</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/142667477.png" alt="image"></p>
<h3 id="3、使用Spring实现AOP"><a href="#3、使用Spring实现AOP" class="headerlink" title="3、使用Spring实现AOP"></a>3、使用Spring实现AOP</h3><h5 id="3-1-通过Spring-API实现"><a href="#3-1-通过Spring-API实现" class="headerlink" title="3.1 通过Spring API实现"></a>3.1 通过Spring API实现</h5><ul>
<li>首先编写我们的业务接口和实现类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add();</span><br><span class="line"></span><br><span class="line">    public void delete();</span><br><span class="line"></span><br><span class="line">    public void update();</span><br><span class="line"></span><br><span class="line">    public void search();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;增加用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        System.out.println(&quot;删除用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;更新用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void search() &#123;</span><br><span class="line">        System.out.println(&quot;查询用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后去写我们的增强类，一个前置增强，一个后置增强。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Log implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">    //method : 要执行的目标对象的方法</span><br><span class="line">    //objects : 被调用的方法的参数</span><br><span class="line">    //Object : 目标对象</span><br><span class="line">    @Override</span><br><span class="line">    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">        System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AfterLog implements AfterReturningAdvice &#123;</span><br><span class="line">    //returnValue 返回值</span><br><span class="line">    //method被调用的方法</span><br><span class="line">    //args 被调用的方法的对象的参数</span><br><span class="line">    //target 被调用的目标对象</span><br><span class="line">    @Override</span><br><span class="line">    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行了&quot; + target.getClass().getName()</span><br><span class="line">        +&quot;的&quot;+method.getName()+&quot;方法,&quot;</span><br><span class="line">        +&quot;返回值：&quot;+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后去spring的文件中注册，并实现aop切入实现，注意导入约束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册bean--&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--aop的配置--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--切入点  expression:表达式匹配要执行的方法--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">        &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.search();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</li>
</ul>
<h5 id="3-2-自定义类来实现AOP"><a href="#3-2-自定义类来实现AOP" class="headerlink" title="3.2 自定义类来实现AOP"></a>3.2 自定义类来实现AOP</h5><ul>
<li>第一步：写我们自己的一个切入类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DiyPointcut &#123;</span><br><span class="line"></span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>去spring配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="line">&lt;!--注册bean--&gt;</span><br><span class="line">&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--aop的配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;diy&quot;&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;</span><br><span class="line">        &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-使用注解实现"><a href="#3-3-使用注解实现" class="headerlink" title="3.3 使用注解实现"></a>3.3 使用注解实现</h5><ul>
<li>编写注解实现的增强类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class AnnotationPointcut &#123;</span><br><span class="line">    @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;环绕前&quot;);</span><br><span class="line">        System.out.println(&quot;签名:&quot;+jp.getSignature());</span><br><span class="line">        //执行目标方法proceed</span><br><span class="line">        Object proceed = jp.proceed();</span><br><span class="line">        System.out.println(&quot;环绕后&quot;);</span><br><span class="line">        System.out.println(proceed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：在spring配置文件中，注册bean，并增加支持注解的配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="line">&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>
<p>op:aspectj-autoproxy：说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 </span><br><span class="line"></span><br><span class="line">&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【java基础】：（4）iterator迭代器遍历集合</title>
    <url>/2020/05/12/%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%EF%BC%9A%EF%BC%884%EF%BC%89Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul>
<li>对collection进行迭代的迭代器，依赖于集合而存在。该接口隐藏了Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口。</li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator &lt;T&gt; iterator  =  集合名. iterator() ,获取的元素都是T类型，T只能是引用类型</span><br></pre></td></tr></table></figure>
<ul>
<li>四个方法：<ul>
<li>boolean hasNext()：如果没遍历完，返回true</li>
<li>Object next（）：返回下一个元素</li>
<li>void remove（）：从迭代器指向Collection中移除迭代器返回的最后一个元素。（上一次next方法返回的元素）</li>
</ul>
</li>
</ul>
<h3 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 需求：存储自定义对象并遍历Student(name,age)</span><br><span class="line"> *</span><br><span class="line"> * 分析：</span><br><span class="line"> * 		A:创建学生类</span><br><span class="line"> * 		B:创建集合对象</span><br><span class="line"> * 		C:创建学生对象</span><br><span class="line"> * 		D:把学生对象添加到集合对象中</span><br><span class="line"> * 		E:遍历集合</span><br><span class="line"> */</span><br><span class="line">public class CollectionTest2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 创建集合对象</span><br><span class="line">		Collection c = new ArrayList();</span><br><span class="line"></span><br><span class="line">		// 创建学生对象</span><br><span class="line">		Student s1 = new Student(&quot;貂蝉&quot;, 25);</span><br><span class="line">		Student s2 = new Student(&quot;小乔&quot;, 16);</span><br><span class="line">		Student s3 = new Student(&quot;黄月英&quot;, 20);</span><br><span class="line">		Student s4 = new Student();</span><br><span class="line">		s4.setName(&quot;大乔&quot;);</span><br><span class="line">		s4.setAge(26);</span><br><span class="line"></span><br><span class="line">		// 把学生对象添加到集合对象中</span><br><span class="line">		c.add(s1);</span><br><span class="line">		c.add(s2);</span><br><span class="line">		c.add(s3);</span><br><span class="line">		c.add(s4);</span><br><span class="line">		c.add(new Student(&quot;孙尚香&quot;, 18)); // 匿名对象</span><br><span class="line"></span><br><span class="line">		// 遍历集合</span><br><span class="line">		Iterator it = c.iterator();</span><br><span class="line">		while (it.hasNext()) &#123;</span><br><span class="line">			Student s = (Student) it.next();</span><br><span class="line">			System.out.println(s.getName() + &quot;---&quot; + s.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Iterator必须依赖于Collection对象，它仅用来遍历集合，本身并不提供盛装对象的能力。但是它只能通过remove方法删除上一次next方法返回的集合元素，否则会发生并发修改异常。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//报错</span><br><span class="line">Iterator iterator =c.iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">    String s=(String) iterator.next();</span><br><span class="line">    if(&quot;java&quot;.equals(s))&#123;</span><br><span class="line">        //c.remove(s);  //并发修改异常</span><br><span class="line">        //集合删除元素后，迭代器并不知道，禁止迭代器在迭代时用集合来进行修改</span><br><span class="line">        //怎么解决？1.迭代器遍历，迭代器修改  2.集合遍历，集合修改</span><br><span class="line">        iterator.remove(s)//迭代器遍历，用迭代器来调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因分析：Iterator迭代器采用的是快速失败（fail-fast）机制，一旦在迭代过程中监测到该集合已经被修改，程序立即引发并发修改异常，而不是显示修改后的结果，这样可以避免共享资源而引发的潜在问题。</li>
</ul>
<h3 id="4、几个小问题"><a href="#4、几个小问题" class="headerlink" title="4、几个小问题"></a>4、几个小问题</h3><h5 id="4-1-为什么Iterator设计成一个接口，而不是设计成一个类？"><a href="#4-1-为什么Iterator设计成一个接口，而不是设计成一个类？" class="headerlink" title="4.1 为什么Iterator设计成一个接口，而不是设计成一个类？"></a>4.1 为什么Iterator设计成一个接口，而不是设计成一个类？</h5><ul>
<li>有些集合允许有重复的元素，有些集合不允许有重复的元素。有些集合是有序的，有些集合是无序的，原因是具体集合的数据结构不一样。集合的遍历依赖于集合的数据结构，所以我们不能写一个类去遍历所有的集合。所以迭代器只能设计成接口或抽象类，他们吧判断和获取功能提取出来，放在接口里面去实现。</li>
</ul>
<h5 id="4-2-为什么不设计成抽象类"><a href="#4-2-为什么不设计成抽象类" class="headerlink" title="4.2 为什么不设计成抽象类"></a>4.2 为什么不设计成抽象类</h5><ul>
<li>因为有些集合可能会继承其他类，由于java的单继承，所以迭代器设计成了一个接口。iterator对象可以遍历对应的集合，说明他知道集合的数据结果，这个类的成员内部类。</li>
</ul>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>【java基础】：（3）Integer等包装类的缓存机制</title>
    <url>/2020/04/18/%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%EF%BC%9A%EF%BC%883%EF%BC%89Integer%E7%AD%89%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="1、装箱和拆箱"><a href="#1、装箱和拆箱" class="headerlink" title="1、装箱和拆箱"></a>1、装箱和拆箱</h3><ul>
<li>1.1 为什么要有包装类型<ul>
<li>让基本类型也具有对象的特征，因为容器都是装对象的。</li>
<li>自动装箱：int i=new Integer（6）；</li>
<li>底层调用Integer.valueOf(6)</li>
</ul>
</li>
<li>1.2 什么是自动装箱？<ul>
<li>自动装箱就是java编译器把基本类型转化为对应的包装类型的过程。例如把int转为Integer</li>
</ul>
</li>
</ul>
<h3 id="2、Integer类的缓存机制"><a href="#2、Integer类的缓存机制" class="headerlink" title="2、Integer类的缓存机制"></a>2、Integer类的缓存机制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> * @since  1.5</span><br><span class="line"> */</span><br><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">//当前值在缓存数组区间段，则直接返回该缓存值</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    //缓存创建新的Integer实例</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">//初始化时，缓存数值为-128 -127的Integer实例，默认是-128到127</span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该类的作用是将数值为-128 ~127区间内的Integer实例缓存到catch数组中，通过valueOf（）方法很明显发现，会复用缓存中的实例。</li>
</ul>
<h3 id="3、其他具有缓存机制的类"><a href="#3、其他具有缓存机制的类" class="headerlink" title="3、其他具有缓存机制的类"></a>3、其他具有缓存机制的类</h3><ul>
<li>实际上，不仅仅Integer具有缓存机制，Byte，Short，long,Character都具有缓存机制。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class LongCache &#123;</span><br><span class="line">    private LongCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static final Long cache[] = new Long[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        for(int i = 0; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = new Long(i - 128);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这些类都有缓存的范围，其中Byte，Short，Integer，Long为 -128 到 127，Character范围为 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。因为其他参数都是写死的，而Integer的下标是写死的，但是上标定义的h=127，是可以通过jvm设置参数改变的。Integer的缓存上界high可以通过jvm参数-XX:AutoBoxCacheMax=size指定，取指定值与127的最大值并且不超过Integer表示范围。</li>
</ul>
<h3 id="4、附录几道面试题"><a href="#4、附录几道面试题" class="headerlink" title="4、附录几道面试题"></a>4、附录几道面试题</h3><ul>
<li>面试题1：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//情景1</span><br><span class="line">   Integer c = 128;</span><br><span class="line">   Integer d = 128;</span><br><span class="line">   System.out.println(c == d);//false 因为是两个对象</span><br><span class="line"></span><br><span class="line">   //情景2</span><br><span class="line">   Integer a = 1;</span><br><span class="line">   Integer b = 1;</span><br><span class="line">   System.out.println(a == b);//true。b.intValue()</span><br><span class="line"></span><br><span class="line">   //情景3</span><br><span class="line">   Integer e = new Integer(1);</span><br><span class="line">   Integer f = new Integer(1);</span><br><span class="line">   System.out.println(e == f);//false</span><br></pre></td></tr></table></figure>

<ul>
<li>面试题2：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//情景4</span><br><span class="line">   int a = 1;</span><br><span class="line">   Integer b = Integer.valueOf(1);</span><br><span class="line">   Integer c = new Integer(1);</span><br><span class="line"></span><br><span class="line">   System.out.println(a == b);//true</span><br><span class="line">   System.out.println(a == c);//true</span><br><span class="line">   //a是基本类型，bc是引用类型，比较时，会自动拆成基本类型，比较值</span><br></pre></td></tr></table></figure>

<ul>
<li>面试题3：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代码来源于《深入理解Java虚拟机》第4章4.3.1 P121。</span><br><span class="line">public class SynAddRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    int a, b;</span><br><span class="line"></span><br><span class="line">    public SynAddRunnable(int a, int b) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (Integer.valueOf(a)) &#123;</span><br><span class="line">            synchronized (Integer.valueOf(b)) &#123;</span><br><span class="line">                System.out.println(a + b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            new Thread(new SynAddRunnable(1, 2)).start();</span><br><span class="line">            new Thread(new SynAddRunnable(2, 1)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面这段程序会发生死锁。造成死锁的原因：[-128，127]之间的数字会被缓存，而Integer.valueOf()会返回缓存的对象。因此代码中200次for循环实际上总共只创建了两个对象，当线程A持有Integer.valueOf(1)时，如果线程B持有Integer.valueOf(2)，则就会出现死锁，属于动态锁顺序死锁。</li>
</ul>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【redis】：（2）高阶</title>
    <url>/2020/04/18/%E3%80%90redis%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h4 id="1、Jedis"><a href="#1、Jedis" class="headerlink" title="1、Jedis"></a>1、Jedis</h4><ul>
<li>我们要用Java来操作Redis。什么是Jedis， 是redis官方推荐的java连接开发工具！使用java操作Redis中间件，如果你要使用java操作redis，那么一定要对jedis十分熟悉。</li>
</ul>
<blockquote>
<p>测试：</p>
</blockquote>
<ul>
<li>1、导入依赖<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.9.3&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.2.54&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>2、编码测试：<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestPing &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1、导入redis对象</span><br><span class="line">        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        //jedis 所有的命令就是我们之前学习的所有指令</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h4><ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>Hash</li>
<li>Zset</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestPing &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        JSONObject jsonObject = new JSONObject();</span><br><span class="line">        jsonObject.put(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">        jsonObject.put(&quot;name&quot;, &quot;xiaolei&quot;);</span><br><span class="line">        // 开启事务</span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line">        //jedis.watch(result)</span><br><span class="line">        try&#123;</span><br><span class="line">            multi.set(&quot;user1&quot;,result);</span><br><span class="line">            multi.set(&quot;user2&quot;,result);</span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            multi.discard();//代码出错抛出异常事务，执行失败</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(jedis.get(&quot;user1&quot;));</span><br><span class="line">            System.out.println(jedis.get(&quot;user2&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-springboot整合redis"><a href="#2-springboot整合redis" class="headerlink" title="2.springboot整合redis"></a>2.springboot整合redis</h3><ul>
<li>SpringBoot操作数据：spring-data jpa jdbc monggggodb</li>
<li>在springboot2.x之后，原来使用的jedis被替换为了   lettuce<ul>
<li>jedis：采用的直连，多个线程操作不安全</li>
<li>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况 ，像（nio）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) </span><br><span class="line">// 我们可以自己定义一个redisTemplate来替换这个默认的！ </span><br><span class="line">public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; </span><br><span class="line">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！ </span><br><span class="line">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 </span><br><span class="line"></span><br><span class="line">&lt;String, Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;@Bean @ConditionalOnMissingBean </span><br><span class="line">// 由于String 是redis中最常使用的类型，所以说单独提出来了一 个bean！ </span><br><span class="line">public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); </span><br><span class="line">return template;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>整合测试：</p>
</blockquote>
<ul>
<li>1、导入依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、配置连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line">spring.redis.port=6379</span><br></pre></td></tr></table></figure>
<ul>
<li>3、测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class Redis02SpringbootApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        //redisTemplate 操作不同的数据类型 api和我们的指令是一样的。</span><br><span class="line">        //opsForValue 操作字符串 类似String</span><br><span class="line">        //opsForList 操作List 类似List</span><br><span class="line">        //opsForSet</span><br><span class="line">        //opsForHash</span><br><span class="line">        //opsForZset</span><br><span class="line">        //opsForGeo</span><br><span class="line">        //opsForHyperLogLog</span><br><span class="line">        //获取redis的连接对象</span><br><span class="line">        //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        //connection.flushDb();</span><br><span class="line">        //connection.flushAll();</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;kuangshen&quot;);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：所有的对象都要可序列化，如果没有可序列化的话，输出会报错。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() throws JsonProcessingException &#123;</span><br><span class="line">    //真实开发一般都会使用json来传递对象</span><br><span class="line">    User user = new User(&quot;xiaolei1996&quot;, 3);</span><br><span class="line">    //转为字符串格式</span><br><span class="line">    String jsonUser = new ObjectMapper().writeValueAsString(user);</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;user&quot;,jsonUser);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    //编写我们自己的redisTemplate</span><br><span class="line">    @Bean</span><br><span class="line">    @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)</span><br><span class="line">            throws UnknownHostException&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        // Json序列化配置</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        // String 的序列化</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = new</span><br><span class="line">                StringRedisSerializer();</span><br><span class="line">        // key采用String的序列化方式</span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        // hash的key也采用String的序列化方式</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        // value序列化方式采用jackson</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        // hash的value序列化方式采用jackson</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、redis-conf理解"><a href="#3、redis-conf理解" class="headerlink" title="3、redis.conf理解"></a>3、redis.conf理解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网络</span><br><span class="line">通用 GENERAL</span><br><span class="line">bind 127.0.0.1 # 绑定的ip</span><br><span class="line">protected-mode yes # 保护模式</span><br><span class="line">port 6379 # 端口设置</span><br><span class="line">daemonize yes # 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！</span><br><span class="line">pidfile /var/run/redis_6379.pid # 如果以后台的方式运行，我们就需要指定一个 pid 文件！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日志</span><br><span class="line"># Specify the server verbosity level.</span><br><span class="line"># This can be one of:</span><br><span class="line">快照</span><br><span class="line">持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof</span><br><span class="line">redis 是内存数据库，如果没有持久化，那么数据断电及失！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">REPLICATION 复制，我们后面讲解主从复制的，时候再进行讲解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECURITY 安全</span><br><span class="line">可以在这里设置redis的密码，默认是没有密码！</span><br><span class="line"># debug (a lot of information, useful for development/testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably) 生产环境</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;&quot; # 日志的文件位置名</span><br><span class="line">databases 16 # 数据库的数量，默认是 16 个数据库</span><br><span class="line">always-show-logo yes # 是否总是显示LOGO</span><br><span class="line"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span><br><span class="line">save 900 1</span><br><span class="line"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span><br><span class="line">save 300 10</span><br><span class="line"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span><br><span class="line">save 60 10000</span><br><span class="line"># 我们之后学习持久化，会自己定义这个测试！</span><br><span class="line">stop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作！</span><br><span class="line">rdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！</span><br><span class="line">rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！</span><br><span class="line">dir ./ # rdb 文件保存的目录！</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass # 获取redis的密码</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录！</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;123456&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">限制 CLIENTS</span><br><span class="line">APPEND ONLY 模式 aof配置</span><br><span class="line">具体的配置，我们在 Redis持久化 中去给大家详细详解！</span><br><span class="line">Redis持久化</span><br><span class="line">面试和工作，持久化都是重点！</span><br><span class="line">Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中</span><br><span class="line">的数据库状态也会消失。所以 Redis 提供了持久化功能！</span><br><span class="line">RDB（Redis DataBase）</span><br><span class="line">什么是RDB</span><br><span class="line">在主从复制中，rdb就是备用了！从机上面！</span><br><span class="line">maxclients 10000 # 设置能连接上redis的最大客户端的数量</span><br><span class="line">maxmemory &lt;bytes&gt; # redis 配置最大的内存容量</span><br><span class="line">maxmemory-policy noeviction # 内存到达上限之后的处理策略</span><br><span class="line">1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）</span><br><span class="line">2、allkeys-lru ： 删除lru算法的key</span><br><span class="line">3、volatile-random：随机删除即将过期key</span><br><span class="line">4、allkeys-random：随机删除</span><br><span class="line">5、volatile-ttl ： 删除即将过期的</span><br><span class="line">6、noeviction ： 永不过期，返回错误</span><br><span class="line">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，</span><br><span class="line">rdb完全够用！</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字</span><br><span class="line"># appendfsync always # 每次修改都会 sync。消耗性能</span><br><span class="line">appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！</span><br><span class="line"># appendfsync no</span><br></pre></td></tr></table></figure>

<h2 id="4、Redis持久化"><a href="#4、Redis持久化" class="headerlink" title="4、Redis持久化"></a>4、Redis持久化</h2><ul>
<li>Redis是内存数据库，如果不将内存中的数据库状态保存在磁盘中，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以redis提供了持久化功能。</li>
</ul>
<h3 id="4-1-RDB"><a href="#4-1-RDB" class="headerlink" title="4.1 RDB"></a>4.1 RDB</h3><ul>
<li><p>在主从复制中，rdb就是备用了从机上面。<br><img src="67C1395F743D4BADA2FDE20A2E821459" alt="image"></p>
</li>
<li><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效，RDB的缺点就是最好一次持久化后的数据可能丢失。我们默认是RDB。</p>
</li>
<li><p><strong>rdb保存的文件是dump.rdb</strong> 都是自自在在我们的配置文件中快照进行配置的<br><img src="5FEB729496FF4212B1FE1F0257132D36" alt="image"><br><img src="E20C800A466045AE818F8FF95A00A51F" alt="image"></p>
</li>
<li><p>触发机制：备份就会自动生成dump.rdb</p>
</li>
</ul>
<ol>
<li>save的规则满足的情况下，会自动触发rdb规则</li>
<li>执行flushall命令，也会触发我们的rdb规则</li>
<li>退出redis，也会产生rdb文件 。<br><img src="24E248A05D034439BC3BBD1D6AFB6224" alt="image"><blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
</li>
<li>只需将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb文件的数据</li>
<li>查看需要存在的位置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir </span><br><span class="line">1) &quot;dir&quot; </span><br><span class="line">2) &quot;/usr/local/bin&quot; </span><br><span class="line"># 如果在这个目录下存在 dump.rdb文件，启动就会自动恢复其中的数据</span><br></pre></td></tr></table></figure>

<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><ul>
<li>优点：<ul>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要一定的时间间隔进程操作！如果redis意外怠机了，这个最后一次修改数据就会来不及保存</li>
<li>fork进程的时候，会占用一定的内容空间。</li>
</ul>
</li>
</ul>
<h3 id="4-2-AOF（Append-only-File）"><a href="#4-2-AOF（Append-only-File）" class="headerlink" title="4.2 AOF（Append only File）"></a>4.2 AOF（Append only File）</h3><ul>
<li>以日志的形式来记录每个写的操作，将redis执行过的所有指令记录下来（读操作不记录），只追加文件但是不可退改写文件，redis启动之初会读取文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将指令从前往后执行一次以完成数据的恢复工作。</li>
<li><strong>Aof 保存的是appendonly.aof文件</strong><br><img src="BD56619E296B4418895CF1C966F31AE5" alt="image"></li>
</ul>
<blockquote>
<p>append 默认是不开启的，把no改成yes即可<br><img src="A5465B12849F486C9E261780B7E60069" alt="image"></p>
</blockquote>
<ul>
<li>如果aof文件出现问题，是不能启动redis的，只能修复这个aof文件。redis给我们提供了一个工具 redis-check-aof<br><img src="13CBE42336B14322B19D786881F8A2B4" alt="image"></li>
</ul>
<h4 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h4><ul>
<li>优点：<ul>
<li>1、每次修改都同步，文件的完整会更加好</li>
<li>2、每秒同步一次，可能会丢失一秒的数据</li>
<li>3、从不同步，效率最高的</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、相对于数据文件来说，aof远远大于rdb，修复速度也比rdb慢</li>
<li>2、aof运行效率较慢</li>
</ul>
</li>
<li>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li>
<li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始<br>的数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li>
<li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</li>
<li>同时开启两种持久化方式在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有<br>AOF可能潜在的Bug，留着作为一个万一的手段。</li>
<li>性能建议因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够<br>了，只保留 save 900 1 这条规则。如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重<br>写可以改到适当的数值。如果不Enable AOF ，仅靠 Master-Slave Repllcation实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【redis】：（1）基础</title>
    <url>/2020/04/18/%E3%80%90redis%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ul>
<li>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库，高速缓存和消息队列代理</strong>。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</li>
</ul>
<h3 id="一、五大数据类型"><a href="#一、五大数据类型" class="headerlink" title="一、五大数据类型"></a>一、五大数据类型</h3><h4 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;xulei&quot;</span><br><span class="line">127.0.0.1:6379&gt; expire name 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name # 剩余时间</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; type age</span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<h4 id="1-1-String"><a href="#1-1-String" class="headerlink" title="1.1 String"></a>1.1 String</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#######  append，strlen</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set key1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 hello</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;v1hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen key1</span><br><span class="line">(integer) 7</span><br><span class="line"></span><br><span class="line">######## 加减操作，可以设置步长</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; incrby views 10</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; decrby views 2</span><br><span class="line">(integer) 9</span><br><span class="line"></span><br><span class="line">########## 字符串范围</span><br><span class="line">127.0.0.1:6379&gt; set key1 &quot;hello,xulei&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 4</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 -1 # 获取所有的字符串</span><br><span class="line">&quot;hello,xulei&quot;</span><br><span class="line"></span><br><span class="line">############ 替换</span><br><span class="line">127.0.0.1:6379&gt; set key2 abcd</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;abcd&quot;</span><br><span class="line">127.0.0.1:6379&gt; setrange key2 1 xx</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;axxd&quot;</span><br><span class="line"></span><br><span class="line">############## setex，setnx</span><br><span class="line">#setex（set with expire） 设置过期时间</span><br><span class="line">#setnx（set if not exist） 不存在设置</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setex key3 20 hualin</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line">&quot;hualin&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey redis # 如果mykey不存在，创建成功</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;mykey&quot;</span><br><span class="line">3) &quot;key2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey 1 # 如果mykey存在，创建失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line">&quot;redis&quot;</span><br><span class="line"></span><br><span class="line">####################### 批量获取和设置</span><br><span class="line"># mset </span><br><span class="line"># mget</span><br><span class="line"># msetnx 是一个原子性的操作，要么一起成功，要么一起失败</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################# 对象</span><br><span class="line"></span><br><span class="line">set user:1 &#123;name:zhangson,age:29&#125;</span><br><span class="line"># 设置一个user：1对象，值为json字符来保存一个对象</span><br><span class="line">127.0.0.1:6379&gt; mset user:2:name xulei user:2:age 26 </span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">########## </span><br><span class="line"># getset 先get然后set，更新的操作，并返回value</span><br><span class="line">127.0.0.1:6379&gt; getset db redis</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;mongodb&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>String类似的使用场景：value 除了是我们的字符串还可以是我们的数字<ul>
<li>计数器</li>
<li>统计多单位的数量 uid：2015101367 ：flow 0 incr</li>
</ul>
</li>
</ul>
<h4 id="1-4-List"><a href="#1-4-List" class="headerlink" title="1.4 List"></a>1.4 List</h4><ul>
<li>基本的数据类型、列表</li>
<li>在redis里面，我们可以把list玩成栈、队列、阻塞队列。看成队列比较好</li>
<li><strong>所有的list命令都是用l开头的</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">########### </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpush list one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list tow</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush list three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;tow&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 2</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;tow&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1 #通过区间获取 从尾部依次往前获取</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;tow&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 1 2 </span><br><span class="line">1) &quot;tow&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush list zero</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 # 插入到头部</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;tow&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;zero&quot;</span><br><span class="line"></span><br><span class="line">############# </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpop list # 移除尾部元素</span><br><span class="line">&quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list # 移除头部元素</span><br><span class="line">&quot;zero&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;tow&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###################</span><br><span class="line"></span><br><span class="line"># 通过下标获取某个值 lindex</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;tow&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; Lindex list 1</span><br><span class="line">&quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; Lindex list 0</span><br><span class="line">&quot;tow&quot;</span><br><span class="line">127.0.0.1:6379&gt; Lindex list 2</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">#######################</span><br><span class="line">Llen: 返回列表的长度</span><br><span class="line">127.0.0.1:6379&gt; llen list </span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">#####################</span><br><span class="line"># lrem 移除指定的值，移除是从头部开始移除的</span><br><span class="line">取关：uid</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 1</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -2</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;2&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line"></span><br><span class="line">###############################</span><br><span class="line"># ltrim 截取list的元素，只剩下剪短后的元素，</span><br><span class="line"># ltrim 1 0 # 是清空整个列表的意思，因为区间长度为负</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;hello5&quot;</span><br><span class="line">2) &quot;hello4&quot;</span><br><span class="line">3) &quot;hello3&quot;</span><br><span class="line">4) &quot;hello2&quot;</span><br><span class="line">5) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; ltrim list2 2 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;hello3&quot;</span><br><span class="line">2) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line">#################</span><br><span class="line">rpoplpush # 移除列表的最后一个元素</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist hello1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist hello2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist hello3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist hello4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist hello5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist othorlist</span><br><span class="line">&quot;hello5&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello1&quot;</span><br><span class="line">2) &quot;hello2&quot;</span><br><span class="line">3) &quot;hello3&quot;</span><br><span class="line">4) &quot;hello4&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange othorlist 0 -1</span><br><span class="line">1) &quot;hello5&quot;</span><br><span class="line"></span><br><span class="line">#################</span><br><span class="line"># lset 将列表中指定的下标的值替换为另外一个值 更新操作</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item # 判断这个列表是否存在，</span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">####################</span><br><span class="line"># linsert 在before和after插入 具体的值</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;intem3&quot;</span><br><span class="line">2) &quot;intem2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert list before &quot;item&quot; nimabi </span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;intem3&quot;</span><br><span class="line">2) &quot;intem2&quot;</span><br><span class="line">3) &quot;nimabi&quot;</span><br><span class="line">4) &quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert list after item hahahhahah</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;intem3&quot;</span><br><span class="line">2) &quot;intem2&quot;</span><br><span class="line">3) &quot;nimabi&quot;</span><br><span class="line">4) &quot;item&quot;</span><br><span class="line">5) &quot;hahahhahah&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>它实际上是一个链表，before Node after，left right都可以插入值</li>
<li>如果key不存在，创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表</li>
<li>在两边插入或者改动值，效率高，中间元素，相对来说效率会低点</li>
</ul>
<p>消息队列（Lpush Rpop） 栈（Lpush Lpop）</p>
<h4 id="1-3-set（集合）"><a href="#1-3-set（集合）" class="headerlink" title="1.3 set（集合）"></a>1.3 set（集合）</h4><ul>
<li>set的值是不能重复的，无序不重复。可以用来存储在某个活动中中奖的用户ID，因为有去重作用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##################################</span><br><span class="line"># sadd 添加元素</span><br><span class="line"># smembers ：所有的set集合</span><br><span class="line"># sismember ：判断是否有该元素</span><br><span class="line"># scard ：获取当前的元素</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset xiaolei</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset xulei love hualin</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;xulei&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;love&quot;</span><br><span class="line">4) &quot;xiaolei&quot;</span><br><span class="line">5) &quot;hualin&quot;</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(integer) 5</span><br><span class="line">########################################</span><br><span class="line"># srem : 移除set集合元素</span><br><span class="line"># SRANDMEMBER：随机抽选出一个元素</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srem myset hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset </span><br><span class="line">&quot;xulei&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset </span><br><span class="line">&quot;hualin&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset </span><br><span class="line">&quot;love&quot;</span><br><span class="line"></span><br><span class="line">########################################</span><br><span class="line"># spop ：随机删除key</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line">&quot;hualin&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;love&quot;</span><br><span class="line">2) &quot;xulei&quot;</span><br><span class="line">3) &quot;xiaolei&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line">&quot;love&quot;</span><br><span class="line"></span><br><span class="line">########################################</span><br><span class="line"># 将一个指定的值，移动到另外一个集合中</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset world</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset xulei</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 hualin</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 xiangni</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 xulei</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) &quot;xulei&quot;</span><br><span class="line">2) &quot;xiangni&quot;</span><br><span class="line">3) &quot;hualin&quot;</span><br><span class="line"></span><br><span class="line">########################################</span><br><span class="line">应用：微博，b站 把所有关注的人放在一个set集合中，将它的粉丝也放在一个集合中。</span><br><span class="line">数字集合类：</span><br><span class="line">    差集：SDIFF</span><br><span class="line">    交集：SINTER</span><br><span class="line">    并集：SUNION</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 c</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 c</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 d</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 e</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SDIFF key1 key2</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; SINTER key1 key2</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">5) &quot;e&quot;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-Hash（哈希）"><a href="#1-4-Hash（哈希）" class="headerlink" title="1.4 Hash（哈希）"></a>1.4 Hash（哈希）</h4><ul>
<li>Map集合 key-<key-value> 这时候这个值是一个map集合，本质和String类型没有太大的区别，还是一个简单的key-value</li>
<li>hash变更的数据 user name age 尤其是用户信息之类的，经常变更过的信息！hash 更适合存储对象，String更适合字符串存储</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#################################</span><br><span class="line"># hset：存值</span><br><span class="line"># hget: 取值</span><br><span class="line"># hmset: 存多个值</span><br><span class="line"># hmget： 取多个值</span><br><span class="line"># hgetall： 获取所有的key value</span><br><span class="line"># hdel: 删除指定的key</span><br><span class="line">127.0.0.1:6379&gt; hset myhash field1 xulei</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line">&quot;xulei&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset myhash field1 xulei</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line">&quot;xulei&quot;</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field2 2 field3 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2 field3</span><br><span class="line">1) &quot;xulei&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;xulei&quot;</span><br><span class="line">3) &quot;field2&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;field3&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field2</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">#################################</span><br><span class="line"># hlen:查看hash表的字段数量</span><br><span class="line"># hexists： 判断指定hash是否存在</span><br><span class="line"># hkeys: 查看当前所有的key</span><br><span class="line"># hvals：只获得所有的value</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;xulei&quot;</span><br><span class="line">3) &quot;field3&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;field3&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;xulei&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line"></span><br><span class="line">################################</span><br><span class="line"># hincryby ：指定增量</span><br><span class="line"># hsetnx : 如果存在则不能设置</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field4 4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field4 2</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field4 -4</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-zset（有序集合）"><a href="#1-5-zset（有序集合）" class="headerlink" title="1.5 zset（有序集合）"></a>1.5 zset（有序集合）</h4><ul>
<li>在set的基础上，增加了一个值，分组。set k1 v1 zset k1 score1 v1</li>
<li>它类似于SortedSet和HashMap的结合体，一方面它是一个set，保证内部value的唯一性，另一方面它可以给每个value赋予一个score，代表这个value的排序权重，它的内部实现用的是跳转列表的数据结构</li>
<li>zset可以用来存储粉丝列表，value值是粉丝的用户id，score是关注时间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##########################</span><br><span class="line"># ZRANGEBYSCORE 排序 min max</span><br><span class="line"># ZREVRANGE ：从大到小排序</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaohon</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 9000 zhansan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 200 xulei</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf</span><br><span class="line">1) &quot;xulei&quot;</span><br><span class="line">2) &quot;xiaohon&quot;</span><br><span class="line">3) &quot;zhansan&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores</span><br><span class="line">1) &quot;xulei&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;xiaohon&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;zhansan&quot;</span><br><span class="line">6) &quot;9000&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores</span><br><span class="line">1) &quot;xulei&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;xiaohon&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1</span><br><span class="line">1) &quot;zhansan&quot;</span><br><span class="line">2) &quot;xiaohon&quot;</span><br><span class="line"></span><br><span class="line">##########################</span><br><span class="line"># rem：移除rem中的元素：移除有序集合中的元素</span><br><span class="line"># zcard：查看里面的元素个树</span><br><span class="line"># zcount：计算区间内的个树</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;xulei&quot;</span><br><span class="line">2) &quot;xiaohon&quot;</span><br><span class="line">3) &quot;zhansan&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem salary xulei</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;xiaohon&quot;</span><br><span class="line">2) &quot;zhansan&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 world 3 xulei</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<ul>
<li>案例思路：set 排序， 存储班级成绩表，工资表排序，带权重执行，排行榜实现。</li>
</ul>
<h3 id="二、三种特殊数据类型"><a href="#二、三种特殊数据类型" class="headerlink" title="二、三种特殊数据类型"></a>二、三种特殊数据类型</h3><h4 id="2-1-geospatial-地理位置"><a href="#2-1-geospatial-地理位置" class="headerlink" title="2.1 geospatial 地理位置"></a>2.1 geospatial 地理位置</h4><ul>
<li>朋友的定位，附近的人，打车距离计算</li>
<li>只有6个命令：GEOADD，GEODIST，GEOHASH，GEOPOS，GEORADIUS，GEOGEORADIUSBYMEMBER</li>
<li><a href="http://redis.cn/commands/geoadd.html" target="_blank" rel="noopener">http://redis.cn/commands/geoadd.html</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line">&quot;166274.15156960039&quot;</span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 100 km</span><br><span class="line">1) &quot;Catania&quot;</span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km</span><br><span class="line">1) &quot;Palermo&quot;</span><br><span class="line">2) &quot;Catania&quot;</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
<p>GEOADD：添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>GEOPOS：获取当前定位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city shanghai hangzhou</span><br><span class="line">1) 1) &quot;121.47000163793563843&quot;</span><br><span class="line">   2) &quot;31.22999903975783553&quot;</span><br><span class="line">2) 1) &quot;120.1600000262260437&quot;</span><br><span class="line">   2) &quot;30.2400003229490224&quot;</span><br></pre></td></tr></table></figure>
<p>GEODIST：两个位置间距离<br>单位：m，km mt，ft</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city shanghai hangzhou</span><br><span class="line">&quot;166761.2770&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city shanghai hangzhou km</span><br><span class="line">&quot;166.7613&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>georadius附近的人？通过半径来找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 120 30 1000 km</span><br><span class="line">1) &quot;hangzhou&quot;</span><br><span class="line">2) &quot;shanghai&quot;</span><br><span class="line"></span><br><span class="line"># 限制一个</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 120 30 1000 km withdist withcoord count 1</span><br><span class="line">1) 1) &quot;hangzhou&quot;</span><br><span class="line">   2) &quot;30.8146&quot;</span><br><span class="line">   3) 1) &quot;120.1600000262260437&quot;</span><br><span class="line">      2) &quot;30.2400003229490224&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Hyperloglog"><a href="#2-2-Hyperloglog" class="headerlink" title="2.2 Hyperloglog"></a>2.2 Hyperloglog</h4><ul>
<li>简介</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网页的UV （一个人访问一个网站多次，但是还是算做一个人），传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断。这个方式如果保存大量的用户id，就会比较麻烦。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey 1 2 3 4 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey2 2 3 4 5 6</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey3</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>
<h4 id="2-3-Bigmaps"><a href="#2-3-Bigmaps" class="headerlink" title="2.3 Bigmaps"></a>2.3 Bigmaps</h4><h3 id="3-redis事务"><a href="#3-redis事务" class="headerlink" title="3.redis事务"></a>3.redis事务</h3><ul>
<li>redis单条命令是保存原子性的，但是<strong>事务不保证原子性。</strong></li>
<li><strong>Redis事务本质</strong>：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行。==一次性、顺序性、排他性==。</li>
<li>Redis事务没有隔离级别的概念。</li>
<li>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行。</li>
<li>redis的事务：<ul>
<li>开启事务（multi）</li>
<li>命令入队（）</li>
<li>执行事务（exec）</li>
<li>放弃命令 （discard）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi ## 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec ## 执行事务</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1 set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard  ## 事务队列中命令都不会被执行</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译期异常（代码有问题！命令有错），事务中的所有命令都不会被执行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k3</span><br><span class="line">(error) ERR wrong number of arguments for &apos;getset&apos; command</span><br><span class="line">127.0.0.1:6379&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec ##错误的命令，执行事务报错，所有命令都不会执行</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行期异常（1/0)，如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec ## 单条有原子性，整体没有</span><br><span class="line">1) (error) ERR value is not an integer or out of range</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4、Redis实现乐观锁"><a href="#4、Redis实现乐观锁" class="headerlink" title="4、Redis实现乐观锁"></a>4、Redis实现乐观锁</h3><blockquote>
<p>监控</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money # 监视money对象</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi #事务正常结束，数据期间没有发生变动，这个时候就正常执行。</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br></pre></td></tr></table></figure>
<ul>
<li>测试多线程修改完值，执行失败。watch监控，可以当做乐观锁操作。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line">&quot;80&quot;</span><br><span class="line">127.0.0.1:6379&gt; set money 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec #执行之前，另外一个线程，修改了值，这个时候，事务失败。</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果发现事务执行失败，就先解锁，获取最新的值，再次监视。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; unwatch </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
</ul>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【redis】：（3）进阶</title>
    <url>/2020/04/18/%E3%80%90redis%E3%80%91%EF%BC%9A%EF%BC%883%EF%BC%89%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="1、Redis发布订阅"><a href="#1、Redis发布订阅" class="headerlink" title="1、Redis发布订阅"></a>1、Redis发布订阅</h2><ul>
<li><p>Redis发布订阅是一种消息通信模式：发送者发送消息，订阅者接收消息。微信、微博、关注系统</p>
</li>
<li><p>Redis客户端可以订阅任意数量的频道<br><img src="876EC7F874BD48EAB3195A8D26865630" alt="image"></p>
</li>
<li><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的<br>关系：<br><img src="FFE9C6A0A11E4416A554DA09338BE0B0" alt="image"></p>
</li>
<li><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户<br>端：<br><img src="5830CB7746B04B39AEFF4F44FAD0B9C0" alt="image"></p>
</li>
<li><p>命令<br><img src="8CCE00D197CC4804AA8BB57E7AF89F02" alt="image"></p>
</li>
<li><p>测试</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 发布者</span><br><span class="line">127.0.0.1:6379&gt; publish kuangshengshuo &quot;hello ,kuangsheng&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">## 订阅者</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE kuangshengshuo #订阅一个频道</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;kuangshengshuo&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">#等待推送的信息</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;kuangshengshuo&quot;</span><br><span class="line">3) &quot;hello ,kuangsheng&quot;</span><br></pre></td></tr></table></figure>
<p>使用场景：</p>
</li>
<li><p>1、实时消息系统！</p>
</li>
<li><p>2、事实聊天！（频道当做聊天室，将信息回显给所有人即可！）</p>
</li>
<li><p>3、订阅，关注系统都是可以的！</p>
</li>
</ul>
<h2 id="2、主从复制"><a href="#2、主从复制" class="headerlink" title="2、主从复制"></a>2、主从复制</h2><ul>
<li><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点<br>(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。<br>Master以写为主，Slave 以读为主。<br>默认情况下，每台Redis服务器都是主节点；<br>且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。（）</p>
</li>
<li><p>主从复制的作用主要包括：</p>
</li>
</ul>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复 制是Redis高可用的基础。</li>
</ol>
<ul>
<li><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：</p>
<ul>
<li>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大。</li>
<li>2、从容量上，单个Redis服务器内容容量有限，就算一台Redis服务器内容容量为256G，也不能将所有内存用作Redis存储内存。一般来说，单台Redis最大使用内存不应该超过20G</li>
</ul>
</li>
<li><p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点就算多读少写<br><img src="89DA5855E54C43EE95404450D30C3614" alt="image"></p>
</li>
</ul>
<h4 id="集群环境配置"><a href="#集群环境配置" class="headerlink" title="集群环境配置"></a>集群环境配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication # 查看当前库的信息</span><br><span class="line"># Replication</span><br><span class="line">role:master # 角色 master</span><br><span class="line">connected_slaves:0 # 没有从机</span><br><span class="line">master_replid:77e9a2dbb3fe8d80bce84d540a8f1d53cc4ec09f</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>
<p>1、端口<br>2、pid 名字<br>3、log文件名字<br>4、dump.rdb 名字<br><img src="487B6EC08FA943029F7D9C1D84164635" alt="image"><br><img src="41DC5F8B880E4B6199616072ED1C32B3" alt="image"><br><img src="E2625A047D054811A15F051A6B323CEB" alt="image"><br><img src="FDABB502B5C448F9A3A2293D43B1D686" alt="image"></p>
<ul>
<li>修改完成后，启动我们三个redis进程。此时这三台都是主机<br><img src="E7459D92FA3E4338983E28D8FF2E0F82" alt="image"></li>
<li>一主二从。配置从机（slaveof）找谁当老大<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:4</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:14</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:4116b68ebe34cfd9140fc70c00a841bc3570003d</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure></li>
<li>真实的主从配置应该在配置文件中配置，这样的话是永久的。主机复制写，从机负责读。</li>
<li>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取主机的信息。</li>
<li>如果是使用命令行来配置的主从，这个时候如果重启了，就会变成主机只要变成从机，立马就会从主机中获取值，</li>
<li>复制原理：Slave 启动成功连接到 master 后会发送一个sync同步命令<br>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行<br>完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。<br>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。<br>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步<br>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中<br>看到！<blockquote>
<p>如果没有老大了，这个时候能不能选择一个老大出来。</p>
</blockquote>
</li>
<li>slaveof no one</li>
</ul>
<h2 id="3、哨兵模式"><a href="#3、哨兵模式" class="headerlink" title="3、哨兵模式"></a>3、哨兵模式</h2><h3 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h3><ul>
<li><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工<br>干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑<br>哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。<br>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。<br>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独<br>立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。<br><img src="11196C4729834A9AAE74CD1D11C882D0" alt="image"></p>
</li>
<li><p>这里的哨兵有两个作用：</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵监测到master宕机，会自动切换slave成master，然后通过发布订阅模式，通知其他的从服务器。修改配置文件，让他们切换主机</li>
</ul>
</li>
<li><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们使用多个哨兵进行监控。多哨兵模式<br><img src="73173BB20C4E4210877C003B1DC7E841" alt="image"></p>
</li>
<li><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认<br>为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一<br>定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。<br>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<br>客观下线。</p>
</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>1、配置哨兵配置文件 sentinel.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sentinel monitor 被监控的名称 host port 1 </span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br><span class="line"># 后面这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会称为主机</span><br></pre></td></tr></table></figure>
<ul>
<li>2、启动哨兵</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@iz2ze7g9h65aj7hp4a1l9bz bin]# redis-sentinel xlconfig/sentinel.conf </span><br><span class="line">8541:X 26 Apr 2020 19:08:06.039 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">8541:X 26 Apr 2020 19:08:06.039 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=8541, just started</span><br><span class="line">8541:X 26 Apr 2020 19:08:06.039 # Configuration loaded</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &apos;&apos;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &apos;&apos;-._           Redis 5.0.8 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   </span><br><span class="line"> (    &apos;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 26379</span><br><span class="line"> |    `-._   `._    /     _.-&apos;    |     PID: 8541</span><br><span class="line">  `-._    `-._  `-./  _.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line">      `-._    `-.__.-&apos;    _.-&apos;                                       </span><br><span class="line">          `-._        _.-&apos;                                           </span><br><span class="line">              `-.__.-&apos;                                               </span><br><span class="line"></span><br><span class="line">8541:X 26 Apr 2020 19:08:06.040 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">8541:X 26 Apr 2020 19:08:06.042 # Sentinel ID is 1231ff44204dd557619c339eb7628ff5cc9182d8</span><br><span class="line">8541:X 26 Apr 2020 19:08:06.042 # +monitor master myredis 127.0.0.1 6379 quorum 1</span><br><span class="line">8541:X 26 Apr 2020 19:08:06.043 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><span class="line">8541:X 26 Apr 2020 19:08:06.045 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379</span><br></pre></td></tr></table></figure>
<ul>
<li>发现6381变成了主机。如果原来的主机回来了，那只能当做从机。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=14249,lag=0</span><br><span class="line">master_replid:77a2ab0ed7454ba9efc54ae6ac73d1b6e5324e5d</span><br><span class="line">master_replid2:4116b68ebe34cfd9140fc70c00a841bc3570003d</span><br><span class="line">master_repl_offset:14249</span><br><span class="line">second_repl_offset:12615</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:169</span><br><span class="line">repl_backlog_histlen:14081</span><br></pre></td></tr></table></figure>
<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4></li>
<li>优点：<ul>
<li>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li>
<li>2、主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>3、哨兵模式就是主从模式的升级，手动变自动</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、Redis不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦</li>
<li>2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择<h4 id="哨兵模式的全部配置"><a href="#哨兵模式的全部配置" class="headerlink" title="哨兵模式的全部配置"></a>哨兵模式的全部配置</h4></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。 # quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了 # sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; sentinel monitor mymaster 127.0.0.1 6379 2 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供 密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass &lt;master-name&gt; &lt;password&gt; sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那 里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时， slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; bilibili：狂神说Java</span><br><span class="line">社会目前程序员饱和（初级和中级）、高级程序员重金难求！（提升自己！）</span><br><span class="line">Redis缓存穿透和雪崩</span><br><span class="line">服务的高可用问题！</span><br><span class="line">在这里我们不会详细的区分析解决方案的底层！</span><br><span class="line">Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一</span><br><span class="line">些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据</span><br><span class="line">的一致性要求很高，那么就不能使用缓存。</span><br><span class="line">另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</span><br><span class="line">sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信 息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。 #通知脚本 # shell编程 # sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已 经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt; # 目前&lt;state&gt;总是“failover”, # &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通 信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配 置！</span><br></pre></td></tr></table></figure>

<h3 id="4、1Redis缓存穿透和雪崩"><a href="#4、1Redis缓存穿透和雪崩" class="headerlink" title="4、1Redis缓存穿透和雪崩"></a>4、1Redis缓存穿透和雪崩</h3><ul>
<li>服务的高可用问题</li>
<li>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。最要害的是数据一致性问题。从严格意义上讲，这个问题无解，数据要求很高，就不能使用。<br><img src="11F9195DA2C84BA38EA4F3F5AC45DB14" alt="image"><h4 id="4-1缓存穿透概念"><a href="#4-1缓存穿透概念" class="headerlink" title="4.1缓存穿透概念"></a>4.1缓存穿透概念</h4>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，于是想持久层数据库查询，发现也没有，并发高的时候，给数据库造成很大的压力，这时候就是缓存穿透。</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>布隆过滤器：是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。<br><img src="EFE8568EB5AE4F3DBD877FD65AD75DF3" alt="image"></li>
<li>缓存空对象：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中存取，保护了后端数据源。<br><img src="B5EBC2ABFD9745CFB63C90DB1626C27C" alt="image"><br>但是这种方法会存在两个问题：<br>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多<br>的空值的键；<br>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于<br>需要保持一致性的业务会有影响。</li>
</ul>
<h4 id="4-2缓存击穿"><a href="#4-2缓存击穿" class="headerlink" title="4.2缓存击穿"></a>4.2缓存击穿</h4><ul>
<li>概述：这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中<br>对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一<br>个屏障上凿开了一个洞。<br>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访<br>问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</li>
</ul>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>设置热点数据永不过期</li>
<li>加互斥锁<br>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布<br>式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考<br>验很大。<br><img src="113D4444F6C34A98BC2EB8F1E70DE38A" alt="image"></li>
</ul>
<h4 id="4-3-缓存雪崩"><a href="#4-3-缓存雪崩" class="headerlink" title="4.3 缓存雪崩"></a>4.3 缓存雪崩</h4><ul>
<li>概念：缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！<br>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商<br>品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都<br>过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波<br>峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。<br><img src="729D391EC655497A8A464D8458BC86CE" alt="image"><br>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然<br>形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就<br>是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知<br>的，很有可能瞬间就把数据库压垮。</li>
</ul>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>redis高可用<br>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</li>
<li>限流降级（在SpringCloud讲解过！）<br>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li>
<li>数据预热<br>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li>
</ul>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作】：入职前的一些规划</title>
    <url>/2019/11/18/%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91%EF%BC%9A%E5%85%A5%E8%81%8C%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%92%E5%92%8C%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[##  一、前言

<p>&emsp;&emsp;未来不可知，上海的职业生涯将正式开始，花自缤纷花自谢，时间太紧了，拼不了爹的自己只能拼命去学习。万一实现了呢？ </p>
<h2 id="二、未来计划（2019-11-2021-9）"><a href="#二、未来计划（2019-11-2021-9）" class="headerlink" title="二、未来计划（2019.11-2021.9）"></a>二、未来计划（2019.11-2021.9）</h2><p>&emsp;&emsp;我希望在这近两年的时间内，竭尽全力的提升自己，努力往（三初一高）的方向发展：    </p>
<ul>
<li><strong>高级的Java开发</strong>；</li>
<li><strong>初级的大数据学习者</strong>；</li>
<li><strong>初级的人工智能学习者</strong>；</li>
<li><strong>初级的vr学习者</strong>；</li>
</ul>
<h2 id="三、着手当下"><a href="#三、着手当下" class="headerlink" title="三、着手当下"></a>三、着手当下</h2><ol>
<li>融入公司，跟上工作节奏。</li>
<li>学习不再片面，有条理的规划出一块内容深入学习</li>
<li>每周抽出20个小时的时间学习新知识。</li>
<li>不打游戏。</li>
<li>开始阅读书籍，书单已经选好。</li>
<li>开始慢慢的理财，关注房价和理财的事儿。</li>
<li>待更。。。</li>
</ol>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【并发编程的艺术】：(1)并发编程的挑战</title>
    <url>/2020/05/16/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>学完了JUC的大概后，现在准备看书学习，深入了解一些底层的东西，更好的理解并发编程的概念。并发编程的目的是为了程序运行的更快，但是是不是线程越多执行的就越快呢？其实并不然，并发编程的世界里面临着很多挑战：比如上下文切换，死锁问题，以及受限于硬件和软件的资源限制问题。</li>
</ul>
<h4 id="一、上下文切换"><a href="#一、上下文切换" class="headerlink" title="一、上下文切换"></a>一、上下文切换</h4><ul>
<li><p>cpu通过给每个线程分配CPU时间片，时间片是CPU分配给各个线程的时间，一般是几十毫秒。不同的线程去抢夺这个是时间片，CPU也不停的切换线程，让我们感觉是同时执行的。</p>
</li>
<li><p>CPU通过时间分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务，但是在切换前会保存上一个任务的状态，以便下次切换回到这个任务时，可以再加载这个任务的状态，所以<strong>保存任务到再加载的过程就是一次上下文切换。</strong></p>
</li>
<li><p>cs（content Switch）：上下文切换次数</p>
</li>
</ul>
<h4 id="二、如何减少上下文切换"><a href="#二、如何减少上下文切换" class="headerlink" title="二、如何减少上下文切换"></a>二、如何减少上下文切换</h4><ul>
<li>1、无锁并发编程：避免使用锁。</li>
<li>2、CAS算法：Java的Atomic包下使用CAS算法来更新数据，而不需要加锁。效率比加锁高</li>
<li>3、使用较少线程：如果任务较少，就不要创建这么多线程，造成资源浪费</li>
<li>4、协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。（协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行）</li>
</ul>
<h4 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h4><ul>
<li>我的理解就是两个线程互相占有对方线程所需要的锁又去相互获取锁的过程，使得两个线程互相等待对方释放锁。</li>
<li>避免死锁的几个方法：<ul>
<li>1、避免一个线程同时获取多个锁</li>
<li>2、避免一个线程在锁内同时占用多个资源，降低锁的粒度</li>
<li>3、尝试使用定时锁，使用lock.tryLock来替代使用内部锁机制</li>
</ul>
</li>
<li>手写一个死锁：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DeathLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Death death1 = new Death();</span><br><span class="line">        Death death2 = new Death();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            death1.setFlag(1);</span><br><span class="line">            death1.deathMethod();</span><br><span class="line">        &#125;,&quot;线程1&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            death2.setFlag(2);</span><br><span class="line">            death2.deathMethod();</span><br><span class="line">        &#125;,&quot;线程2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Death&#123;</span><br><span class="line">    private int flag=1;</span><br><span class="line">    private static final Object o1=new Object();</span><br><span class="line">    private static final Object o2=new Object();</span><br><span class="line"></span><br><span class="line">    public void setFlag(int flag)&#123;</span><br><span class="line">        this.flag=flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deathMethod()&#123;</span><br><span class="line">        if(flag==1)&#123;</span><br><span class="line">            synchronized (o1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;o1&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(800);//等待时间让其他线程获取</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (o2)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;o2&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag==2)&#123;</span><br><span class="line">            synchronized (o2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;o2&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(800);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (o1)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;o1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、资源限制的挑战"><a href="#四、资源限制的挑战" class="headerlink" title="四、资源限制的挑战"></a>四、资源限制的挑战</h4><ul>
<li>比如我们启动一个微服务项目，很可能内存就100%，一个服务几百兆，多线程编程也会有这点问题，会有资源的限制，所以要在资源限制下进行编程。</li>
</ul>]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【潇雷】：风雨求职路</title>
    <url>/2019/11/14/%E3%80%90%E6%B1%82%E8%81%8C%E3%80%91%E9%82%A3%E4%BA%9B%E5%BF%83%E9%85%B8%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>一转眼，来上海就两个半月了，由夏至秋，天气转凉。  如今找工作的事情终于尘埃入定。  应届生社招时的碰壁让我深受打击，不仅投过实习的岗位，也频频报低价格卑微地换取一份糊口的工作，最后，还是没有放弃，总有适合你的工作在等待你。熬一熬，就过去了。</p>
<h1 id="2-求职"><a href="#2-求职" class="headerlink" title="2.求职"></a>2.求职</h1><h2 id="2-1-简历"><a href="#2-1-简历" class="headerlink" title="2.1 简历"></a>2.1 简历</h2><p>面了一个月，boss沟通八百多家，拉钩5年以下全投过，换来的是寥寥无几的面试机会，从刚开始投简历到找到工作的前两天还改些简历中的小毛病，慢慢的，我发现越到后面，我这简历竟然也能入的了一些大中厂的眼，虽然写的一年工作经验，虽然念的是普通二本非科班，这些特征在浩浩荡荡的简历海洋中本就该沉入海底的，我回头想想，除了那些项目，专业技能外，还有两点：第一是我把本科的CPA专业排名第二写上去了，还有一些奖学金，数学竞赛奖，这些起码能说明我在大学还是学了点东西的。第二是我添加了自己的个人博客和微信公众号，虽然不知道他们会不会看，虽然csdn很low，文章也不多，但是看着还是很努力的。所以个人博客的重要性在面试的时候还是挺加分的。因此，在往后的学习工作中，我将以博客的形式来记录自己的学习和生活。</p>
<h2 id="2-2-面试"><a href="#2-2-面试" class="headerlink" title="2.2 面试"></a>2.2 面试</h2><p><strong>第一家:</strong> 去了个培训机构，叫一堆的人去面试，做了几道nc逻辑题，结果全给做错了，连培训机构都不想要我，hhhh，服了，现在培训机构也挑人了吗？<br><strong>第二家:</strong> 是一个医疗相关的，面试很紧张，终于来了次正经的技术面，下面是面试题  </p>
<p><strong>1.两个linux之间相互传文件怎么做？</strong><br>答：可以使用SCP命令。  </p>
<p><strong>2.mysql查询前十条数据怎么做？</strong><br>select * from emp LIMIT 0,10  </p>
<p><strong>3.js怎么定义数组？</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种  </span><br><span class="line">            var arr = new Array();  </span><br><span class="line">            arr[0] = 123  </span><br><span class="line">            arr[1] = &quot;abc&quot;;  </span><br><span class="line">            arr[5] = false;  </span><br><span class="line">            alert(arr[3]);//undefined  </span><br><span class="line">            alert(arr);//123,abc,,,,false  </span><br><span class="line">            alert(arr[10]);//undefined，不会出现越界异常  </span><br><span class="line">            </span><br><span class="line">            //for in 遍历，未定义的不遍历</span><br><span class="line">            for(var i in arr)&#123;</span><br><span class="line">                alert(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">            //第二种  </span><br><span class="line">            var arr2 = new Array(2);//规定了数组的长度为2  </span><br><span class="line">            arr2[0] = &quot;ddd&quot;;  </span><br><span class="line">            arr2[1] = &quot;www&quot;;  </span><br><span class="line">            alert(arr2);//ddd,www  </span><br><span class="line">            arr2[2] = &quot;fff&quot;;//可以再次添加元素，定义的数组大小对此没有影响  </span><br><span class="line">            alert(arr2);//ddd,www,fff  </span><br><span class="line">                 </span><br><span class="line">            //第三种  </span><br><span class="line">            var arr3 = new Array(true,123,false);  </span><br><span class="line">            alert(arr3);//true,123,false  </span><br><span class="line">              </span><br><span class="line">            //第四种,推荐使用  </span><br><span class="line">            var arr4 = [false,&quot;aaa&quot;,123];  </span><br><span class="line">            alert(arr4);//false,aaa,123</span><br></pre></td></tr></table></figure>
<p><strong>4.vue的条件判断的指令？</strong><br> v-if指令。  </p>
<p><strong>5.git是干嘛的？（版本控制系统）</strong>  </p>
<p><strong>6.java的空指针怎么发生的？口述两行代码，一定会发生空指针？</strong><br>当一个对象不存在时，又调用它的话就会产生空指针异常。<br>object o=null；<br>o.tostring();</p>
<p><strong>7.java的数组越界是怎样的？像ArrayList这种自动增长的，它有没有可能发生越界？为什么？</strong><br>因为arrayList是线程不安全的类，当出现多个线程同时添加元素的时候，此时arrayList就会可能会出现数组越界的问题。  </p>
<p><strong>8.java的自定义注解是怎么解析的？（反射，加载成.class字节码文件）</strong>  </p>
<p><strong>9.定义一个简单的java类，这个类要使它能够表达简单的树形结构，那么这个类的关键特征是什么？</strong><br>就是有两个成员变量，类型是自己，分别指向左子树和右子树（以二叉树为例）。  </p>
<p>中间还问了点单词数学，应该是比较缺人，然后虽然我面试的很差，很多答不上来，但是过了几天还是给我发offer，只不过面试的时候就说就面试来看，我只值6k，我也同意它的说法，但是还是想多面几家试试，就拒绝了，没想到后面才正式开始了苦逼之路。</p>
<p><strong>第三家:</strong> 是一个50人左右的公司，做笔试题的时候，发现难度简直升级，结果笔试题都写不下去，就灰溜溜的回去了，下面是部分笔试题：<br>1.1万个人抢100个红包，如何保证2个人不能抢到同一个红包？<br>2.Git如何放弃工作区的更改？<br>3.写一个方法，处理接收POST类型的JSON参数的请求（参数为name，age）<br>4.POST请求是否可以是url？a=b&amp;c=d的形式请求？如何不可以请说出理由<br>5.设计一个对外服务的接口实现类，在1，2，3这三台主机上（有不同的IP地址）实现负载均衡和顺序轮询机制<br>6.@Scheduled是否为多线程执行，如果是请说明理由，否则请给出解决方案；<br>7.通过Nginx实现：访问<a href="http://test.ab.com，代理请求到http://101.101.1.1.9/" target="_blank" rel="noopener">http://test.ab.com，代理请求到http://101.101.1.1.9/</a><br>8.以JAR包的方式部署temp.jar，请写出部署命令，以及查看Java进程，结束进程</p>
<p><strong>第四家：</strong> 自第三家受打击之后就停下来复习了一周，当时也感觉面试好多，才没投几家就去面试了，所以当时想不把一些机会白白浪费掉，尽管如此，现在想来这种做法特别不好，不能停这么久，而且自己学真的学不到那么多，还是少约点面试，保持两天内一个面试放慢节奏还是比较好的。这家面了一个实习，在上海的团队就他一个人，想想就优点怕，它也看出来我心里的担心，最后可能倒在了沟通问题，以及非全日制，和技术回答的比较死板，考虑问题没有挖很深，很多都是直接从面经上看来，比如hashtable为什么不能为null？  </p>
<p><strong>第五家:</strong> 这次去的是一个岗位上技能啥都不要求的公司，会c，python，java就可以，我以为可能又是骗子公司，没想到公司也没想象中那么小，然后填完信息领到面试官那里，让我上机，实现一个在一个64*64的棋盘上，找出他给的100个点里的最短路径，然后让我开始写，我慢慢的脑子陷入了，感觉到现在都没理解好提议，它给的100个点如何输入到电脑里，一个二维数组，怎么接收这些点，然后算法用迪杰斯特拉算法怎么实现？虽然考研的时候做过这种算法找最短路径的点，但是要真让我实现，还真狠有难度，最后不来了之，自此又陷入自闭。 </p>
<p><strong>第六家，第七家：</strong>  上海无果，开始换城市，突发的选了嘉兴，去嘉兴，嘉善分别面了两家，第一家，做金融还要出差，感觉也不是想招人的意思，随便问的一些aop，springboot热部署等问题，最后我还是因为技术没过关被刷了，然后赶去嘉善面试，这个初创公司感觉面试官的他的三年经验很有水分，随便聊聊项目就过了，基础也没问，后面给我开了8k，最后犹豫再三还是拒了，初创公司不敢去，更别提没个大牛的初创公司。  </p>
<p><strong>第八家：</strong>  开始转战上海，一个金融相关的，我面试的感觉还不错，也感觉有希望进，但是最后不知道什么原因被刷了，这家我还是挺想去的。至少工作还是挺成熟的。 </p>
<p><strong>第九家：</strong> 做智能健身相关的，面试官技术很强，阿里出来的年轻小伙，但是给我的感觉是有点轻蔑，可能这就是牛人吧，最后我都报到6k了，但是我感觉那岗位学的东西也不多，不是纯java开发的。</p>
<p><strong>第十家：</strong> 转眼又过了一周，这家去了轻轻家教，面的问题很灵活，数据结构的知识我真的忘了很多，但是面试官人很好，跟我聊了挺久的。不过自己还是太菜了，我只想说面试还是很看重运气和那岗位的缺人程度的，最后惨败吧。 </p>
<p><strong>第十一家：</strong> 又跑了很远的地方去面试，一个挂羊头卖狗头的，应该是猎头公司，收集了很多面试人的信息资料，随便聊聊就不面了。也没抱希望。  </p>
<p><strong>第十二家：</strong> 这家是挺正规的，离我住处最近的一家了，走路十分钟就到了，面试之前看到这家岗位已经关闭了，面试官是一个很年轻的，这种年轻没多少面试经验的面试官会故意问的比较深，来展示他的能力，根本不从实际情况来面，我就一年的实习经验，把我当几年的面，还问我有没有带过人？也问了一些假大空的问题，消息堆积，重复消费，服务挂了怎么看等等，然后一个小时的面试，直接说，今天的面试到此结束。我就灰溜溜的回去了，不想要我干嘛浪费两个人的时间。</p>
<p><strong>第十三家：</strong> 这次是最后一次面试了，公司环境不错，成立八年的互联网公司，也有自己的产品，面积也很大，然后经过两轮的技术面试和一轮的hr小姐姐沟通后，拿到了offer，不过技术用的有点老旧，犹豫下还是去了。面试总结的问题就是提升自己的沟通能力，很多东西，你得学会用自己的话来很精准的描述它，这种能力也是需要锻炼出来的。</p>
<h2 id="3感慨"><a href="#3感慨" class="headerlink" title="3感慨"></a>3感慨</h2><p>这一个多月我经历了什么？我得到了什么？<br>我的生活才刚刚开始，未来可期。<br>记两首诗：</p>
<p><strong>《夜》</strong><br>晚风拂我意，<br>荧屏对相思。<br>奔波十里外，<br>另觅橄榄枝。  </p>
<p><strong>《光》</strong><br>九月憧憬，新奇欲试笔与刀。<br>十月无闻，无花树下羞与闹。<br>十一过半，滩里霓虹光与照。</p>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>【并发编程的艺术】：(2)volatile的原理</title>
    <url>/2020/05/16/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89volatile%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>以前学完多线程后还是没听过这个词，就在面试题里看到过，后来学了JUC后，发现这个是和Synchronized一样强大的存在，而这次就借着这个机会再次学习下这个东东。</li>
</ul>
<h4 id="一、Jmm引入"><a href="#一、Jmm引入" class="headerlink" title="一、Jmm引入"></a>一、Jmm引入</h4><ul>
<li><p>说道volatile 就得提及jmm。jmm是java内存模型，是一种约定，实际并不存在。</p>
</li>
<li><p>约定：</p>
<ul>
<li>1、线程解锁前，必须把共享变量立刻刷回主存</li>
<li>2、线程加锁前，必须读取主存的最新值到工作内存</li>
<li>3、加锁和解锁是同一把锁<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/detail/thread/QQ%E6%88%AA%E5%9B%BE20200516003207.png" alt="image"></li>
</ul>
</li>
<li><p>出现的问题：一个线程改变了主存的值，另一个线程不知道它发生了概念。内存不可见。所以引出了volatile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock     （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</span><br><span class="line">   unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</span><br><span class="line">   read    （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</span><br><span class="line">   load     （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</span><br><span class="line">   use      （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</span><br><span class="line">   assign  （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</span><br><span class="line">   store    （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</span><br><span class="line">   write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="二、volatile的原理"><a href="#二、volatile的原理" class="headerlink" title="二、volatile的原理"></a>二、volatile的原理</h4><ul>
<li>它在多处理器开发中保证了共享变量的可见性。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</li>
</ul>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">instance =new Singleton（）  //instance是volatile变量</span><br><span class="line"></span><br><span class="line"># 转为汇编代码后：会多出第二行，是以lock开头的</span><br><span class="line">0x01a3deld: movb &amp;0x0 .....;</span><br><span class="line">lock addl $0x0... ;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Lock前缀的指令会引发两件事：</p>
<ul>
<li>1、将当前处理器缓存行的数据写回到系统内存</li>
<li>2、这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</li>
</ul>
</li>
<li><p>为了提高处理速度，处理器不直接和内存进行通信，而是将系统内存的数据读到内部缓存后再操作。如果没加volatile的话，它不知道何时会写入内存。而对声明了volatile的变量，jvm会向处理器发送一条Lock前缀的指令，将这变量的缓存值写入内存；利用多处理下的缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，如果发现这个值被修改了，就会把当前缓存值设为无效，重新去主存获取新的数据。</p>
</li>
</ul>]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】：代理模式</title>
    <url>/2020/02/27/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul>
<li>为什么要学该模式？因为这就是SpringAop的底层</li>
<li>代理模式的分类：<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
</li>
</ul>
<h3 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h3><ul>
<li><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的对象</li>
<li>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
</li>
<li><p>静态代理的好处：</p>
<ul>
<li>可以使我们的真实角色更加纯粹，不再关注一些公众的事情</li>
<li>公共的业务由代理来完成，实现了业务的分工</li>
<li>公共业务发生扩展时会变得更加集中方便。</li>
</ul>
</li>
<li><p>静态代理的缺点：</p>
<ul>
<li>多了代理类，工作量变大。</li>
</ul>
</li>
</ul>
<h3 id="3、静态代理的例子理解"><a href="#3、静态代理的例子理解" class="headerlink" title="3、静态代理的例子理解"></a>3、静态代理的例子理解</h3><ol>
<li>创建一个抽象角色。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//抽象角色：增删改查业务</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void add();</span><br><span class="line">    void delete();</span><br><span class="line">    void update();</span><br><span class="line">    void query();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>真实对象完成这些操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//真实对象，完成增删改查操作的人</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;增加了一个用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        System.out.println(&quot;删除了一个用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;更新了一个用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void query() &#123;</span><br><span class="line">        System.out.println(&quot;查询了一个用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>增加一个日志功能</li>
<li>设置一个代理类来处理日志</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代理角色，在这里面增加日志的实现</span><br><span class="line">public class UserServiceProxy implements UserService &#123;</span><br><span class="line">    private UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    public void setUserService(UserServiceImpl userService) &#123;</span><br><span class="line">        this.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        log(&quot;add&quot;);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        log(&quot;delete&quot;);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        log(&quot;update&quot;);</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void query() &#123;</span><br><span class="line">        log(&quot;query&quot;);</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试访问类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //真实业务</span><br><span class="line">        UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">        //代理类</span><br><span class="line">        UserServiceProxy proxy = new UserServiceProxy();</span><br><span class="line">        //使用代理类实现日志功能！</span><br><span class="line">        proxy.setUserService(userService);</span><br><span class="line"></span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、动态代理"><a href="#4、动态代理" class="headerlink" title="4、动态代理"></a>4、动态代理</h3><ul>
<li><p>动态代理的角色和静态代理的一样</p>
</li>
<li><p>动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类：一类是基于接口动态代理，一类是基于类的动态代理</p>
<ul>
<li>基于接口:jdk动态代理</li>
<li>基于类：cglib</li>
</ul>
</li>
<li><p>jdk动态代理需要了解两个类：</p>
</li>
</ul>
<p>核心 : InvocationHandler 和 Proxy</p>
<h5 id="【InvocationHandler：调用处理程序】"><a href="#【InvocationHandler：调用处理程序】" class="headerlink" title="【InvocationHandler：调用处理程序】"></a>【InvocationHandler：调用处理程序】</h5><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1738839022.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object invoke(Object proxy, 方法 method, Object[] args)；</span><br><span class="line">//参数 </span><br><span class="line">//proxy - 调用该方法的代理实例 </span><br><span class="line">//method -所述方法对应于调用代理实例上的接口方法的实例。 方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 </span><br><span class="line">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。 原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span><br></pre></td></tr></table></figure>

<h5 id="【Proxy：代理】"><a href="#【Proxy：代理】" class="headerlink" title="【Proxy：代理】"></a>【Proxy：代理】</h5><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3889331720.png" alt="image"><br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2362460967.png" alt="image"><br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/269587194.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//生成代理类</span><br><span class="line">public Object getProxy()&#123;</span><br><span class="line">    return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">                                  rent.getClass().getInterfaces(),this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、动态代理代码实现"><a href="#5、动态代理代码实现" class="headerlink" title="5、动态代理代码实现"></a>5、动态代理代码实现</h3><ol>
<li>抽象角色（接口）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//抽象角色：租房</span><br><span class="line">public interface Rent &#123;</span><br><span class="line">    public void rent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>真实角色</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">房东，房东要出租房子</span><br><span class="line">public class Host implements Rent&#123;</span><br><span class="line">    public void rent() &#123;</span><br><span class="line">        System.out.println(&quot;房屋出租&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.ProxyInvocationHandler. java 即代理角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProxyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Rent rent;</span><br><span class="line"></span><br><span class="line">    public void setRent(Rent rent) &#123;</span><br><span class="line">        this.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span><br><span class="line">    public Object getProxy()&#123;</span><br><span class="line">        return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">                rent.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span><br><span class="line">    // 处理代理实例上的方法调用并返回结果</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        //核心：本质利用反射实现！</span><br><span class="line">        Object result = method.invoke(rent, args);</span><br><span class="line">        fare();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //看房</span><br><span class="line">    public void seeHouse()&#123;</span><br><span class="line">        System.out.println(&quot;带房客看房&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //收中介费</span><br><span class="line">    public void fare()&#123;</span><br><span class="line">        System.out.println(&quot;收中介费&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.客户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//租客</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //真实角色</span><br><span class="line">        Host host = new Host();</span><br><span class="line">        //代理实例的调用处理程序</span><br><span class="line">        ProxyInvocationHandler pih = new ProxyInvocationHandler();</span><br><span class="line">        pih.setRent(host); //将真实角色放置进去！</span><br><span class="line">        Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>核心：一个动态代理可以代理多个类，代理的是接口。</p>
</li>
<li><p>动态代理的好处：</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
</li>
</ul>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【java基础】：(2)注解</title>
    <url>/2020/03/14/%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><ol>
<li>概念</li>
<li>5个基本注解</li>
<li>jdk元注解</li>
<li>自定义注解</li>
</ol>
<h3 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h3><ul>
<li>Annotation：其实是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用注解，开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。</li>
<li><strong>注解本质</strong>：是一个接口，程序可以通过反射来获取指定程序元素的java.lang.annotation.Annotation对象，然后通过java.lang.annotation.Annotation对象来获取注解里的元数据。</li>
<li>注解是在jdk5后引入的<h5 id="注解的作用："><a href="#注解的作用：" class="headerlink" title="注解的作用："></a>注解的作用：</h5></li>
<li>不是程序本身，可以对程序作出解析。可以被其他程序(比如编译器等)读取。<h5 id="注解的格式："><a href="#注解的格式：" class="headerlink" title="注解的格式："></a>注解的格式：</h5>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings（value=“unchecked”）。</li>
</ul>
<h3 id="二、基本注解"><a href="#二、基本注解" class="headerlink" title="二、基本注解"></a>二、基本注解</h3><ul>
<li>@Override</li>
<li>@Deprecated</li>
<li>@SuppressWarnings</li>
<li>@SafeVarags</li>
<li>@FunctionalInterface</li>
</ul>
<h4 id="2-1-Override-限定重写父类方法"><a href="#2-1-Override-限定重写父类方法" class="headerlink" title="2.1 @Override:限定重写父类方法"></a>2.1 @Override:限定重写父类方法</h4><ul>
<li>存在意义：避免犯低级错误，方法名写错等<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class People &#123;</span><br><span class="line">    public void info()&#123;</span><br><span class="line">        System.out.println(&quot;吃饭，睡觉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Teacher extends People&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void info() &#123;</span><br><span class="line">        System.out.println(&quot;教书&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-Deprecated"><a href="#2-2-Deprecated" class="headerlink" title="2.2 @Deprecated"></a>2.2 @Deprecated</h4></li>
<li>表示程序元素（类、方法）等已过时，当其他程序使用已知的类、方法时，编译器将会发出警告。警告方式为将该方法名划掉</li>
</ul>
<h4 id="2-3-SuppressWarnings：镇压警告"><a href="#2-3-SuppressWarnings：镇压警告" class="headerlink" title="2.3 @SuppressWarnings：镇压警告"></a>2.3 @SuppressWarnings：镇压警告</h4><ul>
<li>可以取消编译器警告。</li>
<li>@SuppressWarnings（value=“unchecked”）</li>
</ul>
<h4 id="2-4-SafeVarags与堆污染？"><a href="#2-4-SafeVarags与堆污染？" class="headerlink" title="2.4 @SafeVarags与堆污染？"></a>2.4 @SafeVarags与堆污染？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List list = new ArrayList&lt;&gt;();</span><br><span class="line">       list.add(20);//添加元素时引发unchecked异常</span><br><span class="line">       //未经检查的转换的警告，编译，运行时完全正常</span><br><span class="line">       List&lt;String&gt; ls=list;</span><br><span class="line">       //只要访问ls里面的元素，如下面代码就会引发运行时异常</span><br><span class="line">       System.out.println(ls.get(0));</span><br></pre></td></tr></table></figure>
<ul>
<li>引发这种错误的原因称为“堆污染”，<strong>当把一个不带泛型的对象赋给一个带泛型的变量时</strong>，往往会发生这种“堆污染”，</li>
<li>此时，虽然可以使用镇压警告，但还是建议在处理堆污染的时候使用@SafeVarags，Java7出现，专门抑制堆污染警告。Java9增强了该注解，允许使用该注解修饰私有实例方法。</li>
</ul>
<h4 id="Java8的函数式接口"><a href="#Java8的函数式接口" class="headerlink" title="Java8的函数式接口"></a>Java8的函数式接口</h4><ul>
<li>如果接口中只有一个抽象方法，该接口就是函数式接口，@FunctionalInterface就是用来指定某个接口必须是函数式接口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunInterface &#123;</span><br><span class="line">    void test();</span><br><span class="line">    void test2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在上述接口中存在两个函数式接口，编译会爆出下面错误。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error:(7, 1) java: 意外的 @FunctionalInterface 注释</span><br><span class="line">  com.example.demo.FunInterface 不是函数接口</span><br><span class="line">    在 接口 com.example.demo.FunInterface 中找到多个非覆盖抽象方法</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="三、JDK元注解"><a href="#三、JDK元注解" class="headerlink" title="三、JDK元注解"></a>三、JDK元注解</h3><h4 id="3-1-使用-Retention"><a href="#3-1-使用-Retention" class="headerlink" title="3.1 使用@Retention"></a>3.1 使用@Retention</h4><ul>
<li>@Retention只能用于修饰注解定义，<strong>用于指定被修饰的注解可以保留多长时间</strong>，@Retention包含一个RetentionPolicy类型的value成员变量，所以使用2Retention时必须为该value衡阳变量指定值。</li>
<li>value的成员变量：<ul>
<li>RetentionPolicy.CLASS:编译器将把注解记录在class文件中。当运行程序时，JVM不可获取注解信息，这是默认值。</li>
<li>RetentionPolicy.RUNTIME:编译器把注解记录在class文件中，当运行时，JVM可获取注解信息，程序可以通过反射来获取注解信息。</li>
<li>RetentionPolicy.SOURCE:保留在源代码中，编译器直接丢弃该注解</li>
</ul>
</li>
<li>总结：如果需要通过反射获取注解信息，就需要使用value属性值为 RetentionPolicy.RUNTIME的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface a();</span><br></pre></td></tr></table></figure>
<h4 id="3-2-使用Target"><a href="#3-2-使用Target" class="headerlink" title="3.2 使用Target"></a>3.2 使用Target</h4><ul>
<li>@Target也只能修饰注解定义，它用于指定被修饰的注解能用于修饰哪些程序单元。@Target元注解也包含一个名为value的成员变量，该成员变量的值只能是如下几个。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/code/java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3.png" alt="image"></li>
</ul>
<h4 id="3-3-使用Documented"><a href="#3-3-使用Documented" class="headerlink" title="3.3 使用Documented"></a>3.3 使用Documented</h4><ul>
<li>@Documented用于指定被该元注解修饰的注解类将被javadoc工具提取成文档，如果定义注解类时使用了@Documented修饰，则所有使用该注解修饰的程序元素的api文档中将会包含该注解说明。</li>
</ul>
<h4 id="3-4-使用-Inherited"><a href="#3-4-使用-Inherited" class="headerlink" title="3.4 使用@Inherited"></a>3.4 使用@Inherited</h4><ul>
<li>@Inherited元注解指定被它修饰的注解将具有继承性，如果某个类使用了@Xxx注解，则其子类时将自动被@Xxx修饰。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">public @interface Inheritable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Inheritable</span><br><span class="line">public class Base &#123;</span><br><span class="line">&#125;</span><br><span class="line">class BaseSon extends Base&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Base.class.isAnnotationPresent(Inheritable.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、自定义注解"><a href="#四、自定义注解" class="headerlink" title="四、自定义注解"></a>四、自定义注解</h3><h4 id="4-1-自定义元注解"><a href="#4-1-自定义元注解" class="headerlink" title="4.1 自定义元注解"></a>4.1 自定义元注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    @MyAnnotation</span><br><span class="line">    public void test()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个注解</span><br><span class="line"> * Target:表示我们的注解可以用在哪些地方</span><br><span class="line"> * Retention：表示我们的注解可以用在哪些地方</span><br><span class="line"> * Documented:表示是否将我们的注解生成在java文档中</span><br><span class="line"> * Inherited:子类可以继承父类的注解</span><br><span class="line"> * runtime&gt;class&gt;source</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)//约束，在方法层使用</span><br><span class="line">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@interface MyAnnotation</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-自定义注解使用"><a href="#4-2-自定义注解使用" class="headerlink" title="4.2 自定义注解使用"></a>4.2 自定义注解使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: XiaoLei</span><br><span class="line"> * @Date Created in 14:14 2020/2/7</span><br><span class="line"> * 自定义注解</span><br><span class="line"> */</span><br><span class="line">public class Test3 &#123;</span><br><span class="line">    @MyAnnotation2(name = &quot;潇雷&quot;,schools = &quot;华东师范大学&quot;)</span><br><span class="line">    public void test()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    @MyAnnotation3(&quot;潇雷&quot;)</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="line">@interface MyAnnotation2&#123;</span><br><span class="line">    //注解的参数：参数类型+参数名（）；</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line">    int age() default 0;</span><br><span class="line">    int id() default -1;//如果默认值为-1代表不存在</span><br><span class="line">    String[] schools();</span><br><span class="line">//  String name() ; 没有默认值就要自己重写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="line">@interface MyAnnotation3&#123;</span><br><span class="line">    String value();//只有一个属性的时候，建议用value，然后在备注注解时可以直接使用内容，而不需要写value=多少</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-注解与配置文件"><a href="#4-3-注解与配置文件" class="headerlink" title="4.3 注解与配置文件"></a>4.3 注解与配置文件</h4><ul>
<li>配置文件：<ul>
<li>优点：可配置，不用改源码。</li>
<li>缺点：不直观，开发效率低</li>
</ul>
</li>
<li>注解：<br>  -优点：直观，开发效率高<br>  -缺点：硬编码，修改之后需要重新编译运行</li>
</ul>
<h4 id="4-4-注解使用注意事项"><a href="#4-4-注解使用注意事项" class="headerlink" title="4.4 注解使用注意事项"></a>4.4 注解使用注意事项</h4><ul>
<li><ol>
<li>要用好注解，必须熟悉Java 的反射机制，从上面的例子可以看出，注解的解析完全依赖于反射。</li>
</ol>
</li>
<li><ol start="2">
<li>不要滥用注解。平常我们编程过程很少接触和使用注解，只有做设计，且不想让设计有过多的配置时，才需要考虑注解。</li>
</ol>
</li>
</ul>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>【java基础】：(1)反射机制</title>
    <url>/2020/02/18/%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="java基础之反射"><a href="#java基础之反射" class="headerlink" title="java基础之反射"></a>java基础之反射</h1><ul>
<li><strong>1、反射概述</strong></li>
<li><strong>2、获取class类型的对象</strong></li>
<li><strong>3、通过反射获取构造方法并使用</strong></li>
<li><strong>4、通过反射获取成员变量并使用</strong></li>
<li><strong>5、通过反射并获取成员方法并使用</strong></li>
</ul>
<h2 id="1、反射概述"><a href="#1、反射概述" class="headerlink" title="1、反射概述"></a>1、反射概述</h2><p>&emsp;&emsp;java不是动态 语言，但java可以被称为准动态语言，因为它的反射机制。而这个反射机制是java被视为动态语言的关键。反射机制允许程序在执行期间借助Reflection API取得任何类的内部消息，并能直接操作任意对象的内部属性及方法。加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称为：反射。</p>
<p><strong>优点</strong>：可以实现动态创建对象和编译，体现出很大的灵活性。</p>
<p><strong>缺点</strong>：对性能有影响，使用反射基本上是一种解析操作，我们可以告诉jvm，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p>
<h2 id="2、获取class类型对象"><a href="#2、获取class类型对象" class="headerlink" title="2、获取class类型对象"></a>2、获取class类型对象</h2><h3 id="2-1-java代码分析"><a href="#2-1-java代码分析" class="headerlink" title="2.1 java代码分析"></a>2.1 java代码分析</h3><p>java代码在计算机中经历有三个阶段。</p>
<p>第一阶段：源代码阶段。由程序员写的一个pojo类，假设为A，可以包含成员变量，构造方法，和成员方法。然后该类经过javac编译，生成了一个A.class的字节码文件。</p>
<p>第二阶段：class类对象阶段。这个阶段由类加载器ClassLoader加载得到一个class类的对象。该对象包含成员变量，构造方法以及成员方法。一个类只产生一个class对象。</p>
<p>第三阶段：运行时阶段。通过class类的这几个方法创建对象。反射的本质理解就是得到class对象后反向获取student对象的各种信息。</p>
<h2 id="2-2-如何得到class类对象"><a href="#2-2-如何得到class类对象" class="headerlink" title="2.2 如何得到class类对象"></a>2.2 如何得到class类对象</h2><p><strong>方式一：</strong> Object类的getClass（）方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">Class c = p.getClass();</span><br></pre></td></tr></table></figure>
<p><strong>方式二：</strong> 任何数据类型都有一个“静态”的class属性.</p>
<p>所有类型的class对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = Object.class;//对象</span><br><span class="line">        Class c2= Comparable.class;//接口</span><br><span class="line">        Class c3=String[].class;//数组</span><br><span class="line">        Class c4=int[][].class;//二维数组</span><br><span class="line">        Class c5=Override.class;//注解</span><br><span class="line">        Class c6=Integer.class;//基本数据类型</span><br><span class="line">        Class c7= ElementType.class;//枚举类型</span><br><span class="line">        Class c8=void.class;//空</span><br><span class="line">        Class c9=Class.class;//class</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.Object</span><br><span class="line">interface java.lang.Comparable</span><br><span class="line">class [Ljava.lang.String;</span><br><span class="line">class [[I</span><br><span class="line">interface java.lang.Override</span><br><span class="line">class java.lang.Integer</span><br><span class="line">class java.lang.annotation.ElementType</span><br><span class="line">void</span><br><span class="line">class java.lang.Class</span><br></pre></td></tr></table></figure>
<p><strong>方式三（常用）：</strong> 通过Class类的静态方法：forName（String  className）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c4 = Class.forName(&quot;com.xiaolei.Person&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="3、通过反射获取构造方法并使用"><a href="#3、通过反射获取构造方法并使用" class="headerlink" title="3、通过反射获取构造方法并使用"></a>3、通过反射获取构造方法并使用</h2><p>写个person类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    //定义三个成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    int age;</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Person(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age, String address) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个无参的方法</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;show!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带参的方法</span><br><span class="line">    public void method(String s) &#123;</span><br><span class="line">        System.out.println(&quot;method:&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带两个参数的方法</span><br><span class="line">    public String getString(String s,int i)&#123;</span><br><span class="line">        return s+&quot;---&quot;+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个私有的方法</span><br><span class="line">    private void function()&#123;</span><br><span class="line">        System.out.println(&quot;function !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写toStirng（）</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person[name=&quot;+name+&quot;,age=&quot;+age+&quot;,address=&quot;+address+&quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package fqy1;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1).批量的方法：</span><br><span class="line">   public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">   public Constructor[] getDeclaredConstructors()：</span><br><span class="line">   获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line"></span><br><span class="line">2).获取单个的方法，并调用：</span><br><span class="line">public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">获取指定单个的&quot;公有的&quot;构造方法：</span><br><span class="line">public Constructor getDeclaredConstructor(Class... parameterTypes):</span><br><span class="line">获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line">调用构造方法：</span><br><span class="line">      Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line">创建对象：</span><br><span class="line">      newInstance()</span><br><span class="line">      con.newInstance(“zhangsan&quot;, 20);</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //获取字节码文件对象</span><br><span class="line">        Class c1=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //第一：public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">        System.out.println(&quot;一、获取所有公有构造方法:&quot;);</span><br><span class="line">        Constructor[] cons = c1.getConstructors();</span><br><span class="line">        for(Constructor con:cons)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第二：public Constructor[] getDeclaredConstructors()：</span><br><span class="line">        //   获取所有的构造方法</span><br><span class="line">        System.out.println(&quot;二、获取所有的构造方法:&quot;);</span><br><span class="line">        Constructor[] cons2 =c1.getDeclaredConstructors();</span><br><span class="line">        for(Constructor con:cons2)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第三：public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">        //获取指定的单个“共有的”构造方法</span><br><span class="line">        //步骤：</span><br><span class="line">        //  A：首先创造字节码文件对象</span><br><span class="line">        //  B：通过字节码文件对象去创建构造器对象</span><br><span class="line">        //  C：通过构造器对象去创建一个实例对象</span><br><span class="line">        System.out.println(&quot;三、无参：获取指定的单个“共有的”构造方法:&quot;);</span><br><span class="line">        Constructor con3= c1.getConstructor(null);//返回的是构造方法对象</span><br><span class="line">        Object obj=con3.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        第四：需求：通过反射去获取该构造方法并使用</span><br><span class="line">        public person (String name,int age,String address)</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;四、通过反射去获取该构造方法并使用:&quot;);</span><br><span class="line">        Constructor con4=c1.getConstructor(String.class,int.class,String.class);</span><br><span class="line"></span><br><span class="line">        //通过带参构造方法对象创建对象</span><br><span class="line">        Object obj2=con4.newInstance(&quot;徐雷&quot;,18,&quot;武汉&quot;);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        需求：通过反射获取私有构造方法并使用</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;五、需求：通过反射获取私有构造方法并使用:&quot;);</span><br><span class="line">        Constructor con5=c1.getDeclaredConstructor(String.class);</span><br><span class="line">        //暴力访问</span><br><span class="line">        con5.setAccessible(true);</span><br><span class="line">         obj2=con5.newInstance(&quot;猫猫&quot;);//IllegalArgumentException:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、获取所有公有构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">二、获取所有的构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">fqy1.Person(java.lang.String,int)</span><br><span class="line">private fqy1.Person(java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">三、无参：获取指定的单个“共有的”构造方法:</span><br><span class="line">Person[name=null,age=0,address=null]</span><br><span class="line">四、通过反射去获取该构造方法并使用:</span><br><span class="line">Person[name=徐雷,age=18,address=武汉]</span><br><span class="line">五、需求：通过反射获取私有构造方法并使用:</span><br><span class="line">Person[name=猫猫,age=0,address=null]</span><br></pre></td></tr></table></figure>
<h2 id="4、通过反射获取成员变量并使用"><a href="#4、通过反射获取成员变量并使用" class="headerlink" title="4、通过反射获取成员变量并使用"></a>4、通过反射获取成员变量并使用</h2><p>1.获取所有成员：<br>     1).Field[] getFields():获取所有的”公有字段”<br>     2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</p>
<p>2.获取单个成员的：<br>     1).public Field getField(String fieldName):获取某个”公有的”字段；<br>     2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</p>
<p>3.修改成员的值：<br>         Field –&gt; public void set(Object obj,Object value):</p>
<p> 参数说明：<br>             1.obj:要设置的字段所在的对象；这个对象通过Constructor创建<br>             2.value:要为字段设置的值；</p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReflectDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c2=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //Field[] getFields():获取所有的&quot;公有字段&quot;</span><br><span class="line">        System.out.println(&quot;第一：获取所有公有成员变量：&quot;);</span><br><span class="line">        Field[] field=c2.getFields();</span><br><span class="line">        for(Field f:field)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有</span><br><span class="line">        System.out.println(&quot;第二：获取所有字段&quot;);</span><br><span class="line">        Field [] field2=c2.getDeclaredFields();</span><br><span class="line">        for(Field f:field2)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span><br><span class="line">        //Field --&gt; public void set(Object obj,Object value):</span><br><span class="line">        System.out.println(&quot;第三：获取某个公共字段并赋值：&quot;);</span><br><span class="line">        //通过无参构造方法创建对象</span><br><span class="line">        Constructor con =c2.getConstructor();</span><br><span class="line">        Object obj =con.newInstance();</span><br><span class="line">        Field field3=c2.getField(&quot;address&quot;);</span><br><span class="line">        field3.set(obj,&quot;武汉&quot;);//给object对象的f字段设置为”武汉“</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //获取name并对其赋值</span><br><span class="line">        System.out.println(&quot;第四：获取私有变量并赋值&quot;);</span><br><span class="line">        Field field4=c2.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        field4.setAccessible(true);</span><br><span class="line">        field4.set(obj,&quot;徐雷&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一：获取所有公有成员变量：</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第二：获取所有字段</span><br><span class="line">private java.lang.String fqy1.Person.name</span><br><span class="line">int fqy1.Person.age</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第三：获取某个公共字段并赋值：</span><br><span class="line">Person[name=null,age=0,address=武汉]</span><br><span class="line">第四：获取私有变量并赋值</span><br><span class="line">Person[name=徐雷,age=0,address=武汉]</span><br></pre></td></tr></table></figure>
<h2 id="5、通过反射获取成员方法并使用"><a href="#5、通过反射获取成员方法并使用" class="headerlink" title="5、通过反射获取成员方法并使用"></a>5、通过反射获取成员方法并使用</h2><h3 id="1-批量的："><a href="#1-批量的：" class="headerlink" title="1.批量的："></a>1.批量的：</h3><pre><code>public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）
public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</code></pre><h3 id="2-获取单个的："><a href="#2-获取单个的：" class="headerlink" title="2.获取单个的："></a>2.获取单个的：</h3><pre><code>public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):
            参数：
                 name : 方法名；
                Class ... : 形参的Class类型对象
public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code></pre><p> 【注】：第一个参数表示的是方法名，第二个参数表示的是方法的参数的class类型，这个方法返回值是Object接收，第一个参数表示对象是谁，第二参数表示调用该方法的实际参数。</p>
<h3 id="3-调用方法："><a href="#3-调用方法：" class="headerlink" title="3.调用方法："></a>3.调用方法：</h3><pre><code>Method --&gt; public Object invoke(Object obj,Object... args):
    参数说明：
    obj : 要调用方法的对象；
    args:调用方式时所传递的实参；</code></pre><p>测试成员方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">测试成员方法：</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //public Method[] getMethods():获取所有&quot;公有方法&quot;；</span><br><span class="line">        System.out.println(&quot;------第一：获取所有公有方法-------&quot;);</span><br><span class="line">        Method []m=c.getMethods();</span><br><span class="line">        for(Method method:m)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        //public Method[] getDeclaredMethods():</span><br><span class="line">        System.out.println(&quot;---------第二：获取所有方法--------&quot;);</span><br><span class="line">        Method[] m2=c.getDeclaredMethods();</span><br><span class="line">        for(Method method:m2)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor con=c.getConstructor();</span><br><span class="line">        Object obj=con.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------第三获取单个无参方法并使用----------&quot;);</span><br><span class="line">        //调用show方法</span><br><span class="line">        Method m1=c.getMethod(&quot;show&quot;);</span><br><span class="line">        //obj.m1();错误</span><br><span class="line">        //</span><br><span class="line">        m1.invoke(obj);//调用obj对象的m1方法</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第四，获取单个有参参数并使用-----------&quot;);</span><br><span class="line">        Method m3=c.getMethod(&quot;method&quot;, String.class);</span><br><span class="line">        m3.invoke(obj,&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第五，获取带多个参数的方法并使用-----&quot;);</span><br><span class="line">        Method m4=c.getMethod(&quot;getString&quot;, String.class, int.class);</span><br><span class="line">        Object objectString=m4.invoke(obj,&quot;徐雷&quot;,18);//返回object类型，记住！</span><br><span class="line">        System.out.println(objectString);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第六。获取私有的方法并使用----&quot;);</span><br><span class="line">        Method m5=c.getDeclaredMethod(&quot;function&quot;);</span><br><span class="line">        m5.setAccessible(true);</span><br><span class="line">        m5.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------第一：获取所有公有方法-------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">---------第二：获取所有方法--------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">private void fqy1.Person.function()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">--------第三获取单个无参方法并使用----------</span><br><span class="line">show!</span><br><span class="line">-----第四，获取单个有参参数并使用-----------</span><br><span class="line">method:hello</span><br><span class="line">-----第五，获取带多个参数的方法并使用-----</span><br><span class="line">徐雷---18</span><br><span class="line">-----第六。获取私</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【mybaits】：(3) 动态sql</title>
    <url>/2020/02/28/%E3%80%90Mybatis%E3%80%91%EF%BC%9A%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81sql/</url>
    <content><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>传统的使用JDBC的方法，相信大家在组合复杂的的SQL语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误。Mybatis的动态SQL功能正是为了解决这种问题， 其通过 if, choose, when, otherwise, trim, where, set, foreach标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率。</p>
<h3 id="2、动态标签"><a href="#2、动态标签" class="headerlink" title="2、动态标签"></a>2、动态标签</h3><h5 id="2-1-if"><a href="#2-1-if" class="headerlink" title="2.1 if"></a>2.1 if</h5><pre><code>- 例如，根据username和sex来查询数据。如果username为空，那么将只根据sex来查询；反之只根据username来查询。
- 首先不使用动态sql来书写</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot;</span><br><span class="line">        resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    &lt;!-- 这里和普通的sql 查询语句差不多，对于只有一个参数，后面的 #&#123;id&#125;表示占位符，里面不一定要写id,</span><br><span class="line">            写啥都可以，但是不要空着，如果有多个参数则必须写pojo类里面的属性 --&gt;</span><br><span class="line">    select * from user where username=#&#123;username&#125; and sex=#&#123;sex&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的查询语句，我们可以发现，如果#{username}为空，那么查询结构也是空，如何解决这个问题呢？使用if来判断</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    select * from user where</span><br><span class="line">        &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">           username=#&#123;username&#125;</span><br><span class="line">        &lt;/if&gt;      </span><br><span class="line">        &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">           and sex=#&#123;sex&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样写我们可以看到，如果 sex 等于 null，那么查询语句为 select * from user where username=#{username},但是如果usename 为空呢？那么查询语句为 select * from user where and sex=#{sex}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句。</li>
</ul>
<h5 id="2-2-where"><a href="#2-2-where" class="headerlink" title="2.2 where"></a>2.2 where</h5><ul>
<li><p>这个where标签会知道如果他包含的标签中有返回值的话，它就插入一个where。此外，如果标签返回的内容是and或or开头的，则它会剔除掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">           username=#&#123;username&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">         </span><br><span class="line">        &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">           and sex=#&#123;sex&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-if-set"><a href="#2-3-if-set" class="headerlink" title="2.3 if+set"></a>2.3 if+set</h5></li>
<li><p>同理，上面的对于查询SQL语句包含where关键字，如果在进行更新操作的时候，含有set关键字，我们怎么处理呢？</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span><br><span class="line">&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    update user u</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;</span><br><span class="line">                u.username = #&#123;username&#125;,</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;</span><br><span class="line">                u.sex = #&#123;sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">     </span><br><span class="line">     where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<p>这样写，</p>
<ul>
<li>如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex=? where id=?</li>
<li>如果第一个条件不为空，那么 sql 语句为：update user u set u.username = ? ,u.sex = ? where id=?</li>
</ul>
<h5 id="2-4-choose（when，otherwise）语句"><a href="#2-4-choose（when，otherwise）语句" class="headerlink" title="2.4 choose（when，otherwise）语句"></a>2.4 choose（when，otherwise）语句</h5><ul>
<li>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用choose标签可以解决此类问题，类似Java的switch语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByChoose&quot; resultType=&quot;com.ys.po.User&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">      select * from user</span><br><span class="line">      &lt;where&gt;</span><br><span class="line">          &lt;choose&gt;</span><br><span class="line">              &lt;when test=&quot;id !=&apos;&apos; and id != null&quot;&gt;</span><br><span class="line">                  id=#&#123;id&#125;</span><br><span class="line">              &lt;/when&gt;</span><br><span class="line">              &lt;when test=&quot;username !=&apos;&apos; and username != null&quot;&gt;</span><br><span class="line">                  and username=#&#123;username&#125;</span><br><span class="line">              &lt;/when&gt;</span><br><span class="line">              &lt;otherwise&gt;</span><br><span class="line">                  and sex=#&#123;sex&#125;</span><br><span class="line">              &lt;/otherwise&gt;</span><br><span class="line">          &lt;/choose&gt;</span><br><span class="line">      &lt;/where&gt;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>也就是说，这里我们有三个条件，id，username，sex，只能选择一个作为查询条件</li>
<li>如果id不为空，那么查询语句为：select * from user where  id=?</li>
<li>如果 id 为空，那么看username 是否为空，如果不为空，那么语句为 select * from user where  username=?;</li>
<li>如果 username 为空，那么查询语句为 select * from user where sex=?</li>
</ul>
<h5 id="2-5trim语句"><a href="#2-5trim语句" class="headerlink" title="2.5trim语句"></a>2.5trim语句</h5><ul>
<li>trim标记是一个格式化的标记，可以完成set或者是where标记的功能。</li>
<li>1、用trim改写上面第二点的if+where语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">        select * from user</span><br><span class="line">        &lt;!-- &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">               username=#&#123;username&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">             </span><br><span class="line">            &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">               and sex=#&#123;sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;  --&gt;</span><br><span class="line">        &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&gt;</span><br><span class="line">            &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">               and username=#&#123;username&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;sex != null&quot;&gt;</span><br><span class="line">               and sex=#&#123;sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/trim&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>prefix：前缀<br>prefixOverride：去掉第一个and或者是or</p>
<ul>
<li>2、用trim改写上面第三点的if+set语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span><br><span class="line">    &lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">        update user u</span><br><span class="line">            &lt;!-- &lt;set&gt;</span><br><span class="line">                &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;</span><br><span class="line">                    u.username = #&#123;username&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;</span><br><span class="line">                    u.sex = #&#123;sex&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/set&gt; --&gt;</span><br><span class="line">            &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">                &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;</span><br><span class="line">                    u.username = #&#123;username&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;</span><br><span class="line">                    u.sex = #&#123;sex&#125;,</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/trim&gt;</span><br><span class="line">         </span><br><span class="line">         where id=#&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>suffix：后缀　　</li>
<li>suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样）</li>
</ul>
<h5 id="2-6-sql片段"><a href="#2-6-sql片段" class="headerlink" title="2.6 sql片段"></a>2.6 sql片段</h5><ul>
<li>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</li>
<li>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义 sql 片段 --&gt;</span><br><span class="line">&lt;sql id=&quot;selectUserByUserNameAndSexSQL&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;</span><br><span class="line">        AND username = #&#123;username&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;</span><br><span class="line">        AND sex = #&#123;sex&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用sql片段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&gt;</span><br><span class="line">        &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;</span><br><span class="line">        &lt;include refid=&quot;selectUserByUserNameAndSexSQL&quot;&gt;&lt;/include&gt;</span><br><span class="line">        &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>【注意】：最好基于单表定义sql片段，提高片段的可重用性；在sql片段中最好不要包括where</li>
</ul>
<h5 id="2-7foreach语句"><a href="#2-7foreach语句" class="headerlink" title="2.7foreach语句"></a>2.7foreach语句</h5><ul>
<li>需求：我们需要查询user表id分为1,2,3的用户</li>
<li>sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where id=1 or id=2 or id=3</span><br><span class="line">　　　　　　 select * from user where id in (1,2,3)</span><br></pre></td></tr></table></figure>
<ol>
<li>建立一个UserVo类，里面封装一个List<integer>ids的属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ys.vo;</span><br><span class="line"> </span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class UserVo &#123;</span><br><span class="line">    //封装多个用户的id</span><br><span class="line">    private List&lt;Integer&gt; ids;</span><br><span class="line"> </span><br><span class="line">    public List&lt;Integer&gt; getIds() &#123;</span><br><span class="line">        return ids;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setIds(List&lt;Integer&gt; ids) &#123;</span><br><span class="line">        this.ids = ids;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>我们用 foreach 来改写 select * from user where id=1 or id=2 or id=3</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id=&quot;selectUserByListId&quot; parameterType=&quot;com.ys.vo.UserVo&quot; resultType=&quot;com.ys.po.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            collection:指定输入对象中的集合属性</span><br><span class="line">            item:每次遍历生成的对象</span><br><span class="line">            open:开始遍历时的拼接字符串</span><br><span class="line">            close:结束时拼接的字符串</span><br><span class="line">            separator:遍历对象之间需要拼接的字符串</span><br><span class="line">            select * from user where 1=1 and (id=1 or id=2 or id=3)</span><br><span class="line">          --&gt;</span><br><span class="line">        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            id=#&#123;id&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>==【注意】：在mapper文件中写sql语句时，遇到特殊字符时，如：&lt; 等，建议使用<![CDATA[ sql 语句 ]]>标记，将sql语句包裹住，不被解析器解析==</p>
<h3 id="3、项目sql实例"><a href="#3、项目sql实例" class="headerlink" title="3、项目sql实例"></a>3、项目sql实例</h3><ul>
<li>统计个数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;countSkillInfoTYB&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">    select count(tb.id)</span><br><span class="line">    from ss_user_skill_info_tyb tb</span><br><span class="line">    &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND|OR &quot;&gt;</span><br><span class="line">        &lt;if test=&quot;state !=null&quot;&gt;</span><br><span class="line">            and tb.state=#&#123;state&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into ss_skill_tag</span><br><span class="line">&lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;tagName != null&quot; &gt;</span><br><span class="line">        tag_name,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;url != null&quot; &gt;</span><br><span class="line">        url,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;sortNum != null&quot; &gt;</span><br><span class="line">        sort_num,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;status != null&quot; &gt;</span><br><span class="line">        status,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    add_date</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;content != null&quot; &gt;</span><br><span class="line">        #&#123;content&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;url != null&quot; &gt;</span><br><span class="line">        #&#123;url&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;sortNum != null&quot; &gt;</span><br><span class="line">        #&#123;sortNum&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;status != null&quot; &gt;</span><br><span class="line">        #&#123;status&#125;,</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    now()</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
