<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【java基础】：反射机制</title>
    <url>/2020/02/18/%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="java基础之反射"><a href="#java基础之反射" class="headerlink" title="java基础之反射"></a>java基础之反射</h1><ul>
<li><strong>1、反射概述</strong></li>
<li><strong>2、获取class类型的对象</strong></li>
<li><strong>3、通过反射获取构造方法并使用</strong></li>
<li><strong>4、通过反射获取成员变量并使用</strong></li>
<li><strong>5、通过反射并获取成员方法并使用</strong></li>
</ul>
<h2 id="1、反射概述"><a href="#1、反射概述" class="headerlink" title="1、反射概述"></a>1、反射概述</h2><p>&emsp;&emsp;java不是动态 语言，但java可以被称为准动态语言，因为它的反射机制。而这个反射机制是java被视为动态语言的关键。反射机制允许程序在执行期间借助Reflection API取得任何类的内部消息，并能直接操作任意对象的内部属性及方法。加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称为：反射。</p>
<p><strong>优点</strong>：可以实现动态创建对象和编译，体现出很大的灵活性。</p>
<p><strong>缺点</strong>：对性能有影响，使用反射基本上是一种解析操作，我们可以告诉jvm，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p>
<h2 id="2、获取class类型对象"><a href="#2、获取class类型对象" class="headerlink" title="2、获取class类型对象"></a>2、获取class类型对象</h2><h3 id="2-1-java代码分析"><a href="#2-1-java代码分析" class="headerlink" title="2.1 java代码分析"></a>2.1 java代码分析</h3><p>java代码在计算机中经历有三个阶段。</p>
<p>第一阶段：源代码阶段。由程序员写的一个pojo类，假设为A，可以包含成员变量，构造方法，和成员方法。然后该类经过javac编译，生成了一个A.class的字节码文件。</p>
<p>第二阶段：class类对象阶段。这个阶段由类加载器ClassLoader加载得到一个class类的对象。该对象包含成员变量，构造方法以及成员方法。一个类只产生一个class对象。</p>
<p>第三阶段：运行时阶段。通过class类的这几个方法创建对象。反射的本质理解就是得到class对象后反向获取student对象的各种信息。</p>
<h2 id="2-2-如何得到class类对象"><a href="#2-2-如何得到class类对象" class="headerlink" title="2.2 如何得到class类对象"></a>2.2 如何得到class类对象</h2><p><strong>方式一：</strong> Object类的getClass（）方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">Class c = p.getClass();</span><br></pre></td></tr></table></figure>
<p><strong>方式二：</strong> 任何数据类型都有一个“静态”的class属性.</p>
<p>所有类型的class对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = Object.class;//对象</span><br><span class="line">        Class c2= Comparable.class;//接口</span><br><span class="line">        Class c3=String[].class;//数组</span><br><span class="line">        Class c4=int[][].class;//二维数组</span><br><span class="line">        Class c5=Override.class;//注解</span><br><span class="line">        Class c6=Integer.class;//基本数据类型</span><br><span class="line">        Class c7= ElementType.class;//枚举类型</span><br><span class="line">        Class c8=void.class;//空</span><br><span class="line">        Class c9=Class.class;//class</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.Object</span><br><span class="line">interface java.lang.Comparable</span><br><span class="line">class [Ljava.lang.String;</span><br><span class="line">class [[I</span><br><span class="line">interface java.lang.Override</span><br><span class="line">class java.lang.Integer</span><br><span class="line">class java.lang.annotation.ElementType</span><br><span class="line">void</span><br><span class="line">class java.lang.Class</span><br></pre></td></tr></table></figure>
<p><strong>方式三（常用）：</strong> 通过Class类的静态方法：forName（String  className）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c4 = Class.forName(&quot;com.xiaolei.Person&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="3、通过反射获取构造方法并使用"><a href="#3、通过反射获取构造方法并使用" class="headerlink" title="3、通过反射获取构造方法并使用"></a>3、通过反射获取构造方法并使用</h2><p>写个person类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    //定义三个成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    int age;</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Person(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age, String address) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个无参的方法</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;show!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带参的方法</span><br><span class="line">    public void method(String s) &#123;</span><br><span class="line">        System.out.println(&quot;method:&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带两个参数的方法</span><br><span class="line">    public String getString(String s,int i)&#123;</span><br><span class="line">        return s+&quot;---&quot;+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个私有的方法</span><br><span class="line">    private void function()&#123;</span><br><span class="line">        System.out.println(&quot;function !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写toStirng（）</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person[name=&quot;+name+&quot;,age=&quot;+age+&quot;,address=&quot;+address+&quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package fqy1;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1).批量的方法：</span><br><span class="line">   public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">   public Constructor[] getDeclaredConstructors()：</span><br><span class="line">   获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line"></span><br><span class="line">2).获取单个的方法，并调用：</span><br><span class="line">public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">获取指定单个的&quot;公有的&quot;构造方法：</span><br><span class="line">public Constructor getDeclaredConstructor(Class... parameterTypes):</span><br><span class="line">获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line">调用构造方法：</span><br><span class="line">      Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line">创建对象：</span><br><span class="line">      newInstance()</span><br><span class="line">      con.newInstance(“zhangsan&quot;, 20);</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //获取字节码文件对象</span><br><span class="line">        Class c1=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //第一：public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">        System.out.println(&quot;一、获取所有公有构造方法:&quot;);</span><br><span class="line">        Constructor[] cons = c1.getConstructors();</span><br><span class="line">        for(Constructor con:cons)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第二：public Constructor[] getDeclaredConstructors()：</span><br><span class="line">        //   获取所有的构造方法</span><br><span class="line">        System.out.println(&quot;二、获取所有的构造方法:&quot;);</span><br><span class="line">        Constructor[] cons2 =c1.getDeclaredConstructors();</span><br><span class="line">        for(Constructor con:cons2)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第三：public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">        //获取指定的单个“共有的”构造方法</span><br><span class="line">        //步骤：</span><br><span class="line">        //  A：首先创造字节码文件对象</span><br><span class="line">        //  B：通过字节码文件对象去创建构造器对象</span><br><span class="line">        //  C：通过构造器对象去创建一个实例对象</span><br><span class="line">        System.out.println(&quot;三、无参：获取指定的单个“共有的”构造方法:&quot;);</span><br><span class="line">        Constructor con3= c1.getConstructor(null);//返回的是构造方法对象</span><br><span class="line">        Object obj=con3.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        第四：需求：通过反射去获取该构造方法并使用</span><br><span class="line">        public person (String name,int age,String address)</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;四、通过反射去获取该构造方法并使用:&quot;);</span><br><span class="line">        Constructor con4=c1.getConstructor(String.class,int.class,String.class);</span><br><span class="line"></span><br><span class="line">        //通过带参构造方法对象创建对象</span><br><span class="line">        Object obj2=con4.newInstance(&quot;徐雷&quot;,18,&quot;武汉&quot;);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        需求：通过反射获取私有构造方法并使用</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;五、需求：通过反射获取私有构造方法并使用:&quot;);</span><br><span class="line">        Constructor con5=c1.getDeclaredConstructor(String.class);</span><br><span class="line">        //暴力访问</span><br><span class="line">        con5.setAccessible(true);</span><br><span class="line">         obj2=con5.newInstance(&quot;猫猫&quot;);//IllegalArgumentException:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、获取所有公有构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">二、获取所有的构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">fqy1.Person(java.lang.String,int)</span><br><span class="line">private fqy1.Person(java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">三、无参：获取指定的单个“共有的”构造方法:</span><br><span class="line">Person[name=null,age=0,address=null]</span><br><span class="line">四、通过反射去获取该构造方法并使用:</span><br><span class="line">Person[name=徐雷,age=18,address=武汉]</span><br><span class="line">五、需求：通过反射获取私有构造方法并使用:</span><br><span class="line">Person[name=猫猫,age=0,address=null]</span><br></pre></td></tr></table></figure>
<h2 id="4、通过反射获取成员变量并使用"><a href="#4、通过反射获取成员变量并使用" class="headerlink" title="4、通过反射获取成员变量并使用"></a>4、通过反射获取成员变量并使用</h2><p>1.获取所有成员：<br>     1).Field[] getFields():获取所有的”公有字段”<br>     2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</p>
<p>2.获取单个成员的：<br>     1).public Field getField(String fieldName):获取某个”公有的”字段；<br>     2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</p>
<p>3.修改成员的值：<br>         Field –&gt; public void set(Object obj,Object value):</p>
<p> 参数说明：<br>             1.obj:要设置的字段所在的对象；这个对象通过Constructor创建<br>             2.value:要为字段设置的值；</p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReflectDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c2=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //Field[] getFields():获取所有的&quot;公有字段&quot;</span><br><span class="line">        System.out.println(&quot;第一：获取所有公有成员变量：&quot;);</span><br><span class="line">        Field[] field=c2.getFields();</span><br><span class="line">        for(Field f:field)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有</span><br><span class="line">        System.out.println(&quot;第二：获取所有字段&quot;);</span><br><span class="line">        Field [] field2=c2.getDeclaredFields();</span><br><span class="line">        for(Field f:field2)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span><br><span class="line">        //Field --&gt; public void set(Object obj,Object value):</span><br><span class="line">        System.out.println(&quot;第三：获取某个公共字段并赋值：&quot;);</span><br><span class="line">        //通过无参构造方法创建对象</span><br><span class="line">        Constructor con =c2.getConstructor();</span><br><span class="line">        Object obj =con.newInstance();</span><br><span class="line">        Field field3=c2.getField(&quot;address&quot;);</span><br><span class="line">        field3.set(obj,&quot;武汉&quot;);//给object对象的f字段设置为”武汉“</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //获取name并对其赋值</span><br><span class="line">        System.out.println(&quot;第四：获取私有变量并赋值&quot;);</span><br><span class="line">        Field field4=c2.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        field4.setAccessible(true);</span><br><span class="line">        field4.set(obj,&quot;徐雷&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一：获取所有公有成员变量：</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第二：获取所有字段</span><br><span class="line">private java.lang.String fqy1.Person.name</span><br><span class="line">int fqy1.Person.age</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第三：获取某个公共字段并赋值：</span><br><span class="line">Person[name=null,age=0,address=武汉]</span><br><span class="line">第四：获取私有变量并赋值</span><br><span class="line">Person[name=徐雷,age=0,address=武汉]</span><br></pre></td></tr></table></figure>
<h2 id="5、通过反射获取成员方法并使用"><a href="#5、通过反射获取成员方法并使用" class="headerlink" title="5、通过反射获取成员方法并使用"></a>5、通过反射获取成员方法并使用</h2><h3 id="1-批量的："><a href="#1-批量的：" class="headerlink" title="1.批量的："></a>1.批量的：</h3><pre><code>public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）
public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</code></pre><h3 id="2-获取单个的："><a href="#2-获取单个的：" class="headerlink" title="2.获取单个的："></a>2.获取单个的：</h3><pre><code>public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):
            参数：
                 name : 方法名；
                Class ... : 形参的Class类型对象
public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code></pre><p> 【注】：第一个参数表示的是方法名，第二个参数表示的是方法的参数的class类型，这个方法返回值是Object接收，第一个参数表示对象是谁，第二参数表示调用该方法的实际参数。</p>
<h3 id="3-调用方法："><a href="#3-调用方法：" class="headerlink" title="3.调用方法："></a>3.调用方法：</h3><pre><code>Method --&gt; public Object invoke(Object obj,Object... args):
    参数说明：
    obj : 要调用方法的对象；
    args:调用方式时所传递的实参；</code></pre><p>测试成员方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">测试成员方法：</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //public Method[] getMethods():获取所有&quot;公有方法&quot;；</span><br><span class="line">        System.out.println(&quot;------第一：获取所有公有方法-------&quot;);</span><br><span class="line">        Method []m=c.getMethods();</span><br><span class="line">        for(Method method:m)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        //public Method[] getDeclaredMethods():</span><br><span class="line">        System.out.println(&quot;---------第二：获取所有方法--------&quot;);</span><br><span class="line">        Method[] m2=c.getDeclaredMethods();</span><br><span class="line">        for(Method method:m2)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor con=c.getConstructor();</span><br><span class="line">        Object obj=con.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------第三获取单个无参方法并使用----------&quot;);</span><br><span class="line">        //调用show方法</span><br><span class="line">        Method m1=c.getMethod(&quot;show&quot;);</span><br><span class="line">        //obj.m1();错误</span><br><span class="line">        //</span><br><span class="line">        m1.invoke(obj);//调用obj对象的m1方法</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第四，获取单个有参参数并使用-----------&quot;);</span><br><span class="line">        Method m3=c.getMethod(&quot;method&quot;, String.class);</span><br><span class="line">        m3.invoke(obj,&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第五，获取带多个参数的方法并使用-----&quot;);</span><br><span class="line">        Method m4=c.getMethod(&quot;getString&quot;, String.class, int.class);</span><br><span class="line">        Object objectString=m4.invoke(obj,&quot;徐雷&quot;,18);//返回object类型，记住！</span><br><span class="line">        System.out.println(objectString);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第六。获取私有的方法并使用----&quot;);</span><br><span class="line">        Method m5=c.getDeclaredMethod(&quot;function&quot;);</span><br><span class="line">        m5.setAccessible(true);</span><br><span class="line">        m5.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------第一：获取所有公有方法-------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">---------第二：获取所有方法--------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">private void fqy1.Person.function()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">--------第三获取单个无参方法并使用----------</span><br><span class="line">show!</span><br><span class="line">-----第四，获取单个有参参数并使用-----------</span><br><span class="line">method:hello</span><br><span class="line">-----第五，获取带多个参数的方法并使用-----</span><br><span class="line">徐雷---18</span><br><span class="line">-----第六。获取私</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作】：入职前的一些规划</title>
    <url>/2019/11/18/%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91%EF%BC%9A%E5%85%A5%E8%81%8C%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%92%E5%92%8C%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[## 一、前言

<p>&emsp;&emsp;未来不可知，上海的职业生涯将正式开始，花自缤纷花自谢，时间太紧了，拼不了爹的自己只能拼命去学习。万一实现了呢？ </p>
<h2 id="二、未来计划（2019-11-2021-9）"><a href="#二、未来计划（2019-11-2021-9）" class="headerlink" title="二、未来计划（2019.11-2021.9）"></a>二、未来计划（2019.11-2021.9）</h2><p>&emsp;&emsp;我希望在这近两年的时间内，竭尽全力的提升自己，努力往（三初一高）的方向发展：    </p>
<ul>
<li><strong>高级的Java开发</strong>；</li>
<li><strong>初级的大数据学习者</strong>；</li>
<li><strong>初级的人工智能学习者</strong>；</li>
<li><strong>初级的vr学习者</strong>；</li>
</ul>
<h2 id="三、着手当下"><a href="#三、着手当下" class="headerlink" title="三、着手当下"></a>三、着手当下</h2><ol>
<li>融入公司，跟上工作节奏。</li>
<li>学习不再片面，有条理的规划出一块内容深入学习</li>
<li>每周抽出20个小时的时间学习新知识。</li>
<li>不打游戏。</li>
<li>开始阅读书籍，书单已经选好。</li>
<li>开始慢慢的理财，关注房价和理财的事儿。</li>
<li>待更。。。</li>
</ol>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【潇雷】：风雨求职路</title>
    <url>/2019/11/14/%E3%80%90%E6%B1%82%E8%81%8C%E3%80%91%E9%82%A3%E4%BA%9B%E5%BF%83%E9%85%B8%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>一转眼，来上海就两个半月了，由夏至秋，天气转凉。  如今找工作的事情终于尘埃入定。  应届生社招时的碰壁让我深受打击，不仅投过实习的岗位，也频频报低价格卑微地换取一份糊口的工作，最后，还是没有放弃，总有适合你的工作在等待你。熬一熬，就过去了。</p>
<h1 id="2-求职"><a href="#2-求职" class="headerlink" title="2.求职"></a>2.求职</h1><h2 id="2-1-简历"><a href="#2-1-简历" class="headerlink" title="2.1 简历"></a>2.1 简历</h2><p>面了一个月，boss沟通八百多家，拉钩5年以下全投过，换来的是寥寥无几的面试机会，从刚开始投简历到找到工作的前两天还改些简历中的小毛病，慢慢的，我发现越到后面，我这简历竟然也能入的了一些大中厂的眼，虽然写的一年工作经验，虽然念的是普通二本非科班，这些特征在浩浩荡荡的简历海洋中本就该沉入海底的，我回头想想，除了那些项目，专业技能外，还有两点：第一是我把本科的CPA专业排名第二写上去了，还有一些奖学金，数学竞赛奖，这些起码能说明我在大学还是学了点东西的。第二是我添加了自己的个人博客和微信公众号，虽然不知道他们会不会看，虽然csdn很low，文章也不多，但是看着还是很努力的。所以个人博客的重要性在面试的时候还是挺加分的。因此，在往后的学习工作中，我将以博客的形式来记录自己的学习和生活。</p>
<h2 id="2-2-面试"><a href="#2-2-面试" class="headerlink" title="2.2 面试"></a>2.2 面试</h2><p><strong>第一家:</strong> 去了个培训机构，叫一堆的人去面试，做了几道nc逻辑题，结果全给做错了，连培训机构都不想要我，hhhh，服了，现在培训机构也挑人了吗？<br><strong>第二家:</strong> 是一个医疗相关的，面试很紧张，终于来了次正经的技术面，下面是面试题  </p>
<p><strong>1.两个linux之间相互传文件怎么做？</strong><br>答：可以使用SCP命令。  </p>
<p><strong>2.mysql查询前十条数据怎么做？</strong><br>select * from emp LIMIT 0,10  </p>
<p><strong>3.js怎么定义数组？</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种  </span><br><span class="line">            var arr = new Array();  </span><br><span class="line">            arr[0] = 123  </span><br><span class="line">            arr[1] = &quot;abc&quot;;  </span><br><span class="line">            arr[5] = false;  </span><br><span class="line">            alert(arr[3]);//undefined  </span><br><span class="line">            alert(arr);//123,abc,,,,false  </span><br><span class="line">            alert(arr[10]);//undefined，不会出现越界异常  </span><br><span class="line">            </span><br><span class="line">            //for in 遍历，未定义的不遍历</span><br><span class="line">            for(var i in arr)&#123;</span><br><span class="line">                alert(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">            //第二种  </span><br><span class="line">            var arr2 = new Array(2);//规定了数组的长度为2  </span><br><span class="line">            arr2[0] = &quot;ddd&quot;;  </span><br><span class="line">            arr2[1] = &quot;www&quot;;  </span><br><span class="line">            alert(arr2);//ddd,www  </span><br><span class="line">            arr2[2] = &quot;fff&quot;;//可以再次添加元素，定义的数组大小对此没有影响  </span><br><span class="line">            alert(arr2);//ddd,www,fff  </span><br><span class="line">                 </span><br><span class="line">            //第三种  </span><br><span class="line">            var arr3 = new Array(true,123,false);  </span><br><span class="line">            alert(arr3);//true,123,false  </span><br><span class="line">              </span><br><span class="line">            //第四种,推荐使用  </span><br><span class="line">            var arr4 = [false,&quot;aaa&quot;,123];  </span><br><span class="line">            alert(arr4);//false,aaa,123</span><br></pre></td></tr></table></figure>
<p><strong>4.vue的条件判断的指令？</strong><br> v-if指令。  </p>
<p><strong>5.git是干嘛的？（版本控制系统）</strong>  </p>
<p><strong>6.java的空指针怎么发生的？口述两行代码，一定会发生空指针？</strong><br>当一个对象不存在时，又调用它的话就会产生空指针异常。<br>object o=null；<br>o.tostring();</p>
<p><strong>7.java的数组越界是怎样的？像ArrayList这种自动增长的，它有没有可能发生越界？为什么？</strong><br>因为arrayList是线程不安全的类，当出现多个线程同时添加元素的时候，此时arrayList就会可能会出现数组越界的问题。  </p>
<p><strong>8.java的自定义注解是怎么解析的？（反射，加载成.class字节码文件）</strong>  </p>
<p><strong>9.定义一个简单的java类，这个类要使它能够表达简单的树形结构，那么这个类的关键特征是什么？</strong><br>就是有两个成员变量，类型是自己，分别指向左子树和右子树（以二叉树为例）。  </p>
<p>中间还问了点单词数学，应该是比较缺人，然后虽然我面试的很差，很多答不上来，但是过了几天还是给我发offer，只不过面试的时候就说就面试来看，我只值6k，我也同意它的说法，但是还是想多面几家试试，就拒绝了，没想到后面才正式开始了苦逼之路。</p>
<p><strong>第三家:</strong> 是一个50人左右的公司，做笔试题的时候，发现难度简直升级，结果笔试题都写不下去，就灰溜溜的回去了，下面是部分笔试题：<br>1.1万个人抢100个红包，如何保证2个人不能抢到同一个红包？<br>2.Git如何放弃工作区的更改？<br>3.写一个方法，处理接收POST类型的JSON参数的请求（参数为name，age）<br>4.POST请求是否可以是url？a=b&amp;c=d的形式请求？如何不可以请说出理由<br>5.设计一个对外服务的接口实现类，在1，2，3这三台主机上（有不同的IP地址）实现负载均衡和顺序轮询机制<br>6.@Scheduled是否为多线程执行，如果是请说明理由，否则请给出解决方案；<br>7.通过Nginx实现：访问<a href="http://test.ab.com，代理请求到http://101.101.1.1.9/" target="_blank" rel="noopener">http://test.ab.com，代理请求到http://101.101.1.1.9/</a><br>8.以JAR包的方式部署temp.jar，请写出部署命令，以及查看Java进程，结束进程</p>
<p><strong>第四家：</strong> 自第三家受打击之后就停下来复习了一周，当时也感觉面试好多，才没投几家就去面试了，所以当时想不把一些机会白白浪费掉，尽管如此，现在想来这种做法特别不好，不能停这么久，而且自己学真的学不到那么多，还是少约点面试，保持两天内一个面试放慢节奏还是比较好的。这家面了一个实习，在上海的团队就他一个人，想想就优点怕，它也看出来我心里的担心，最后可能倒在了沟通问题，以及非全日制，和技术回答的比较死板，考虑问题没有挖很深，很多都是直接从面经上看来，比如hashtable为什么不能为null？  </p>
<p><strong>第五家:</strong> 这次去的是一个岗位上技能啥都不要求的公司，会c，python，java就可以，我以为可能又是骗子公司，没想到公司也没想象中那么小，然后填完信息领到面试官那里，让我上机，实现一个在一个64*64的棋盘上，找出他给的100个点里的最短路径，然后让我开始写，我慢慢的脑子陷入了，感觉到现在都没理解好提议，它给的100个点如何输入到电脑里，一个二维数组，怎么接收这些点，然后算法用迪杰斯特拉算法怎么实现？虽然考研的时候做过这种算法找最短路径的点，但是要真让我实现，还真狠有难度，最后不来了之，自此又陷入自闭。 </p>
<p><strong>第六家，第七家：</strong>  上海无果，开始换城市，突发的选了嘉兴，去嘉兴，嘉善分别面了两家，第一家，做金融还要出差，感觉也不是想招人的意思，随便问的一些aop，springboot热部署等问题，最后我还是因为技术没过关被刷了，然后赶去嘉善面试，这个初创公司感觉面试官的他的三年经验很有水分，随便聊聊项目就过了，基础也没问，后面给我开了8k，最后犹豫再三还是拒了，初创公司不敢去，更别提没个大牛的初创公司。  </p>
<p><strong>第八家：</strong>  开始转战上海，一个金融相关的，我面试的感觉还不错，也感觉有希望进，但是最后不知道什么原因被刷了，这家我还是挺想去的。至少工作还是挺成熟的。 </p>
<p><strong>第九家：</strong> 做智能健身相关的，面试官技术很强，阿里出来的年轻小伙，但是给我的感觉是有点轻蔑，可能这就是牛人吧，最后我都报到6k了，但是我感觉那岗位学的东西也不多，不是纯java开发的。</p>
<p><strong>第十家：</strong> 转眼又过了一周，这家去了轻轻家教，面的问题很灵活，数据结构的知识我真的忘了很多，但是面试官人很好，跟我聊了挺久的。不过自己还是太菜了，我只想说面试还是很看重运气和那岗位的缺人程度的，最后惨败吧。 </p>
<p><strong>第十一家：</strong> 又跑了很远的地方去面试，一个挂羊头卖狗头的，应该是猎头公司，收集了很多面试人的信息资料，随便聊聊就不面了。也没抱希望。  </p>
<p><strong>第十二家：</strong> 这家是挺正规的，离我住处最近的一家了，走路十分钟就到了，面试之前看到这家岗位已经关闭了，面试官是一个很年轻的，这种年轻没多少面试经验的面试官会故意问的比较深，来展示他的能力，根本不从实际情况来面，我就一年的实习经验，把我当几年的面，还问我有没有带过人？也问了一些假大空的问题，消息堆积，重复消费，服务挂了怎么看等等，然后一个小时的面试，直接说，今天的面试到此结束。我就灰溜溜的回去了，不想要我干嘛浪费两个人的时间。</p>
<p><strong>第十三家：</strong> 这次是最后一次面试了，公司环境不错，成立八年的互联网公司，也有自己的产品，面积也很大，然后经过两轮的技术面试和一轮的hr小姐姐沟通后，终于以自己的实力和运气终于拿到了offer，这虽然不是最好的公司，但是这是现阶段最适合我的公司，面试总结的问题就是提升自己的沟通能力，很多东西，你得学会用自己的话来很精准的描述它，这种能力也是需要锻炼出来的，我在回复它邮件的时候，写了未来我们一起加油。  </p>
<h2 id="3感慨"><a href="#3感慨" class="headerlink" title="3感慨"></a>3感慨</h2><p>这一个多月我经历了什么？我得到了什么？<br>我的生活才刚刚开始，未来可期。<br>记两首诗：</p>
<p><strong>《夜》</strong><br>晚风拂我意，<br>荧屏对相思。<br>奔波十里外，<br>另觅橄榄枝。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/850b262531a3b749e927b27f1b28805.jpg" alt="image"></p>
<p><strong>《光》</strong><br>九月憧憬，新奇欲试笔与刀。<br>十月无闻，无花树下羞与闹。<br>十一过半，滩里霓虹光与照。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/f8e7a632c8e60cd0d9deb53f2ffd247.jpg" alt="image"></p>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>潇雷哥哥的第一篇博客</title>
    <url>/2019/11/11/%E6%BD%87%E9%9B%B7%E5%93%A5%E5%93%A5%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[# 潇雷

<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul>
<li>列表1</li>
<li>列表2<br>  a 字列表<br>  b 字列表<br>top: 100 数值越大越靠前<br><a href="https://lixiaoyu.cc/" target="_blank" rel="noopener">啸宇的博客</a><br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/00c1963b1cff4855bf4b72a84f2e0249" alt="我的头像"><br><em>字体是倾斜的</em><br>#字体也能加粗#</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is a block</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
