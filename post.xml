<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Spring】：（6）AOP</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%886%EF%BC%89AOP/</url>
    <content><![CDATA[<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><ul>
<li>面向切面编程，是一种通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。是函数式编程的一种衍生范型，利用AOP可以对业务逻辑的各个部分进行隔离，实现各部分之间的解耦。<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1595583263.png" alt="image"></li>
</ul>
<h3 id="2、AOP在Spring中的作用"><a href="#2、AOP在Spring中的作用" class="headerlink" title="2、AOP在Spring中的作用"></a>2、AOP在Spring中的作用</h3><p><strong>==提供声明式事务：允许用户自定义切面==</strong></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。就是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…</li>
<li>切面（ASPECT）：横切关注点，被模块化的特殊对象，它是一个类</li>
<li>通知（Advice）：切面必须要完成的工作。它是类中的一个方法</li>
<li>目标（Target）：被通知对象</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象</li>
<li>切入点（PointCut）：切面通知 执行的地点的定义</li>
<li>连接点（jointPoint）：与切入点匹配的执行点</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/142667477.png" alt="image"></p>
<h3 id="3、使用Spring实现AOP"><a href="#3、使用Spring实现AOP" class="headerlink" title="3、使用Spring实现AOP"></a>3、使用Spring实现AOP</h3><h5 id="3-1-通过Spring-API实现"><a href="#3-1-通过Spring-API实现" class="headerlink" title="3.1 通过Spring API实现"></a>3.1 通过Spring API实现</h5><ul>
<li>首先编写我们的业务接口和实现类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add();</span><br><span class="line"></span><br><span class="line">    public void delete();</span><br><span class="line"></span><br><span class="line">    public void update();</span><br><span class="line"></span><br><span class="line">    public void search();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;增加用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        System.out.println(&quot;删除用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;更新用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void search() &#123;</span><br><span class="line">        System.out.println(&quot;查询用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后去写我们的增强类，一个前置增强，一个后置增强。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Log implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">    //method : 要执行的目标对象的方法</span><br><span class="line">    //objects : 被调用的方法的参数</span><br><span class="line">    //Object : 目标对象</span><br><span class="line">    @Override</span><br><span class="line">    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">        System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AfterLog implements AfterReturningAdvice &#123;</span><br><span class="line">    //returnValue 返回值</span><br><span class="line">    //method被调用的方法</span><br><span class="line">    //args 被调用的方法的对象的参数</span><br><span class="line">    //target 被调用的目标对象</span><br><span class="line">    @Override</span><br><span class="line">    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行了&quot; + target.getClass().getName()</span><br><span class="line">        +&quot;的&quot;+method.getName()+&quot;方法,&quot;</span><br><span class="line">        +&quot;返回值：&quot;+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后去spring的文件中注册，并实现aop切入实现，注意导入约束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册bean--&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--aop的配置--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--切入点  expression:表达式匹配要执行的方法--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">        &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.search();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</li>
</ul>
<h5 id="3-2-自定义类来实现AOP"><a href="#3-2-自定义类来实现AOP" class="headerlink" title="3.2 自定义类来实现AOP"></a>3.2 自定义类来实现AOP</h5><ul>
<li>第一步：写我们自己的一个切入类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DiyPointcut &#123;</span><br><span class="line"></span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>去spring配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="line">&lt;!--注册bean--&gt;</span><br><span class="line">&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--aop的配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;diy&quot;&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;</span><br><span class="line">        &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-使用注解实现"><a href="#3-3-使用注解实现" class="headerlink" title="3.3 使用注解实现"></a>3.3 使用注解实现</h5><ul>
<li>编写注解实现的增强类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class AnnotationPointcut &#123;</span><br><span class="line">    @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行前---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;---------方法执行后---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br><span class="line">    public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;环绕前&quot;);</span><br><span class="line">        System.out.println(&quot;签名:&quot;+jp.getSignature());</span><br><span class="line">        //执行目标方法proceed</span><br><span class="line">        Object proceed = jp.proceed();</span><br><span class="line">        System.out.println(&quot;环绕后&quot;);</span><br><span class="line">        System.out.println(proceed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：在spring配置文件中，注册bean，并增加支持注解的配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="line">&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>
<p>op:aspectj-autoproxy：说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 </span><br><span class="line"></span><br><span class="line">&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>【Spring】：（5）：Bean的自动装配</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%885%EF%BC%89%EF%BC%9ABean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h3 id="1、Bean的自动装配"><a href="#1、Bean的自动装配" class="headerlink" title="1、Bean的自动装配"></a>1、Bean的自动装配</h3><ul>
<li>自动装配是Spring满足bean依赖的一种方式！</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在spring中有三种装配的方式：</p>
<ul>
<li>在xml中显示的配置</li>
<li>在java中显示配置</li>
<li>隐式的自动装配【重要】</li>
</ul>
<h3 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h3><p>环境搭建：一个人有两个宠物。</p>
<h3 id="3、自动装配"><a href="#3、自动装配" class="headerlink" title="3、自动装配"></a>3、自动装配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;cat&quot; class=&quot;xiaolei.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;xiaolei.pojo.Dog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">byname:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id,如果相同，则自动装配</span><br><span class="line">byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;people&quot; class=&quot;xiaolei.pojo.People&quot; autowire=&quot;byName&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>【小结】：</p>
<ul>
<li>byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致。</li>
<li>bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。</li>
</ul>
<h3 id="4、使用注解自动装配"><a href="#4、使用注解自动装配" class="headerlink" title="4、使用注解自动装配"></a>4、使用注解自动装配</h3><p>要使用注解须知：<br>1、导入约束：content约束<br>2、配置注解的支持：==<strong><a href="context:annotation-config" target="_blank" rel="noopener">context:annotation-config</a></strong>==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean definitions here --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.cskaoyan&quot;&gt;   &lt;/context:component-scan&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><ul>
<li>@Autowired 是按类型自动装配的，不支持id匹配。</li>
<li>需要导入Spring-aop的包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//如果允许对象为null，设置required = false,默认为true</span><br><span class="line">@Autowired(required = false)</span><br><span class="line">private Cat cat;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用</li>
</ul>
<p>测试：</p>
<ul>
<li>1.配置文件修改内容，保证类型存在对象，且名字不为类的默认名字！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.没有加Qualifier测试，直接报错。</li>
<li>3.在属性上添加Qualifier注解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;cat2&quot;)</span><br><span class="line">private Cat cat;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;dog2&quot;)</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、成功输出</li>
</ul>
<h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【Spring】：（4）Spring Bean 的生命周期</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%884%EF%BC%89Spring%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="1、Bean的完整生命周期"><a href="#1、Bean的完整生命周期" class="headerlink" title="1、Bean的完整生命周期"></a>1、Bean的完整生命周期</h3><ul>
<li>在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean 的实例化，然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。</li>
<li>相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强，下面展示了一个Bean的构造过程</li>
</ul>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java0-1558500658.jpg" alt="image"></p>
<p>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</p>
<p> 1、实例化一个Bean－－也就是我们常说的new；</p>
<p> 2、按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；</p>
<p> 3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值</p>
<p> 4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</p>
<p> 5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</p>
<p> 6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</p>
<p> 7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p>
<p> 8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；</p>
<p>  注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</p>
<p> 9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；</p>
<p> 10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p>
<h3 id="2、各种接口方法分类"><a href="#2、各种接口方法分类" class="headerlink" title="2、各种接口方法分类"></a>2、各种接口方法分类</h3><ul>
<li>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：<ul>
<li>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</li>
<li>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</li>
<li>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li>
<li>工厂后处理器接口方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【Spring】：（3）依赖注入</title>
    <url>/2020/02/27/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%883%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="1、依赖注入"><a href="#1、依赖注入" class="headerlink" title="1、依赖注入"></a>1、依赖注入</h3><ul>
<li>依赖：指Bean对象的创建依赖于容器，Bean对象的依赖资源。</li>
<li>注入：指Bean对象所依赖的资源，由容器来设置和装配。</li>
<li>依赖注入分为：构造器注入、setter注入（重点）、拓展注入实现。</li>
</ul>
<h3 id="2、构造器注入"><a href="#2、构造器注入" class="headerlink" title="2、构造器注入"></a>2、构造器注入</h3><ul>
<li>有参构造和无参构造。</li>
</ul>
<h3 id="3、setter注入"><a href="#3、setter注入" class="headerlink" title="3、setter注入"></a>3、setter注入</h3><p>【环境搭建】：</p>
<ul>
<li>两个pojo类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    //1、基本类型</span><br><span class="line">    private String name;</span><br><span class="line">    //2、引用类型</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] books;</span><br><span class="line">    private List&lt;String&gt; hobbies;</span><br><span class="line">    private Map&lt;String,String&gt; card;</span><br><span class="line">    private Set&lt;String&gt; games;</span><br><span class="line">    private String wife;</span><br><span class="line">    private Properties info;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(Address address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getBooks() &#123;</span><br><span class="line">        return books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBooks(String[] books) &#123;</span><br><span class="line">        this.books = books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getHobbies() &#123;</span><br><span class="line">        return hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHobbies(List&lt;String&gt; hobbies) &#123;</span><br><span class="line">        this.hobbies = hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, String&gt; getCard() &#123;</span><br><span class="line">        return card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCard(Map&lt;String, String&gt; card) &#123;</span><br><span class="line">        this.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; getGames() &#123;</span><br><span class="line">        return games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGames(Set&lt;String&gt; games) &#123;</span><br><span class="line">        this.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getWife() &#123;</span><br><span class="line">        return wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWife(String wife) &#123;</span><br><span class="line">        this.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Properties getInfo() &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInfo(Properties info) &#123;</span><br><span class="line">        this.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, address=&quot; + address.toString() +</span><br><span class="line">                &quot;, books=&quot; + Arrays.toString(books) +</span><br><span class="line">                &quot;, hobbies=&quot; + hobbies +</span><br><span class="line">                &quot;, card=&quot; + card +</span><br><span class="line">                &quot;, games=&quot; + games +</span><br><span class="line">                &quot;, wife=&apos;&quot; + wife + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, info=&quot; + info +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address&#123;&quot; +</span><br><span class="line">                &quot;address=&apos;&quot; + address + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beans.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;address&quot; class=&quot;xiaolei.pojo.Address&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;address&quot; value=&quot;上海&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;xiaolei.pojo.Student&quot;&gt;</span><br><span class="line">        &lt;!--第一种：普通值注入，value--&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">        &lt;!--第二种：Bean注入，ref注入--&gt;</span><br><span class="line">        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;</span><br><span class="line">        &lt;!--第三种：数组注入--&gt;</span><br><span class="line">        &lt;property name=&quot;books&quot;&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;《Java编程思想》&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;《Java多线程并发》&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;《深入学习Mysql》&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第四种：List集合数组--&gt;</span><br><span class="line">        &lt;property name=&quot;hobbies&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;喝奶茶&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;吃火锅&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;写代码&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第五种：Map集合--&gt;</span><br><span class="line">        &lt;property name=&quot;card&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;身份证&quot; value=&quot;121212&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;银行卡&quot; value=&quot;212121&quot;/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第六种：Set集合--&gt;</span><br><span class="line">        &lt;property name=&quot;games&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;LOL&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;CF&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;DNF&lt;/value&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!--第七种：空值注入--&gt;</span><br><span class="line">        &lt;property name=&quot;wife&quot;&gt;</span><br><span class="line">            &lt;null/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第八种：properties--&gt;</span><br><span class="line">        &lt;property name=&quot;info&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;driver&quot;&gt;20192020&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;url&quot;&gt;男&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;username&quot;&gt;20192020&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        Student student = (Student) context.getBean(&quot;student&quot;);</span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&apos;潇雷&apos;, address=Address&#123;address=&apos;上海&apos;&#125;, books=[《Java编程思想》, 《Java多线程并发》, 《深入学习Mysql》], hobbies=[喝奶茶, 吃火锅, 写代码], card=&#123;身份证=121212, 银行卡=212121&#125;, games=[LOL, CF, DNF], wife=&apos;null&apos;, info=&#123;url=男, driver=20192020, username=20192020&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、拓展方式注入"><a href="#4、拓展方式注入" class="headerlink" title="4、拓展方式注入"></a>4、拓展方式注入</h3><ul>
<li>1、P命名空间注入：需要在头文件加入约束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; p:name=&quot;潇雷&quot; p:age=&quot;18&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>2、C命名空间注入：需要在头文件加入约束文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; c:name=&quot;潇雷&quot; p:age=&quot;18&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5、Bean的作用域"><a href="#5、Bean的作用域" class="headerlink" title="5、Bean的作用域"></a>5、Bean的作用域</h3><ul>
<li>在Spring中，那些组成应用程序的主体及由Spring ioc容器所管理的对象，被称为bean。简单的说，bean就是由ioc容器初始化、装配及管理的对象。</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/852070927.png" alt="image"></p>
<ul>
<li><p>几种作用域中，request，session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架）只能用在基于web的spring ApplicationContext环境。</p>
</li>
<li><p>1、单例模式（Spring默认机制）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; scope=&quot;singleton&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>2、原型模式：每次从容器中get的时候，都会产生一个新对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【spring】：（1）概述、ioc理论</title>
    <url>/2020/02/25/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0%E3%80%81ioc%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<img width="769px" height="369px" src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/%E7%BE%8E%E5%9B%BE/1bffb1a3f9f12ff2a0b3a0c2f83d9eeb_5be671fc13d35.jpg"/>

<h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><ul>
<li>Spring：春天-&gt;给软件行业带来了春天</li>
<li>2002年，首先推出Spring框架的雏形：interface21</li>
<li>2004年3月24号：在interface21框架上，发布了Spring框架的1.0版本</li>
<li>Rod Johnson：Spring Framework创始人,音乐学博士</li>
<li>Spring理念：本身就是大杂烩，整合现有的框架技术。</li>
</ul>
<p>官网：<a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">https://spring.io/projects/spring-framework</a></p>
<p>官方下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>Github：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></p>
<h2 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h2><ol>
<li>方便解耦，简化开发（高内聚，低耦合）</li>
<li>Spring是一个轻量级的、非侵入式的框架！非侵入式就是对原来的东西没有影响</li>
<li><strong>控制反转（ioc）、面向切面编程（AOP）</strong></li>
<li>支持事务的处理，对框架整合的支持</li>
</ol>
<p><strong>==总结一句话：Spring就是一个轻量级的控制反转（ioc）和面向切面编程的框架==</strong></p>
<h2 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h2><ul>
<li>spring框架是一个分层架构，由7个定义良好的模块组成，Spring模块构建在核心容器之上，核心容器定义了创建、配置和管理bean的方式。</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3294472123.png" alt="image"></p>
<ul>
<li>组成Sping框架的每个模块都可以单独存在，或者与其他一个或多个模块联合实现，每个模块的功能如下：<ul>
<li>核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
</li>
</ul>
<h2 id="1-4-ioc理论推导"><a href="#1-4-ioc理论推导" class="headerlink" title="1.4 ioc理论推导"></a>1.4 ioc理论推导</h2><h4 id="1-4-1-过去我们写代码："><a href="#1-4-1-过去我们写代码：" class="headerlink" title="1.4.1 过去我们写代码："></a>1.4.1 过去我们写代码：</h4><ul>
<li>1、先一个UserDao接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2、再去写Dao的实现类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;获取用户数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3、然后去写UserService的接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>4、最后写UserService的实现类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao = new UserDaoImpl();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、测试一下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    UserService service = new UserServiceImpl();</span><br><span class="line">    service.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这是我们原来的方式，如果在dao层在增加一个实现类，则需要更改service实现类的代码。如果大量增加实现类，大量更改service代码的话，这种方法也就不适用了。耦合性太高，牵一发而动全身！</p>
<h4 id="1-4-2-如何解决？"><a href="#1-4-2-如何解决？" class="headerlink" title="1.4.2 如何解决？"></a>1.4.2 如何解决？</h4><ul>
<li>我们可以在需要用到它的地方，不去实现它，而是留出一个接口，利用set，我们去代码里修改下。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    // 利用set实现</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改后，就不需要再动service里的代码，用户想调用什么就在外面直接调用。</p>
<ol>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用set注入后，程序不再具有主动性，而是变成可被动的接收到对象。</li>
</ol>
<ul>
<li>这种思想，从本质上解决了问题，外面程序员不再管理对象的创建，系统的耦合性大大降低，可以更加专注在业务的实现上，这就是ioc的原型。</li>
</ul>
<h2 id="1-5-ioc本质"><a href="#1-5-ioc本质" class="headerlink" title="1.5 ioc本质"></a>1.5 ioc本质</h2><ul>
<li>ioc：inverse of controller 控制反转，ioc是一种新的java编程模式。由Spring来负责控制对象的生命周期和对象间的关系，而不需要程序员来管理，Di是实现ioc的一种方法。</li>
<li>Spring容器在初始化时会读取配置文件，根据配置文件或元数据创建组织对象存入容器中，程序使用时从ioc容器中取出需要的对象</li>
</ul>
<p><strong>搞清楚几个问题：</strong></p>
<ul>
<li>谁依赖谁：应用程序依赖于ioc容器</li>
<li>为什么要依赖：应用程序需要ioc容器来提供对象需要的外部资源。</li>
<li>谁注入谁：IOC容器注入应用程序某个对象，应用程序依赖的对象。</li>
<li>注入了什么：注入了某个对象所需要的外部资源（包括对象、资源、常量数据）</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【java基础】：反射机制</title>
    <url>/2020/02/18/%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="java基础之反射"><a href="#java基础之反射" class="headerlink" title="java基础之反射"></a>java基础之反射</h1><ul>
<li><strong>1、反射概述</strong></li>
<li><strong>2、获取class类型的对象</strong></li>
<li><strong>3、通过反射获取构造方法并使用</strong></li>
<li><strong>4、通过反射获取成员变量并使用</strong></li>
<li><strong>5、通过反射并获取成员方法并使用</strong></li>
</ul>
<h2 id="1、反射概述"><a href="#1、反射概述" class="headerlink" title="1、反射概述"></a>1、反射概述</h2><p>&emsp;&emsp;java不是动态 语言，但java可以被称为准动态语言，因为它的反射机制。而这个反射机制是java被视为动态语言的关键。反射机制允许程序在执行期间借助Reflection API取得任何类的内部消息，并能直接操作任意对象的内部属性及方法。加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称为：反射。</p>
<p><strong>优点</strong>：可以实现动态创建对象和编译，体现出很大的灵活性。</p>
<p><strong>缺点</strong>：对性能有影响，使用反射基本上是一种解析操作，我们可以告诉jvm，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p>
<h2 id="2、获取class类型对象"><a href="#2、获取class类型对象" class="headerlink" title="2、获取class类型对象"></a>2、获取class类型对象</h2><h3 id="2-1-java代码分析"><a href="#2-1-java代码分析" class="headerlink" title="2.1 java代码分析"></a>2.1 java代码分析</h3><p>java代码在计算机中经历有三个阶段。</p>
<p>第一阶段：源代码阶段。由程序员写的一个pojo类，假设为A，可以包含成员变量，构造方法，和成员方法。然后该类经过javac编译，生成了一个A.class的字节码文件。</p>
<p>第二阶段：class类对象阶段。这个阶段由类加载器ClassLoader加载得到一个class类的对象。该对象包含成员变量，构造方法以及成员方法。一个类只产生一个class对象。</p>
<p>第三阶段：运行时阶段。通过class类的这几个方法创建对象。反射的本质理解就是得到class对象后反向获取student对象的各种信息。</p>
<h2 id="2-2-如何得到class类对象"><a href="#2-2-如何得到class类对象" class="headerlink" title="2.2 如何得到class类对象"></a>2.2 如何得到class类对象</h2><p><strong>方式一：</strong> Object类的getClass（）方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">Class c = p.getClass();</span><br></pre></td></tr></table></figure>
<p><strong>方式二：</strong> 任何数据类型都有一个“静态”的class属性.</p>
<p>所有类型的class对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = Object.class;//对象</span><br><span class="line">        Class c2= Comparable.class;//接口</span><br><span class="line">        Class c3=String[].class;//数组</span><br><span class="line">        Class c4=int[][].class;//二维数组</span><br><span class="line">        Class c5=Override.class;//注解</span><br><span class="line">        Class c6=Integer.class;//基本数据类型</span><br><span class="line">        Class c7= ElementType.class;//枚举类型</span><br><span class="line">        Class c8=void.class;//空</span><br><span class="line">        Class c9=Class.class;//class</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.Object</span><br><span class="line">interface java.lang.Comparable</span><br><span class="line">class [Ljava.lang.String;</span><br><span class="line">class [[I</span><br><span class="line">interface java.lang.Override</span><br><span class="line">class java.lang.Integer</span><br><span class="line">class java.lang.annotation.ElementType</span><br><span class="line">void</span><br><span class="line">class java.lang.Class</span><br></pre></td></tr></table></figure>
<p><strong>方式三（常用）：</strong> 通过Class类的静态方法：forName（String  className）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c4 = Class.forName(&quot;com.xiaolei.Person&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="3、通过反射获取构造方法并使用"><a href="#3、通过反射获取构造方法并使用" class="headerlink" title="3、通过反射获取构造方法并使用"></a>3、通过反射获取构造方法并使用</h2><p>写个person类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    //定义三个成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    int age;</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Person(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age, String address) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个无参的方法</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;show!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带参的方法</span><br><span class="line">    public void method(String s) &#123;</span><br><span class="line">        System.out.println(&quot;method:&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带两个参数的方法</span><br><span class="line">    public String getString(String s,int i)&#123;</span><br><span class="line">        return s+&quot;---&quot;+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个私有的方法</span><br><span class="line">    private void function()&#123;</span><br><span class="line">        System.out.println(&quot;function !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写toStirng（）</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person[name=&quot;+name+&quot;,age=&quot;+age+&quot;,address=&quot;+address+&quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package fqy1;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1).批量的方法：</span><br><span class="line">   public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">   public Constructor[] getDeclaredConstructors()：</span><br><span class="line">   获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line"></span><br><span class="line">2).获取单个的方法，并调用：</span><br><span class="line">public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">获取指定单个的&quot;公有的&quot;构造方法：</span><br><span class="line">public Constructor getDeclaredConstructor(Class... parameterTypes):</span><br><span class="line">获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line">调用构造方法：</span><br><span class="line">      Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line">创建对象：</span><br><span class="line">      newInstance()</span><br><span class="line">      con.newInstance(“zhangsan&quot;, 20);</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //获取字节码文件对象</span><br><span class="line">        Class c1=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //第一：public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">        System.out.println(&quot;一、获取所有公有构造方法:&quot;);</span><br><span class="line">        Constructor[] cons = c1.getConstructors();</span><br><span class="line">        for(Constructor con:cons)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第二：public Constructor[] getDeclaredConstructors()：</span><br><span class="line">        //   获取所有的构造方法</span><br><span class="line">        System.out.println(&quot;二、获取所有的构造方法:&quot;);</span><br><span class="line">        Constructor[] cons2 =c1.getDeclaredConstructors();</span><br><span class="line">        for(Constructor con:cons2)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第三：public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">        //获取指定的单个“共有的”构造方法</span><br><span class="line">        //步骤：</span><br><span class="line">        //  A：首先创造字节码文件对象</span><br><span class="line">        //  B：通过字节码文件对象去创建构造器对象</span><br><span class="line">        //  C：通过构造器对象去创建一个实例对象</span><br><span class="line">        System.out.println(&quot;三、无参：获取指定的单个“共有的”构造方法:&quot;);</span><br><span class="line">        Constructor con3= c1.getConstructor(null);//返回的是构造方法对象</span><br><span class="line">        Object obj=con3.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        第四：需求：通过反射去获取该构造方法并使用</span><br><span class="line">        public person (String name,int age,String address)</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;四、通过反射去获取该构造方法并使用:&quot;);</span><br><span class="line">        Constructor con4=c1.getConstructor(String.class,int.class,String.class);</span><br><span class="line"></span><br><span class="line">        //通过带参构造方法对象创建对象</span><br><span class="line">        Object obj2=con4.newInstance(&quot;徐雷&quot;,18,&quot;武汉&quot;);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        需求：通过反射获取私有构造方法并使用</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;五、需求：通过反射获取私有构造方法并使用:&quot;);</span><br><span class="line">        Constructor con5=c1.getDeclaredConstructor(String.class);</span><br><span class="line">        //暴力访问</span><br><span class="line">        con5.setAccessible(true);</span><br><span class="line">         obj2=con5.newInstance(&quot;猫猫&quot;);//IllegalArgumentException:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、获取所有公有构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">二、获取所有的构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">fqy1.Person(java.lang.String,int)</span><br><span class="line">private fqy1.Person(java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">三、无参：获取指定的单个“共有的”构造方法:</span><br><span class="line">Person[name=null,age=0,address=null]</span><br><span class="line">四、通过反射去获取该构造方法并使用:</span><br><span class="line">Person[name=徐雷,age=18,address=武汉]</span><br><span class="line">五、需求：通过反射获取私有构造方法并使用:</span><br><span class="line">Person[name=猫猫,age=0,address=null]</span><br></pre></td></tr></table></figure>
<h2 id="4、通过反射获取成员变量并使用"><a href="#4、通过反射获取成员变量并使用" class="headerlink" title="4、通过反射获取成员变量并使用"></a>4、通过反射获取成员变量并使用</h2><p>1.获取所有成员：<br>     1).Field[] getFields():获取所有的”公有字段”<br>     2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</p>
<p>2.获取单个成员的：<br>     1).public Field getField(String fieldName):获取某个”公有的”字段；<br>     2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</p>
<p>3.修改成员的值：<br>         Field –&gt; public void set(Object obj,Object value):</p>
<p> 参数说明：<br>             1.obj:要设置的字段所在的对象；这个对象通过Constructor创建<br>             2.value:要为字段设置的值；</p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReflectDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c2=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //Field[] getFields():获取所有的&quot;公有字段&quot;</span><br><span class="line">        System.out.println(&quot;第一：获取所有公有成员变量：&quot;);</span><br><span class="line">        Field[] field=c2.getFields();</span><br><span class="line">        for(Field f:field)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有</span><br><span class="line">        System.out.println(&quot;第二：获取所有字段&quot;);</span><br><span class="line">        Field [] field2=c2.getDeclaredFields();</span><br><span class="line">        for(Field f:field2)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span><br><span class="line">        //Field --&gt; public void set(Object obj,Object value):</span><br><span class="line">        System.out.println(&quot;第三：获取某个公共字段并赋值：&quot;);</span><br><span class="line">        //通过无参构造方法创建对象</span><br><span class="line">        Constructor con =c2.getConstructor();</span><br><span class="line">        Object obj =con.newInstance();</span><br><span class="line">        Field field3=c2.getField(&quot;address&quot;);</span><br><span class="line">        field3.set(obj,&quot;武汉&quot;);//给object对象的f字段设置为”武汉“</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //获取name并对其赋值</span><br><span class="line">        System.out.println(&quot;第四：获取私有变量并赋值&quot;);</span><br><span class="line">        Field field4=c2.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        field4.setAccessible(true);</span><br><span class="line">        field4.set(obj,&quot;徐雷&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一：获取所有公有成员变量：</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第二：获取所有字段</span><br><span class="line">private java.lang.String fqy1.Person.name</span><br><span class="line">int fqy1.Person.age</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第三：获取某个公共字段并赋值：</span><br><span class="line">Person[name=null,age=0,address=武汉]</span><br><span class="line">第四：获取私有变量并赋值</span><br><span class="line">Person[name=徐雷,age=0,address=武汉]</span><br></pre></td></tr></table></figure>
<h2 id="5、通过反射获取成员方法并使用"><a href="#5、通过反射获取成员方法并使用" class="headerlink" title="5、通过反射获取成员方法并使用"></a>5、通过反射获取成员方法并使用</h2><h3 id="1-批量的："><a href="#1-批量的：" class="headerlink" title="1.批量的："></a>1.批量的：</h3><pre><code>public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）
public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</code></pre><h3 id="2-获取单个的："><a href="#2-获取单个的：" class="headerlink" title="2.获取单个的："></a>2.获取单个的：</h3><pre><code>public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):
            参数：
                 name : 方法名；
                Class ... : 形参的Class类型对象
public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code></pre><p> 【注】：第一个参数表示的是方法名，第二个参数表示的是方法的参数的class类型，这个方法返回值是Object接收，第一个参数表示对象是谁，第二参数表示调用该方法的实际参数。</p>
<h3 id="3-调用方法："><a href="#3-调用方法：" class="headerlink" title="3.调用方法："></a>3.调用方法：</h3><pre><code>Method --&gt; public Object invoke(Object obj,Object... args):
    参数说明：
    obj : 要调用方法的对象；
    args:调用方式时所传递的实参；</code></pre><p>测试成员方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">测试成员方法：</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //public Method[] getMethods():获取所有&quot;公有方法&quot;；</span><br><span class="line">        System.out.println(&quot;------第一：获取所有公有方法-------&quot;);</span><br><span class="line">        Method []m=c.getMethods();</span><br><span class="line">        for(Method method:m)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        //public Method[] getDeclaredMethods():</span><br><span class="line">        System.out.println(&quot;---------第二：获取所有方法--------&quot;);</span><br><span class="line">        Method[] m2=c.getDeclaredMethods();</span><br><span class="line">        for(Method method:m2)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor con=c.getConstructor();</span><br><span class="line">        Object obj=con.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------第三获取单个无参方法并使用----------&quot;);</span><br><span class="line">        //调用show方法</span><br><span class="line">        Method m1=c.getMethod(&quot;show&quot;);</span><br><span class="line">        //obj.m1();错误</span><br><span class="line">        //</span><br><span class="line">        m1.invoke(obj);//调用obj对象的m1方法</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第四，获取单个有参参数并使用-----------&quot;);</span><br><span class="line">        Method m3=c.getMethod(&quot;method&quot;, String.class);</span><br><span class="line">        m3.invoke(obj,&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第五，获取带多个参数的方法并使用-----&quot;);</span><br><span class="line">        Method m4=c.getMethod(&quot;getString&quot;, String.class, int.class);</span><br><span class="line">        Object objectString=m4.invoke(obj,&quot;徐雷&quot;,18);//返回object类型，记住！</span><br><span class="line">        System.out.println(objectString);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第六。获取私有的方法并使用----&quot;);</span><br><span class="line">        Method m5=c.getDeclaredMethod(&quot;function&quot;);</span><br><span class="line">        m5.setAccessible(true);</span><br><span class="line">        m5.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------第一：获取所有公有方法-------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">---------第二：获取所有方法--------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">private void fqy1.Person.function()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">--------第三获取单个无参方法并使用----------</span><br><span class="line">show!</span><br><span class="line">-----第四，获取单个有参参数并使用-----------</span><br><span class="line">method:hello</span><br><span class="line">-----第五，获取带多个参数的方法并使用-----</span><br><span class="line">徐雷---18</span><br><span class="line">-----第六。获取私</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作】：入职前的一些规划</title>
    <url>/2019/11/18/%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91%EF%BC%9A%E5%85%A5%E8%81%8C%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%92%E5%92%8C%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[## 一、前言

<p>&emsp;&emsp;未来不可知，上海的职业生涯将正式开始，花自缤纷花自谢，时间太紧了，拼不了爹的自己只能拼命去学习。万一实现了呢？ </p>
<h2 id="二、未来计划（2019-11-2021-9）"><a href="#二、未来计划（2019-11-2021-9）" class="headerlink" title="二、未来计划（2019.11-2021.9）"></a>二、未来计划（2019.11-2021.9）</h2><p>&emsp;&emsp;我希望在这近两年的时间内，竭尽全力的提升自己，努力往（三初一高）的方向发展：    </p>
<ul>
<li><strong>高级的Java开发</strong>；</li>
<li><strong>初级的大数据学习者</strong>；</li>
<li><strong>初级的人工智能学习者</strong>；</li>
<li><strong>初级的vr学习者</strong>；</li>
</ul>
<h2 id="三、着手当下"><a href="#三、着手当下" class="headerlink" title="三、着手当下"></a>三、着手当下</h2><ol>
<li>融入公司，跟上工作节奏。</li>
<li>学习不再片面，有条理的规划出一块内容深入学习</li>
<li>每周抽出20个小时的时间学习新知识。</li>
<li>不打游戏。</li>
<li>开始阅读书籍，书单已经选好。</li>
<li>开始慢慢的理财，关注房价和理财的事儿。</li>
<li>待更。。。</li>
</ol>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【潇雷】：风雨求职路</title>
    <url>/2019/11/14/%E3%80%90%E6%B1%82%E8%81%8C%E3%80%91%E9%82%A3%E4%BA%9B%E5%BF%83%E9%85%B8%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>一转眼，来上海就两个半月了，由夏至秋，天气转凉。  如今找工作的事情终于尘埃入定。  应届生社招时的碰壁让我深受打击，不仅投过实习的岗位，也频频报低价格卑微地换取一份糊口的工作，最后，还是没有放弃，总有适合你的工作在等待你。熬一熬，就过去了。</p>
<h1 id="2-求职"><a href="#2-求职" class="headerlink" title="2.求职"></a>2.求职</h1><h2 id="2-1-简历"><a href="#2-1-简历" class="headerlink" title="2.1 简历"></a>2.1 简历</h2><p>面了一个月，boss沟通八百多家，拉钩5年以下全投过，换来的是寥寥无几的面试机会，从刚开始投简历到找到工作的前两天还改些简历中的小毛病，慢慢的，我发现越到后面，我这简历竟然也能入的了一些大中厂的眼，虽然写的一年工作经验，虽然念的是普通二本非科班，这些特征在浩浩荡荡的简历海洋中本就该沉入海底的，我回头想想，除了那些项目，专业技能外，还有两点：第一是我把本科的CPA专业排名第二写上去了，还有一些奖学金，数学竞赛奖，这些起码能说明我在大学还是学了点东西的。第二是我添加了自己的个人博客和微信公众号，虽然不知道他们会不会看，虽然csdn很low，文章也不多，但是看着还是很努力的。所以个人博客的重要性在面试的时候还是挺加分的。因此，在往后的学习工作中，我将以博客的形式来记录自己的学习和生活。</p>
<h2 id="2-2-面试"><a href="#2-2-面试" class="headerlink" title="2.2 面试"></a>2.2 面试</h2><p><strong>第一家:</strong> 去了个培训机构，叫一堆的人去面试，做了几道nc逻辑题，结果全给做错了，连培训机构都不想要我，hhhh，服了，现在培训机构也挑人了吗？<br><strong>第二家:</strong> 是一个医疗相关的，面试很紧张，终于来了次正经的技术面，下面是面试题  </p>
<p><strong>1.两个linux之间相互传文件怎么做？</strong><br>答：可以使用SCP命令。  </p>
<p><strong>2.mysql查询前十条数据怎么做？</strong><br>select * from emp LIMIT 0,10  </p>
<p><strong>3.js怎么定义数组？</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种  </span><br><span class="line">            var arr = new Array();  </span><br><span class="line">            arr[0] = 123  </span><br><span class="line">            arr[1] = &quot;abc&quot;;  </span><br><span class="line">            arr[5] = false;  </span><br><span class="line">            alert(arr[3]);//undefined  </span><br><span class="line">            alert(arr);//123,abc,,,,false  </span><br><span class="line">            alert(arr[10]);//undefined，不会出现越界异常  </span><br><span class="line">            </span><br><span class="line">            //for in 遍历，未定义的不遍历</span><br><span class="line">            for(var i in arr)&#123;</span><br><span class="line">                alert(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">            //第二种  </span><br><span class="line">            var arr2 = new Array(2);//规定了数组的长度为2  </span><br><span class="line">            arr2[0] = &quot;ddd&quot;;  </span><br><span class="line">            arr2[1] = &quot;www&quot;;  </span><br><span class="line">            alert(arr2);//ddd,www  </span><br><span class="line">            arr2[2] = &quot;fff&quot;;//可以再次添加元素，定义的数组大小对此没有影响  </span><br><span class="line">            alert(arr2);//ddd,www,fff  </span><br><span class="line">                 </span><br><span class="line">            //第三种  </span><br><span class="line">            var arr3 = new Array(true,123,false);  </span><br><span class="line">            alert(arr3);//true,123,false  </span><br><span class="line">              </span><br><span class="line">            //第四种,推荐使用  </span><br><span class="line">            var arr4 = [false,&quot;aaa&quot;,123];  </span><br><span class="line">            alert(arr4);//false,aaa,123</span><br></pre></td></tr></table></figure>
<p><strong>4.vue的条件判断的指令？</strong><br> v-if指令。  </p>
<p><strong>5.git是干嘛的？（版本控制系统）</strong>  </p>
<p><strong>6.java的空指针怎么发生的？口述两行代码，一定会发生空指针？</strong><br>当一个对象不存在时，又调用它的话就会产生空指针异常。<br>object o=null；<br>o.tostring();</p>
<p><strong>7.java的数组越界是怎样的？像ArrayList这种自动增长的，它有没有可能发生越界？为什么？</strong><br>因为arrayList是线程不安全的类，当出现多个线程同时添加元素的时候，此时arrayList就会可能会出现数组越界的问题。  </p>
<p><strong>8.java的自定义注解是怎么解析的？（反射，加载成.class字节码文件）</strong>  </p>
<p><strong>9.定义一个简单的java类，这个类要使它能够表达简单的树形结构，那么这个类的关键特征是什么？</strong><br>就是有两个成员变量，类型是自己，分别指向左子树和右子树（以二叉树为例）。  </p>
<p>中间还问了点单词数学，应该是比较缺人，然后虽然我面试的很差，很多答不上来，但是过了几天还是给我发offer，只不过面试的时候就说就面试来看，我只值6k，我也同意它的说法，但是还是想多面几家试试，就拒绝了，没想到后面才正式开始了苦逼之路。</p>
<p><strong>第三家:</strong> 是一个50人左右的公司，做笔试题的时候，发现难度简直升级，结果笔试题都写不下去，就灰溜溜的回去了，下面是部分笔试题：<br>1.1万个人抢100个红包，如何保证2个人不能抢到同一个红包？<br>2.Git如何放弃工作区的更改？<br>3.写一个方法，处理接收POST类型的JSON参数的请求（参数为name，age）<br>4.POST请求是否可以是url？a=b&amp;c=d的形式请求？如何不可以请说出理由<br>5.设计一个对外服务的接口实现类，在1，2，3这三台主机上（有不同的IP地址）实现负载均衡和顺序轮询机制<br>6.@Scheduled是否为多线程执行，如果是请说明理由，否则请给出解决方案；<br>7.通过Nginx实现：访问<a href="http://test.ab.com，代理请求到http://101.101.1.1.9/" target="_blank" rel="noopener">http://test.ab.com，代理请求到http://101.101.1.1.9/</a><br>8.以JAR包的方式部署temp.jar，请写出部署命令，以及查看Java进程，结束进程</p>
<p><strong>第四家：</strong> 自第三家受打击之后就停下来复习了一周，当时也感觉面试好多，才没投几家就去面试了，所以当时想不把一些机会白白浪费掉，尽管如此，现在想来这种做法特别不好，不能停这么久，而且自己学真的学不到那么多，还是少约点面试，保持两天内一个面试放慢节奏还是比较好的。这家面了一个实习，在上海的团队就他一个人，想想就优点怕，它也看出来我心里的担心，最后可能倒在了沟通问题，以及非全日制，和技术回答的比较死板，考虑问题没有挖很深，很多都是直接从面经上看来，比如hashtable为什么不能为null？  </p>
<p><strong>第五家:</strong> 这次去的是一个岗位上技能啥都不要求的公司，会c，python，java就可以，我以为可能又是骗子公司，没想到公司也没想象中那么小，然后填完信息领到面试官那里，让我上机，实现一个在一个64*64的棋盘上，找出他给的100个点里的最短路径，然后让我开始写，我慢慢的脑子陷入了，感觉到现在都没理解好提议，它给的100个点如何输入到电脑里，一个二维数组，怎么接收这些点，然后算法用迪杰斯特拉算法怎么实现？虽然考研的时候做过这种算法找最短路径的点，但是要真让我实现，还真狠有难度，最后不来了之，自此又陷入自闭。 </p>
<p><strong>第六家，第七家：</strong>  上海无果，开始换城市，突发的选了嘉兴，去嘉兴，嘉善分别面了两家，第一家，做金融还要出差，感觉也不是想招人的意思，随便问的一些aop，springboot热部署等问题，最后我还是因为技术没过关被刷了，然后赶去嘉善面试，这个初创公司感觉面试官的他的三年经验很有水分，随便聊聊项目就过了，基础也没问，后面给我开了8k，最后犹豫再三还是拒了，初创公司不敢去，更别提没个大牛的初创公司。  </p>
<p><strong>第八家：</strong>  开始转战上海，一个金融相关的，我面试的感觉还不错，也感觉有希望进，但是最后不知道什么原因被刷了，这家我还是挺想去的。至少工作还是挺成熟的。 </p>
<p><strong>第九家：</strong> 做智能健身相关的，面试官技术很强，阿里出来的年轻小伙，但是给我的感觉是有点轻蔑，可能这就是牛人吧，最后我都报到6k了，但是我感觉那岗位学的东西也不多，不是纯java开发的。</p>
<p><strong>第十家：</strong> 转眼又过了一周，这家去了轻轻家教，面的问题很灵活，数据结构的知识我真的忘了很多，但是面试官人很好，跟我聊了挺久的。不过自己还是太菜了，我只想说面试还是很看重运气和那岗位的缺人程度的，最后惨败吧。 </p>
<p><strong>第十一家：</strong> 又跑了很远的地方去面试，一个挂羊头卖狗头的，应该是猎头公司，收集了很多面试人的信息资料，随便聊聊就不面了。也没抱希望。  </p>
<p><strong>第十二家：</strong> 这家是挺正规的，离我住处最近的一家了，走路十分钟就到了，面试之前看到这家岗位已经关闭了，面试官是一个很年轻的，这种年轻没多少面试经验的面试官会故意问的比较深，来展示他的能力，根本不从实际情况来面，我就一年的实习经验，把我当几年的面，还问我有没有带过人？也问了一些假大空的问题，消息堆积，重复消费，服务挂了怎么看等等，然后一个小时的面试，直接说，今天的面试到此结束。我就灰溜溜的回去了，不想要我干嘛浪费两个人的时间。</p>
<p><strong>第十三家：</strong> 这次是最后一次面试了，公司环境不错，成立八年的互联网公司，也有自己的产品，面积也很大，然后经过两轮的技术面试和一轮的hr小姐姐沟通后，终于以自己的实力和运气终于拿到了offer，这虽然不是最好的公司，但是这是现阶段最适合我的公司，面试总结的问题就是提升自己的沟通能力，很多东西，你得学会用自己的话来很精准的描述它，这种能力也是需要锻炼出来的，我在回复它邮件的时候，写了未来我们一起加油。  </p>
<h2 id="3感慨"><a href="#3感慨" class="headerlink" title="3感慨"></a>3感慨</h2><p>这一个多月我经历了什么？我得到了什么？<br>我的生活才刚刚开始，未来可期。<br>记两首诗：</p>
<p><strong>《夜》</strong><br>晚风拂我意，<br>荧屏对相思。<br>奔波十里外，<br>另觅橄榄枝。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/850b262531a3b749e927b27f1b28805.jpg" alt="image"></p>
<p><strong>《光》</strong><br>九月憧憬，新奇欲试笔与刀。<br>十月无闻，无花树下羞与闹。<br>十一过半，滩里霓虹光与照。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/f8e7a632c8e60cd0d9deb53f2ffd247.jpg" alt="image"></p>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>潇雷哥哥的第一篇博客</title>
    <url>/2019/11/11/%E6%BD%87%E9%9B%B7%E5%93%A5%E5%93%A5%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[# 潇雷

<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul>
<li>列表1</li>
<li>列表2<br>  a 字列表<br>  b 字列表<br>top: 100 数值越大越靠前<br><a href="https://lixiaoyu.cc/" target="_blank" rel="noopener">啸宇的博客</a><br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/00c1963b1cff4855bf4b72a84f2e0249" alt="我的头像"><br><em>字体是倾斜的</em><br>#字体也能加粗#</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is a block</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
