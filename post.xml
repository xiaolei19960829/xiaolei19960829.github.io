<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【java基础】：反射机制</title>
    <url>/2020/02/18/%E3%80%90java%E5%9F%BA%E7%A1%80%E3%80%91%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="java基础之反射"><a href="#java基础之反射" class="headerlink" title="java基础之反射"></a>java基础之反射</h1><ul>
<li><strong>1、反射概述</strong></li>
<li><strong>2、获取class类型的对象</strong></li>
<li><strong>3、通过反射获取构造方法并使用</strong></li>
<li><strong>4、通过反射获取成员变量并使用</strong></li>
<li><strong>5、通过反射并获取成员方法并使用</strong></li>
</ul>
<h2 id="1、反射概述"><a href="#1、反射概述" class="headerlink" title="1、反射概述"></a>1、反射概述</h2><p>&emsp;&emsp;java不是动态 语言，但java可以被称为准动态语言，因为它的反射机制。而这个反射机制是java被视为动态语言的关键。反射机制允许程序在执行期间借助Reflection API取得任何类的内部消息，并能直接操作任意对象的内部属性及方法。加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称为：反射。</p>
<p><strong>优点</strong>：可以实现动态创建对象和编译，体现出很大的灵活性。</p>
<p><strong>缺点</strong>：对性能有影响，使用反射基本上是一种解析操作，我们可以告诉jvm，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p>
<h2 id="2、获取class类型对象"><a href="#2、获取class类型对象" class="headerlink" title="2、获取class类型对象"></a>2、获取class类型对象</h2><h3 id="2-1-java代码分析"><a href="#2-1-java代码分析" class="headerlink" title="2.1 java代码分析"></a>2.1 java代码分析</h3><p>java代码在计算机中经历有三个阶段。</p>
<p>第一阶段：源代码阶段。由程序员写的一个pojo类，假设为A，可以包含成员变量，构造方法，和成员方法。然后该类经过javac编译，生成了一个A.class的字节码文件。</p>
<p>第二阶段：class类对象阶段。这个阶段由类加载器ClassLoader加载得到一个class类的对象。该对象包含成员变量，构造方法以及成员方法。一个类只产生一个class对象。</p>
<p>第三阶段：运行时阶段。通过class类的这几个方法创建对象。反射的本质理解就是得到class对象后反向获取student对象的各种信息。</p>
<h2 id="2-2-如何得到class类对象"><a href="#2-2-如何得到class类对象" class="headerlink" title="2.2 如何得到class类对象"></a>2.2 如何得到class类对象</h2><p><strong>方式一：</strong> Object类的getClass（）方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">Class c = p.getClass();</span><br></pre></td></tr></table></figure>
<p><strong>方式二：</strong> 任何数据类型都有一个“静态”的class属性.</p>
<p>所有类型的class对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = Object.class;//对象</span><br><span class="line">        Class c2= Comparable.class;//接口</span><br><span class="line">        Class c3=String[].class;//数组</span><br><span class="line">        Class c4=int[][].class;//二维数组</span><br><span class="line">        Class c5=Override.class;//注解</span><br><span class="line">        Class c6=Integer.class;//基本数据类型</span><br><span class="line">        Class c7= ElementType.class;//枚举类型</span><br><span class="line">        Class c8=void.class;//空</span><br><span class="line">        Class c9=Class.class;//class</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.Object</span><br><span class="line">interface java.lang.Comparable</span><br><span class="line">class [Ljava.lang.String;</span><br><span class="line">class [[I</span><br><span class="line">interface java.lang.Override</span><br><span class="line">class java.lang.Integer</span><br><span class="line">class java.lang.annotation.ElementType</span><br><span class="line">void</span><br><span class="line">class java.lang.Class</span><br></pre></td></tr></table></figure>
<p><strong>方式三（常用）：</strong> 通过Class类的静态方法：forName（String  className）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c4 = Class.forName(&quot;com.xiaolei.Person&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="3、通过反射获取构造方法并使用"><a href="#3、通过反射获取构造方法并使用" class="headerlink" title="3、通过反射获取构造方法并使用"></a>3、通过反射获取构造方法并使用</h2><p>写个person类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    //定义三个成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    int age;</span><br><span class="line">    public String address;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Person(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age, String address) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个无参的方法</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;show!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带参的方法</span><br><span class="line">    public void method(String s) &#123;</span><br><span class="line">        System.out.println(&quot;method:&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个带两个参数的方法</span><br><span class="line">    public String getString(String s,int i)&#123;</span><br><span class="line">        return s+&quot;---&quot;+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写个私有的方法</span><br><span class="line">    private void function()&#123;</span><br><span class="line">        System.out.println(&quot;function !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写toStirng（）</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person[name=&quot;+name+&quot;,age=&quot;+age+&quot;,address=&quot;+address+&quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package fqy1;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1).批量的方法：</span><br><span class="line">   public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">   public Constructor[] getDeclaredConstructors()：</span><br><span class="line">   获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line"></span><br><span class="line">2).获取单个的方法，并调用：</span><br><span class="line">public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">获取指定单个的&quot;公有的&quot;构造方法：</span><br><span class="line">public Constructor getDeclaredConstructor(Class... parameterTypes):</span><br><span class="line">获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line">调用构造方法：</span><br><span class="line">      Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line">创建对象：</span><br><span class="line">      newInstance()</span><br><span class="line">      con.newInstance(“zhangsan&quot;, 20);</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //获取字节码文件对象</span><br><span class="line">        Class c1=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //第一：public Constructor[] getConstructors()：所有public构造方法</span><br><span class="line">        System.out.println(&quot;一、获取所有公有构造方法:&quot;);</span><br><span class="line">        Constructor[] cons = c1.getConstructors();</span><br><span class="line">        for(Constructor con:cons)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第二：public Constructor[] getDeclaredConstructors()：</span><br><span class="line">        //   获取所有的构造方法</span><br><span class="line">        System.out.println(&quot;二、获取所有的构造方法:&quot;);</span><br><span class="line">        Constructor[] cons2 =c1.getDeclaredConstructors();</span><br><span class="line">        for(Constructor con:cons2)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第三：public Constructor getConstructor(Class... parameterTypes):</span><br><span class="line">        //获取指定的单个“共有的”构造方法</span><br><span class="line">        //步骤：</span><br><span class="line">        //  A：首先创造字节码文件对象</span><br><span class="line">        //  B：通过字节码文件对象去创建构造器对象</span><br><span class="line">        //  C：通过构造器对象去创建一个实例对象</span><br><span class="line">        System.out.println(&quot;三、无参：获取指定的单个“共有的”构造方法:&quot;);</span><br><span class="line">        Constructor con3= c1.getConstructor(null);//返回的是构造方法对象</span><br><span class="line">        Object obj=con3.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        第四：需求：通过反射去获取该构造方法并使用</span><br><span class="line">        public person (String name,int age,String address)</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;四、通过反射去获取该构造方法并使用:&quot;);</span><br><span class="line">        Constructor con4=c1.getConstructor(String.class,int.class,String.class);</span><br><span class="line"></span><br><span class="line">        //通过带参构造方法对象创建对象</span><br><span class="line">        Object obj2=con4.newInstance(&quot;徐雷&quot;,18,&quot;武汉&quot;);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        需求：通过反射获取私有构造方法并使用</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;五、需求：通过反射获取私有构造方法并使用:&quot;);</span><br><span class="line">        Constructor con5=c1.getDeclaredConstructor(String.class);</span><br><span class="line">        //暴力访问</span><br><span class="line">        con5.setAccessible(true);</span><br><span class="line">         obj2=con5.newInstance(&quot;猫猫&quot;);//IllegalArgumentException:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、获取所有公有构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">二、获取所有的构造方法:</span><br><span class="line">public fqy1.Person(java.lang.String,int,java.lang.String)</span><br><span class="line">fqy1.Person(java.lang.String,int)</span><br><span class="line">private fqy1.Person(java.lang.String)</span><br><span class="line">public fqy1.Person()</span><br><span class="line">三、无参：获取指定的单个“共有的”构造方法:</span><br><span class="line">Person[name=null,age=0,address=null]</span><br><span class="line">四、通过反射去获取该构造方法并使用:</span><br><span class="line">Person[name=徐雷,age=18,address=武汉]</span><br><span class="line">五、需求：通过反射获取私有构造方法并使用:</span><br><span class="line">Person[name=猫猫,age=0,address=null]</span><br></pre></td></tr></table></figure>
<h2 id="4、通过反射获取成员变量并使用"><a href="#4、通过反射获取成员变量并使用" class="headerlink" title="4、通过反射获取成员变量并使用"></a>4、通过反射获取成员变量并使用</h2><p>1.获取所有成员：<br>     1).Field[] getFields():获取所有的”公有字段”<br>     2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</p>
<p>2.获取单个成员的：<br>     1).public Field getField(String fieldName):获取某个”公有的”字段；<br>     2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</p>
<p>3.修改成员的值：<br>         Field –&gt; public void set(Object obj,Object value):</p>
<p> 参数说明：<br>             1.obj:要设置的字段所在的对象；这个对象通过Constructor创建<br>             2.value:要为字段设置的值；</p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReflectDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c2=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //Field[] getFields():获取所有的&quot;公有字段&quot;</span><br><span class="line">        System.out.println(&quot;第一：获取所有公有成员变量：&quot;);</span><br><span class="line">        Field[] field=c2.getFields();</span><br><span class="line">        for(Field f:field)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有</span><br><span class="line">        System.out.println(&quot;第二：获取所有字段&quot;);</span><br><span class="line">        Field [] field2=c2.getDeclaredFields();</span><br><span class="line">        for(Field f:field2)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span><br><span class="line">        //Field --&gt; public void set(Object obj,Object value):</span><br><span class="line">        System.out.println(&quot;第三：获取某个公共字段并赋值：&quot;);</span><br><span class="line">        //通过无参构造方法创建对象</span><br><span class="line">        Constructor con =c2.getConstructor();</span><br><span class="line">        Object obj =con.newInstance();</span><br><span class="line">        Field field3=c2.getField(&quot;address&quot;);</span><br><span class="line">        field3.set(obj,&quot;武汉&quot;);//给object对象的f字段设置为”武汉“</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //获取name并对其赋值</span><br><span class="line">        System.out.println(&quot;第四：获取私有变量并赋值&quot;);</span><br><span class="line">        Field field4=c2.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        field4.setAccessible(true);</span><br><span class="line">        field4.set(obj,&quot;徐雷&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一：获取所有公有成员变量：</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第二：获取所有字段</span><br><span class="line">private java.lang.String fqy1.Person.name</span><br><span class="line">int fqy1.Person.age</span><br><span class="line">public java.lang.String fqy1.Person.address</span><br><span class="line">第三：获取某个公共字段并赋值：</span><br><span class="line">Person[name=null,age=0,address=武汉]</span><br><span class="line">第四：获取私有变量并赋值</span><br><span class="line">Person[name=徐雷,age=0,address=武汉]</span><br></pre></td></tr></table></figure>
<h2 id="5、通过反射获取成员方法并使用"><a href="#5、通过反射获取成员方法并使用" class="headerlink" title="5、通过反射获取成员方法并使用"></a>5、通过反射获取成员方法并使用</h2><h3 id="1-批量的："><a href="#1-批量的：" class="headerlink" title="1.批量的："></a>1.批量的：</h3><pre><code>public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）
public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</code></pre><h3 id="2-获取单个的："><a href="#2-获取单个的：" class="headerlink" title="2.获取单个的："></a>2.获取单个的：</h3><pre><code>public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):
            参数：
                 name : 方法名；
                Class ... : 形参的Class类型对象
public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code></pre><p> 【注】：第一个参数表示的是方法名，第二个参数表示的是方法的参数的class类型，这个方法返回值是Object接收，第一个参数表示对象是谁，第二参数表示调用该方法的实际参数。</p>
<h3 id="3-调用方法："><a href="#3-调用方法：" class="headerlink" title="3.调用方法："></a>3.调用方法：</h3><pre><code>Method --&gt; public Object invoke(Object obj,Object... args):
    参数说明：
    obj : 要调用方法的对象；
    args:调用方式时所传递的实参；</code></pre><p>测试成员方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">测试成员方法：</span><br><span class="line"> */</span><br><span class="line">public class ReflectDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        //创建class类对象</span><br><span class="line">        Class c=Class.forName(&quot;fqy1.Person&quot;);</span><br><span class="line"></span><br><span class="line">        //public Method[] getMethods():获取所有&quot;公有方法&quot;；</span><br><span class="line">        System.out.println(&quot;------第一：获取所有公有方法-------&quot;);</span><br><span class="line">        Method []m=c.getMethods();</span><br><span class="line">        for(Method method:m)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        //public Method[] getDeclaredMethods():</span><br><span class="line">        System.out.println(&quot;---------第二：获取所有方法--------&quot;);</span><br><span class="line">        Method[] m2=c.getDeclaredMethods();</span><br><span class="line">        for(Method method:m2)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor con=c.getConstructor();</span><br><span class="line">        Object obj=con.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------第三获取单个无参方法并使用----------&quot;);</span><br><span class="line">        //调用show方法</span><br><span class="line">        Method m1=c.getMethod(&quot;show&quot;);</span><br><span class="line">        //obj.m1();错误</span><br><span class="line">        //</span><br><span class="line">        m1.invoke(obj);//调用obj对象的m1方法</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第四，获取单个有参参数并使用-----------&quot;);</span><br><span class="line">        Method m3=c.getMethod(&quot;method&quot;, String.class);</span><br><span class="line">        m3.invoke(obj,&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第五，获取带多个参数的方法并使用-----&quot;);</span><br><span class="line">        Method m4=c.getMethod(&quot;getString&quot;, String.class, int.class);</span><br><span class="line">        Object objectString=m4.invoke(obj,&quot;徐雷&quot;,18);//返回object类型，记住！</span><br><span class="line">        System.out.println(objectString);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----第六。获取私有的方法并使用----&quot;);</span><br><span class="line">        Method m5=c.getDeclaredMethod(&quot;function&quot;);</span><br><span class="line">        m5.setAccessible(true);</span><br><span class="line">        m5.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------第一：获取所有公有方法-------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">---------第二：获取所有方法--------</span><br><span class="line">public java.lang.String fqy1.Person.toString()</span><br><span class="line">private void fqy1.Person.function()</span><br><span class="line">public void fqy1.Person.method(java.lang.String)</span><br><span class="line">public java.lang.String fqy1.Person.getString(java.lang.String,int)</span><br><span class="line">public void fqy1.Person.show()</span><br><span class="line">--------第三获取单个无参方法并使用----------</span><br><span class="line">show!</span><br><span class="line">-----第四，获取单个有参参数并使用-----------</span><br><span class="line">method:hello</span><br><span class="line">-----第五，获取带多个参数的方法并使用-----</span><br><span class="line">徐雷---18</span><br><span class="line">-----第六。获取私</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（1）概述、ioc理论</title>
    <url>/2019/11/18/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0%E3%80%81ioc%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<img width="769px" height="369px" src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/%E7%BE%8E%E5%9B%BE/1bffb1a3f9f12ff2a0b3a0c2f83d9eeb_5be671fc13d35.jpg"/>

<h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><ul>
<li>Spring：春天-&gt;给软件行业带来了春天</li>
<li>2002年，首先推出Spring框架的雏形：interface21</li>
<li>2004年3月24号：在interface21框架上，发布了Spring框架的1.0版本</li>
<li>Rod Johnson：Spring Framework创始人,音乐学博士</li>
<li>Spring理念：本身就是大杂烩，整合现有的框架技术。</li>
</ul>
<p>官网：<a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">https://spring.io/projects/spring-framework</a></p>
<p>官方下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>Github：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></p>
<h2 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h2><ol>
<li>方便解耦，简化开发（高内聚，低耦合）</li>
<li>Spring是一个轻量级的、非侵入式的框架！非侵入式就是对原来的东西没有影响</li>
<li><strong>控制反转（ioc）、面向切面编程（AOP）</strong></li>
<li>支持事务的处理，对框架整合的支持</li>
</ol>
<p><strong>==总结一句话：Spring就是一个轻量级的控制反转（ioc）和面向切面编程的框架==</strong></p>
<h2 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h2><ul>
<li>spring框架是一个分层架构，由7个定义良好的模块组成，Spring模块构建在核心容器之上，核心容器定义了创建、配置和管理bean的方式。</li>
</ul>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3294472123.png" alt="image"></p>
<ul>
<li>组成Sping框架的每个模块都可以单独存在，或者与其他一个或多个模块联合实现，每个模块的功能如下：<ul>
<li>核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
</li>
</ul>
<h2 id="1-4-ioc理论推导"><a href="#1-4-ioc理论推导" class="headerlink" title="1.4 ioc理论推导"></a>1.4 ioc理论推导</h2><h4 id="1-4-1-过去我们写代码："><a href="#1-4-1-过去我们写代码：" class="headerlink" title="1.4.1 过去我们写代码："></a>1.4.1 过去我们写代码：</h4><ul>
<li>1、先一个UserDao接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2、再去写Dao的实现类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;获取用户数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3、然后去写UserService的接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>4、最后写UserService的实现类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao = new UserDaoImpl();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、测试一下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    UserService service = new UserServiceImpl();</span><br><span class="line">    service.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这是我们原来的方式，如果在dao层在增加一个实现类，则需要更改service实现类的代码。如果大量增加实现类，大量更改service代码的话，这种方法也就不适用了。耦合性太高，牵一发而动全身！</p>
<h4 id="1-4-2-如何解决？"><a href="#1-4-2-如何解决？" class="headerlink" title="1.4.2 如何解决？"></a>1.4.2 如何解决？</h4><ul>
<li>我们可以在需要用到它的地方，不去实现它，而是留出一个接口，利用set，我们去代码里修改下。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    // 利用set实现</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改后，就不需要再动service里的代码，用户想调用什么就在外面直接调用。</p>
<ol>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用set注入后，程序不再具有主动性，而是变成可被动的接收到对象。</li>
</ol>
<ul>
<li>这种思想，从本质上解决了问题，外面程序员不再管理对象的创建，系统的耦合性大大降低，可以更加专注在业务的实现上，这就是ioc的原型。</li>
</ul>
<h2 id="1-5-ioc本质"><a href="#1-5-ioc本质" class="headerlink" title="1.5 ioc本质"></a>1.5 ioc本质</h2><ul>
<li>ioc：inverse of controller 控制反转，ioc是一种新的java编程模式。由Spring来负责控制对象的生命周期和对象间的关系，而不需要程序员来管理，Di是实现ioc的一种方法。</li>
<li>Spring容器在初始化时会读取配置文件，根据配置文件或元数据创建组织对象存入容器中，程序使用时从ioc容器中取出需要的对象</li>
</ul>
<p><strong>搞清楚几个问题：</strong></p>
<ul>
<li>谁依赖谁：应用程序依赖于ioc容器</li>
<li>为什么要依赖：应用程序需要ioc容器来提供对象需要的外部资源。</li>
<li>谁注入谁：IOC容器注入应用程序某个对象，应用程序依赖的对象。</li>
<li>注入了什么：注入了某个对象所需要的外部资源（包括对象、资源、常量数据）</li>
</ul>
]]></content>
      <categories>
        <category>工spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【spring】：（2）第一个程序、ioc创建对象方式、spring配置</title>
    <url>/2019/11/18/%E3%80%90Spring%E3%80%91%EF%BC%9A%EF%BC%882%EF%BC%89%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E3%80%81ioc%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F%E3%80%81spring%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<img width="769px" height="369px" src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/%E7%BE%8E%E5%9B%BE/1bffb1a3f9f12ff2a0b3a0c2f83d9eeb_5be671fc13d35.jpg"/>

<h2 id="1、第一个Spring程序"><a href="#1、第一个Spring程序" class="headerlink" title="1、第一个Spring程序"></a>1、第一个Spring程序</h2><ul>
<li>spring的xml配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>先写一个简单的pojo类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    private String str;</span><br><span class="line"></span><br><span class="line">    public String getStr() &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStr(String str) &#123;</span><br><span class="line">        this.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hello&#123;&quot; +</span><br><span class="line">                &quot;str=&apos;&quot; + str + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再在xml中配置bean：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--使用spring来创建对象，在spring这些都称为bean--&gt;</span><br><span class="line">&lt;bean id=&quot;hello&quot; class=&quot;xiaolei.pojo.Hello&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在测试类中，不需要创建Hello对象就获得：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取Spring的上下文对象！</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        //我们的对象现在都在spring中的管理了，我们要使用，直接去里面取出来就可以了</span><br><span class="line">        Hello hello = (Hello) context.getBean(&quot;hello&quot;);</span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong></p>
<ul>
<li>hello对象是谁创建的？答：hello对象是由spring创建的。</li>
<li>hello对象的属性是怎么设置的？答：hello对象的属性是由spring容器设置的。</li>
</ul>
<h2 id="2、ioc创建对象常见方式"><a href="#2、ioc创建对象常见方式" class="headerlink" title="2、ioc创建对象常见方式"></a>2、ioc创建对象常见方式</h2><h4 id="2-1-无参构造"><a href="#2-1-无参构造" class="headerlink" title="2.1 无参构造"></a>2.1 无参构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">    public User() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--注册无参构造--&gt;</span><br><span class="line">&lt;bean id=&quot;user2&quot; class=&quot;Bean.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;hahaha&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<property>标签给构造出来的无参对象赋值</li>
<li>这个便签内的name的值必须是类中存在的setter方法。</li>
<li>至于后面的ref，指向其他类型的bean，如果该bean已经被注册，则ref值指向该bean的id，如果该bean没有被注册，则写该bean的全类限定名。</li>
<li>当然，value也可以写在bean标签的外部，单独写一个标签。</li>
</ul>
<h4 id="2-2-有参构造"><a href="#2-2-有参构造" class="headerlink" title="2.2 有参构造"></a>2.2 有参构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public User(String username,String password)&#123;</span><br><span class="line">    this.password=password;</span><br><span class="line">    this.username=username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;bean.User&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;password&quot; value=&quot;123&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<constructor-arg>标签构造方法的参数</li>
<li>当是有参构造时，name的参数就是构造方法的形参名</li>
<li>如果这个参数变量是javabean，写ref</li>
<li>如果是基本类型，写value</li>
</ul>
<h2 id="3-spring配置"><a href="#3-spring配置" class="headerlink" title="3.spring配置"></a>3.spring配置</h2><h5 id="3-1-别名"><a href="#3-1-别名" class="headerlink" title="3.1 别名"></a>3.1 别名</h5><ul>
<li>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;xiaolei.pojo.User&quot;&gt;</span><br><span class="line">   &lt;constructor-arg name=&quot;name&quot; value=&quot;潇雷&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;alias name=&quot;user&quot; alias=&quot;user2&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-Bean的配置"><a href="#3-2-Bean的配置" class="headerlink" title="3.2 Bean的配置"></a>3.2 Bean的配置</h5><ul>
<li>id:bean的唯一标识符，也就是java对象名。如果没有配置id，name就是默认标识符；如果配置了id，又配置了name，那么name是别名，name可以设置多个别名，可以用逗号，分号，空格隔开。</li>
<li>如果不配置id和name，可以根据applicationContext.getBean(.class)获取对象;</li>
<li>class:bean对象所对应的全限定名</li>
</ul>
<h5 id="3-3-import"><a href="#3-3-import" class="headerlink" title="3.3 import"></a>3.3 import</h5><ul>
<li>一般用于团队开发使用，它可以将多个配置文件，导入合并为一个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作】：入职前的一些规划</title>
    <url>/2019/11/18/%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91%EF%BC%9A%E5%85%A5%E8%81%8C%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%92%E5%92%8C%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[## 一、前言

<p>&emsp;&emsp;未来不可知，上海的职业生涯将正式开始，花自缤纷花自谢，时间太紧了，拼不了爹的自己只能拼命去学习。万一实现了呢？ </p>
<h2 id="二、未来计划（2019-11-2021-9）"><a href="#二、未来计划（2019-11-2021-9）" class="headerlink" title="二、未来计划（2019.11-2021.9）"></a>二、未来计划（2019.11-2021.9）</h2><p>&emsp;&emsp;我希望在这近两年的时间内，竭尽全力的提升自己，努力往（三初一高）的方向发展：    </p>
<ul>
<li><strong>高级的Java开发</strong>；</li>
<li><strong>初级的大数据学习者</strong>；</li>
<li><strong>初级的人工智能学习者</strong>；</li>
<li><strong>初级的vr学习者</strong>；</li>
</ul>
<h2 id="三、着手当下"><a href="#三、着手当下" class="headerlink" title="三、着手当下"></a>三、着手当下</h2><ol>
<li>融入公司，跟上工作节奏。</li>
<li>学习不再片面，有条理的规划出一块内容深入学习</li>
<li>每周抽出20个小时的时间学习新知识。</li>
<li>不打游戏。</li>
<li>开始阅读书籍，书单已经选好。</li>
<li>开始慢慢的理财，关注房价和理财的事儿。</li>
<li>待更。。。</li>
</ol>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【潇雷】：风雨求职路</title>
    <url>/2019/11/14/%E3%80%90%E6%B1%82%E8%81%8C%E3%80%91%E9%82%A3%E4%BA%9B%E5%BF%83%E9%85%B8%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>一转眼，来上海就两个半月了，由夏至秋，天气转凉。  如今找工作的事情终于尘埃入定。  应届生社招时的碰壁让我深受打击，不仅投过实习的岗位，也频频报低价格卑微地换取一份糊口的工作，最后，还是没有放弃，总有适合你的工作在等待你。熬一熬，就过去了。</p>
<h1 id="2-求职"><a href="#2-求职" class="headerlink" title="2.求职"></a>2.求职</h1><h2 id="2-1-简历"><a href="#2-1-简历" class="headerlink" title="2.1 简历"></a>2.1 简历</h2><p>面了一个月，boss沟通八百多家，拉钩5年以下全投过，换来的是寥寥无几的面试机会，从刚开始投简历到找到工作的前两天还改些简历中的小毛病，慢慢的，我发现越到后面，我这简历竟然也能入的了一些大中厂的眼，虽然写的一年工作经验，虽然念的是普通二本非科班，这些特征在浩浩荡荡的简历海洋中本就该沉入海底的，我回头想想，除了那些项目，专业技能外，还有两点：第一是我把本科的CPA专业排名第二写上去了，还有一些奖学金，数学竞赛奖，这些起码能说明我在大学还是学了点东西的。第二是我添加了自己的个人博客和微信公众号，虽然不知道他们会不会看，虽然csdn很low，文章也不多，但是看着还是很努力的。所以个人博客的重要性在面试的时候还是挺加分的。因此，在往后的学习工作中，我将以博客的形式来记录自己的学习和生活。</p>
<h2 id="2-2-面试"><a href="#2-2-面试" class="headerlink" title="2.2 面试"></a>2.2 面试</h2><p><strong>第一家:</strong> 去了个培训机构，叫一堆的人去面试，做了几道nc逻辑题，结果全给做错了，连培训机构都不想要我，hhhh，服了，现在培训机构也挑人了吗？<br><strong>第二家:</strong> 是一个医疗相关的，面试很紧张，终于来了次正经的技术面，下面是面试题  </p>
<p><strong>1.两个linux之间相互传文件怎么做？</strong><br>答：可以使用SCP命令。  </p>
<p><strong>2.mysql查询前十条数据怎么做？</strong><br>select * from emp LIMIT 0,10  </p>
<p><strong>3.js怎么定义数组？</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种  </span><br><span class="line">            var arr = new Array();  </span><br><span class="line">            arr[0] = 123  </span><br><span class="line">            arr[1] = &quot;abc&quot;;  </span><br><span class="line">            arr[5] = false;  </span><br><span class="line">            alert(arr[3]);//undefined  </span><br><span class="line">            alert(arr);//123,abc,,,,false  </span><br><span class="line">            alert(arr[10]);//undefined，不会出现越界异常  </span><br><span class="line">            </span><br><span class="line">            //for in 遍历，未定义的不遍历</span><br><span class="line">            for(var i in arr)&#123;</span><br><span class="line">                alert(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">            //第二种  </span><br><span class="line">            var arr2 = new Array(2);//规定了数组的长度为2  </span><br><span class="line">            arr2[0] = &quot;ddd&quot;;  </span><br><span class="line">            arr2[1] = &quot;www&quot;;  </span><br><span class="line">            alert(arr2);//ddd,www  </span><br><span class="line">            arr2[2] = &quot;fff&quot;;//可以再次添加元素，定义的数组大小对此没有影响  </span><br><span class="line">            alert(arr2);//ddd,www,fff  </span><br><span class="line">                 </span><br><span class="line">            //第三种  </span><br><span class="line">            var arr3 = new Array(true,123,false);  </span><br><span class="line">            alert(arr3);//true,123,false  </span><br><span class="line">              </span><br><span class="line">            //第四种,推荐使用  </span><br><span class="line">            var arr4 = [false,&quot;aaa&quot;,123];  </span><br><span class="line">            alert(arr4);//false,aaa,123</span><br></pre></td></tr></table></figure>
<p><strong>4.vue的条件判断的指令？</strong><br> v-if指令。  </p>
<p><strong>5.git是干嘛的？（版本控制系统）</strong>  </p>
<p><strong>6.java的空指针怎么发生的？口述两行代码，一定会发生空指针？</strong><br>当一个对象不存在时，又调用它的话就会产生空指针异常。<br>object o=null；<br>o.tostring();</p>
<p><strong>7.java的数组越界是怎样的？像ArrayList这种自动增长的，它有没有可能发生越界？为什么？</strong><br>因为arrayList是线程不安全的类，当出现多个线程同时添加元素的时候，此时arrayList就会可能会出现数组越界的问题。  </p>
<p><strong>8.java的自定义注解是怎么解析的？（反射，加载成.class字节码文件）</strong>  </p>
<p><strong>9.定义一个简单的java类，这个类要使它能够表达简单的树形结构，那么这个类的关键特征是什么？</strong><br>就是有两个成员变量，类型是自己，分别指向左子树和右子树（以二叉树为例）。  </p>
<p>中间还问了点单词数学，应该是比较缺人，然后虽然我面试的很差，很多答不上来，但是过了几天还是给我发offer，只不过面试的时候就说就面试来看，我只值6k，我也同意它的说法，但是还是想多面几家试试，就拒绝了，没想到后面才正式开始了苦逼之路。</p>
<p><strong>第三家:</strong> 是一个50人左右的公司，做笔试题的时候，发现难度简直升级，结果笔试题都写不下去，就灰溜溜的回去了，下面是部分笔试题：<br>1.1万个人抢100个红包，如何保证2个人不能抢到同一个红包？<br>2.Git如何放弃工作区的更改？<br>3.写一个方法，处理接收POST类型的JSON参数的请求（参数为name，age）<br>4.POST请求是否可以是url？a=b&amp;c=d的形式请求？如何不可以请说出理由<br>5.设计一个对外服务的接口实现类，在1，2，3这三台主机上（有不同的IP地址）实现负载均衡和顺序轮询机制<br>6.@Scheduled是否为多线程执行，如果是请说明理由，否则请给出解决方案；<br>7.通过Nginx实现：访问<a href="http://test.ab.com，代理请求到http://101.101.1.1.9/" target="_blank" rel="noopener">http://test.ab.com，代理请求到http://101.101.1.1.9/</a><br>8.以JAR包的方式部署temp.jar，请写出部署命令，以及查看Java进程，结束进程</p>
<p><strong>第四家：</strong> 自第三家受打击之后就停下来复习了一周，当时也感觉面试好多，才没投几家就去面试了，所以当时想不把一些机会白白浪费掉，尽管如此，现在想来这种做法特别不好，不能停这么久，而且自己学真的学不到那么多，还是少约点面试，保持两天内一个面试放慢节奏还是比较好的。这家面了一个实习，在上海的团队就他一个人，想想就优点怕，它也看出来我心里的担心，最后可能倒在了沟通问题，以及非全日制，和技术回答的比较死板，考虑问题没有挖很深，很多都是直接从面经上看来，比如hashtable为什么不能为null？  </p>
<p><strong>第五家:</strong> 这次去的是一个岗位上技能啥都不要求的公司，会c，python，java就可以，我以为可能又是骗子公司，没想到公司也没想象中那么小，然后填完信息领到面试官那里，让我上机，实现一个在一个64*64的棋盘上，找出他给的100个点里的最短路径，然后让我开始写，我慢慢的脑子陷入了，感觉到现在都没理解好提议，它给的100个点如何输入到电脑里，一个二维数组，怎么接收这些点，然后算法用迪杰斯特拉算法怎么实现？虽然考研的时候做过这种算法找最短路径的点，但是要真让我实现，还真狠有难度，最后不来了之，自此又陷入自闭。 </p>
<p><strong>第六家，第七家：</strong>  上海无果，开始换城市，突发的选了嘉兴，去嘉兴，嘉善分别面了两家，第一家，做金融还要出差，感觉也不是想招人的意思，随便问的一些aop，springboot热部署等问题，最后我还是因为技术没过关被刷了，然后赶去嘉善面试，这个初创公司感觉面试官的他的三年经验很有水分，随便聊聊项目就过了，基础也没问，后面给我开了8k，最后犹豫再三还是拒了，初创公司不敢去，更别提没个大牛的初创公司。  </p>
<p><strong>第八家：</strong>  开始转战上海，一个金融相关的，我面试的感觉还不错，也感觉有希望进，但是最后不知道什么原因被刷了，这家我还是挺想去的。至少工作还是挺成熟的。 </p>
<p><strong>第九家：</strong> 做智能健身相关的，面试官技术很强，阿里出来的年轻小伙，但是给我的感觉是有点轻蔑，可能这就是牛人吧，最后我都报到6k了，但是我感觉那岗位学的东西也不多，不是纯java开发的。</p>
<p><strong>第十家：</strong> 转眼又过了一周，这家去了轻轻家教，面的问题很灵活，数据结构的知识我真的忘了很多，但是面试官人很好，跟我聊了挺久的。不过自己还是太菜了，我只想说面试还是很看重运气和那岗位的缺人程度的，最后惨败吧。 </p>
<p><strong>第十一家：</strong> 又跑了很远的地方去面试，一个挂羊头卖狗头的，应该是猎头公司，收集了很多面试人的信息资料，随便聊聊就不面了。也没抱希望。  </p>
<p><strong>第十二家：</strong> 这家是挺正规的，离我住处最近的一家了，走路十分钟就到了，面试之前看到这家岗位已经关闭了，面试官是一个很年轻的，这种年轻没多少面试经验的面试官会故意问的比较深，来展示他的能力，根本不从实际情况来面，我就一年的实习经验，把我当几年的面，还问我有没有带过人？也问了一些假大空的问题，消息堆积，重复消费，服务挂了怎么看等等，然后一个小时的面试，直接说，今天的面试到此结束。我就灰溜溜的回去了，不想要我干嘛浪费两个人的时间。</p>
<p><strong>第十三家：</strong> 这次是最后一次面试了，公司环境不错，成立八年的互联网公司，也有自己的产品，面积也很大，然后经过两轮的技术面试和一轮的hr小姐姐沟通后，终于以自己的实力和运气终于拿到了offer，这虽然不是最好的公司，但是这是现阶段最适合我的公司，面试总结的问题就是提升自己的沟通能力，很多东西，你得学会用自己的话来很精准的描述它，这种能力也是需要锻炼出来的，我在回复它邮件的时候，写了未来我们一起加油。  </p>
<h2 id="3感慨"><a href="#3感慨" class="headerlink" title="3感慨"></a>3感慨</h2><p>这一个多月我经历了什么？我得到了什么？<br>我的生活才刚刚开始，未来可期。<br>记两首诗：</p>
<p><strong>《夜》</strong><br>晚风拂我意，<br>荧屏对相思。<br>奔波十里外，<br>另觅橄榄枝。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/850b262531a3b749e927b27f1b28805.jpg" alt="image"></p>
<p><strong>《光》</strong><br>九月憧憬，新奇欲试笔与刀。<br>十月无闻，无花树下羞与闹。<br>十一过半，滩里霓虹光与照。<br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/blog/f8e7a632c8e60cd0d9deb53f2ffd247.jpg" alt="image"></p>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>潇雷哥哥的第一篇博客</title>
    <url>/2019/11/11/%E6%BD%87%E9%9B%B7%E5%93%A5%E5%93%A5%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[# 潇雷

<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul>
<li>列表1</li>
<li>列表2<br>  a 字列表<br>  b 字列表<br>top: 100 数值越大越靠前<br><a href="https://lixiaoyu.cc/" target="_blank" rel="noopener">啸宇的博客</a><br><img src="https://xiaolei1996.oss-cn-shanghai.aliyuncs.com/00c1963b1cff4855bf4b72a84f2e0249" alt="我的头像"><br><em>字体是倾斜的</em><br>#字体也能加粗#</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is a block</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
</search>
